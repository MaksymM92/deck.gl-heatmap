{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log } from '@deck.gl/core';\nimport { ColumnLayer } from '@deck.gl/layers';\nimport { defaultColorRange } from '../utils/color-utils';\nimport { pointToHexbin } from './hexagon-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer from '../aggregation-layer';\nfunction nop() {}\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {\n    type: 'accessor',\n    value: null\n  },\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  lowerPercentile: {\n    type: 'number',\n    value: 0,\n    min: 0,\n    max: 100\n  },\n  upperPercentile: {\n    type: 'number',\n    value: 100,\n    min: 0,\n    max: 100\n  },\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {\n    type: 'accessor',\n    value: null\n  },\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {\n    type: 'number',\n    value: 0,\n    min: 0,\n    max: 100\n  },\n  elevationUpperPercentile: {\n    type: 'number',\n    value: 100,\n    min: 0,\n    max: 100\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n  radius: {\n    type: 'number',\n    value: 1000,\n    min: 1\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  extruded: false,\n  hexagonAggregator: pointToHexbin,\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  material: true,\n  _filterData: {\n    type: 'function',\n    value: null,\n    optional: true\n  }\n};\nexport default class HexagonLayer extends AggregationLayer {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", void 0);\n  }\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.hexagonAggregator,\n      getCellSize: props => props.radius\n    });\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state,\n      vertices: null\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        type: 5130,\n        accessor: 'getPosition'\n      }\n    });\n  }\n  updateState(opts) {\n    super.updateState(opts);\n    if (opts.changeFlags.propsOrDataChanged) {\n      const aggregatorState = this.state.cpuAggregator.updateState(opts, {\n        viewport: this.context.viewport,\n        attributes: this.getAttributes()\n      });\n      if (this.state.aggregatorState.layerData !== aggregatorState.layerData) {\n        const {\n          hexagonVertices\n        } = aggregatorState.layerData || {};\n        this.setState({\n          vertices: hexagonVertices && this.convertLatLngToMeterOffset(hexagonVertices)\n        });\n      }\n      this.setState({\n        aggregatorState\n      });\n    }\n  }\n  convertLatLngToMeterOffset(hexagonVertices) {\n    const {\n      viewport\n    } = this.context;\n    if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n      const vertex0 = hexagonVertices[0];\n      const vertex3 = hexagonVertices[3];\n      const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n      const centroidFlat = viewport.projectFlat(centroid);\n      const {\n        metersPerUnit\n      } = viewport.getDistanceScales(centroid);\n      const vertices = hexagonVertices.map(vt => {\n        const vtFlat = viewport.projectFlat(vt);\n        return [(vtFlat[0] - centroidFlat[0]) * metersPerUnit[0], (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]];\n      });\n      return vertices;\n    }\n    log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n    return null;\n  }\n  getPickingInfo(_ref) {\n    let {\n      info\n    } = _ref;\n    return this.state.cpuAggregator.getPickingInfo({\n      info\n    });\n  }\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n  renderLayers() {\n    const {\n      elevationScale,\n      extruded,\n      coverage,\n      material,\n      transitions\n    } = this.props;\n    const {\n      aggregatorState,\n      vertices\n    } = this.state;\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const updateTriggers = this._getSublayerUpdateTriggers();\n    const geometry = vertices ? {\n      vertices,\n      radius: 1\n    } : {\n      radius: aggregatorState.layerData.radiusCommon || 1,\n      radiusUnits: 'common',\n      angle: 90\n    };\n    return new SubLayerClass({\n      ...geometry,\n      diskResolution: 6,\n      elevationScale,\n      extruded,\n      coverage,\n      material,\n      getFillColor: this._onGetSublayerColor.bind(this),\n      getElevation: this._onGetSublayerElevation.bind(this),\n      transitions: transitions && {\n        getFillColor: transitions.getColorValue || transitions.getColorWeight,\n        getElevation: transitions.getElevationValue || transitions.getElevationWeight\n      }\n    }, this.getSubLayerProps({\n      id: 'hexagon-cell',\n      updateTriggers\n    }), {\n      data: aggregatorState.layerData.data\n    });\n  }\n}\n_defineProperty(HexagonLayer, \"layerName\", 'HexagonLayer');\n_defineProperty(HexagonLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["log","ColumnLayer","defaultColorRange","pointToHexbin","CPUAggregator","AggregationLayer","nop","defaultProps","colorDomain","colorRange","getColorValue","type","value","getColorWeight","colorAggregation","lowerPercentile","min","max","upperPercentile","colorScaleType","onSetColorDomain","elevationDomain","elevationRange","getElevationValue","getElevationWeight","elevationAggregation","elevationLowerPercentile","elevationUpperPercentile","elevationScale","elevationScaleType","onSetElevationDomain","radius","coverage","extruded","hexagonAggregator","getPosition","x","position","material","_filterData","optional","HexagonLayer","constructor","arguments","_defineProperty","initializeState","cpuAggregator","getAggregator","props","getCellSize","state","aggregatorState","vertices","attributeManager","getAttributeManager","add","positions","size","accessor","updateState","opts","changeFlags","propsOrDataChanged","viewport","context","attributes","getAttributes","layerData","hexagonVertices","setState","convertLatLngToMeterOffset","Array","isArray","length","vertex0","vertex3","centroid","centroidFlat","projectFlat","metersPerUnit","getDistanceScales","map","vt","vtFlat","error","getPickingInfo","_ref","info","_onGetSublayerColor","cell","getAccessor","_onGetSublayerElevation","_getSublayerUpdateTriggers","getUpdateTriggers","renderLayers","transitions","SubLayerClass","getSubLayerClass","updateTriggers","geometry","radiusCommon","radiusUnits","angle","diskResolution","getFillColor","bind","getElevation","getSubLayerProps","id","data"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/src/hexagon-layer/hexagon-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  log,\n  Position,\n  Material,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\n\nimport {defaultColorRange} from '../utils/color-utils';\n\nimport {pointToHexbin} from './hexagon-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer, {AggregationLayerProps} from '../aggregation-layer';\n\nimport GL from '@luma.gl/constants';\nimport {AggregateAccessor} from '../types';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction nop() {}\n\nconst defaultProps: DefaultProps<HexagonLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calcuated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  upperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calcuated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  elevationUpperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n\n  radius: {type: 'number', value: 1000, min: 1},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: false,\n  hexagonAggregator: pointToHexbin,\n  getPosition: {type: 'accessor', value: x => x.position},\n  // Optional material for 'lighting' shader module\n  material: true,\n\n  // data filter\n  _filterData: {type: 'function', value: null, optional: true}\n};\n\n/** All properties supported by by HexagonLayer. */\nexport type HexagonLayerProps<DataT = any> = _HexagonLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\n/** Properties added by HexagonLayer. */\ntype _HexagonLayerProps<DataT = any> = {\n  /**\n   * Radius of hexagon bin in meters. The hexagons are pointy-topped (rather than flat-topped).\n   * @default 1000\n   */\n  radius?: number;\n\n  /**\n   * Function to aggregate data into hexagonal bins.\n   * @default d3-hexbin\n   */\n  hexagonAggregator?: (props: any, params: any) => any;\n\n  /**\n   * Color scale input domain.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Hexagon radius multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain. The elevation scale is a linear scale that maps number of counts to elevation.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Hexagon elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter bins and re-calculate color by `upperPercentile`.\n   * Hexagons with color value larger than the `upperPercentile` will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate color by `lowerPercentile`.\n   * Hexagons with color value smaller than the `lowerPercentile` will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate elevation by `elevationUpperPercentile`.\n   * Hexagons with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate elevation by `elevationLowerPercentile`.\n   * Hexagons with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell, default value is 'quantize'.\n   * Supported Values are 'quantize', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell, only supports 'linear'.\n   */\n  elevationScaleType?: 'linear';\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a bin.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into bins, this accessor is called on each cell to get the value that its color is based on.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a bin.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into bins, this accessor is called on each cell to get the value that its elevation is based on.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when cell color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when cell elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * (Experimental) Filter data objects\n   */\n  _filterData: null | ((d: DataT) => boolean);\n};\n\n/** Aggregates data into a hexagon-based heatmap. The color and height of a hexagon are determined based on the objects it contains. */\nexport default class HexagonLayer<DataT, ExtraPropsT extends {} = {}> extends AggregationLayer<\n  DataT,\n  ExtraPropsT & Required<_HexagonLayerProps>\n> {\n  static layerName = 'HexagonLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] & {\n    cpuAggregator: CPUAggregator;\n    aggregatorState: any;\n  };\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.hexagonAggregator,\n      getCellSize: props => props.radius\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state,\n      vertices: null\n    };\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'}\n    });\n    // color and elevation attributes can't be added as attributes\n    // they are calculated using 'getValue' accessor that takes an array of pints.\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n\n    if (opts.changeFlags.propsOrDataChanged) {\n      const aggregatorState = this.state.cpuAggregator.updateState(opts, {\n        viewport: this.context.viewport,\n        attributes: this.getAttributes()\n      });\n      if (this.state.aggregatorState.layerData !== aggregatorState.layerData) {\n        // if user provided custom aggregator and returns hexagonVertices,\n        // Need to recalculate radius and angle based on vertices\n        const {hexagonVertices} = aggregatorState.layerData || {};\n        this.setState({\n          vertices: hexagonVertices && this.convertLatLngToMeterOffset(hexagonVertices)\n        });\n      }\n\n      this.setState({\n        // make a copy of the internal state of cpuAggregator for testing\n        aggregatorState\n      });\n    }\n  }\n\n  convertLatLngToMeterOffset(hexagonVertices) {\n    const {viewport} = this.context;\n    if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n      // get centroid of hexagons\n      const vertex0 = hexagonVertices[0];\n      const vertex3 = hexagonVertices[3];\n\n      const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n      const centroidFlat = viewport.projectFlat(centroid);\n\n      const {metersPerUnit} = viewport.getDistanceScales(centroid);\n\n      // offset all points by centroid to meter offset\n      const vertices = hexagonVertices.map(vt => {\n        const vtFlat = viewport.projectFlat(vt);\n\n        return [\n          (vtFlat[0] - centroidFlat[0]) * metersPerUnit[0],\n          (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]\n        ];\n      });\n\n      return vertices;\n    }\n\n    log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n    return null;\n  }\n\n  getPickingInfo({info}) {\n    return this.state.cpuAggregator.getPickingInfo({info});\n  }\n\n  // create a method for testing\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n\n  // create a method for testing\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  renderLayers() {\n    const {elevationScale, extruded, coverage, material, transitions} = this.props;\n    const {aggregatorState, vertices} = this.state;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const updateTriggers = this._getSublayerUpdateTriggers();\n\n    const geometry = vertices\n      ? {vertices, radius: 1}\n      : {\n          // default geometry\n          radius: aggregatorState.layerData.radiusCommon || 1,\n          radiusUnits: 'common',\n          angle: 90\n        };\n    return new SubLayerClass(\n      {\n        ...geometry,\n        diskResolution: 6,\n        elevationScale,\n        extruded,\n        coverage,\n        material,\n\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      },\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers\n      }),\n      {\n        data: aggregatorState.layerData.data\n      }\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}