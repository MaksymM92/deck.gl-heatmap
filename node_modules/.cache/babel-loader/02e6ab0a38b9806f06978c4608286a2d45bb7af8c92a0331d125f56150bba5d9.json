{"ast":null,"code":"import Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport { parseUniformName, getUniformSetter } from './uniforms';\nimport { VertexShader, FragmentShader } from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport { copyUniform, checkUniformValues } from './uniforms';\nimport { isWebGL2, assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { getPrimitiveDrawMode } from '../webgl-utils/attribute-utils';\nimport { assert } from '../utils/assert';\nimport { uid } from '../utils/utils';\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\nconst GL_SEPARATE_ATTRIBS = 0x8c8d;\nconst V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];\nexport default class Program extends Resource {\n  get [Symbol.toStringTag]() {\n    return 'Program';\n  }\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, props);\n    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n    this._isCached = false;\n    this.initialize(props);\n    Object.seal(this);\n    this._setId(props.id);\n  }\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      hash,\n      vs,\n      fs,\n      varyings,\n      bufferMode = GL_SEPARATE_ATTRIBS\n    } = props;\n    this.hash = hash || '';\n    this.vs = typeof vs === 'string' ? new VertexShader(this.gl, {\n      id: \"\".concat(props.id, \"-vs\"),\n      source: vs\n    }) : vs;\n    this.fs = typeof fs === 'string' ? new FragmentShader(this.gl, {\n      id: \"\".concat(props.id, \"-fs\"),\n      source: fs\n    }) : fs;\n    assert(this.vs instanceof VertexShader);\n    assert(this.fs instanceof FragmentShader);\n    this.uniforms = {};\n    this._textureUniforms = {};\n    if (varyings && varyings.length > 0) {\n      assertWebGL2Context(this.gl);\n      this.varyings = varyings;\n      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n    this._compileAndLink();\n    this._readUniformLocationsFromLinkedProgram();\n    this.configuration = new ProgramConfiguration(this);\n    return this.setProps(props);\n  }\n  delete() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this._isCached) {\n      return this;\n    }\n    return super.delete(options);\n  }\n  setProps(props) {\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n    return this;\n  }\n  draw(_ref) {\n    let {\n      logPriority,\n      drawMode = 4,\n      vertexCount,\n      offset = 0,\n      start,\n      end,\n      isIndexed = false,\n      indexType = 5123,\n      instanceCount = 0,\n      isInstanced = instanceCount > 0,\n      vertexArray = null,\n      transformFeedback,\n      framebuffer,\n      parameters = {},\n      uniforms,\n      samplers\n    } = _ref;\n    if (uniforms || samplers) {\n      log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n      this.setUniforms(uniforms || {});\n    }\n    if (log.priority >= logPriority) {\n      const fb = framebuffer ? framebuffer.id : 'default';\n      const message = \"mode=\".concat(getKey(this.gl, drawMode), \" verts=\").concat(vertexCount, \" \") + \"instances=\".concat(instanceCount, \" indexType=\").concat(getKey(this.gl, indexType), \" \") + \"isInstanced=\".concat(isInstanced, \" isIndexed=\").concat(isIndexed, \" \") + \"Framebuffer=\".concat(fb);\n      log.log(logPriority, message)();\n    }\n    assert(vertexArray);\n    this.gl.useProgram(this.handle);\n    if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {\n      return false;\n    }\n    vertexArray.bindForDraw(vertexCount, instanceCount, () => {\n      if (framebuffer !== undefined) {\n        parameters = Object.assign({}, parameters, {\n          framebuffer\n        });\n      }\n      if (transformFeedback) {\n        const primitiveMode = getPrimitiveDrawMode(drawMode);\n        transformFeedback.begin(primitiveMode);\n      }\n      this._bindTextures();\n      withParameters(this.gl, parameters, () => {\n        if (isIndexed && isInstanced) {\n          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n        } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {\n          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n        } else if (isIndexed) {\n          this.gl.drawElements(drawMode, vertexCount, indexType, offset);\n        } else if (isInstanced) {\n          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n        } else {\n          this.gl.drawArrays(drawMode, offset, vertexCount);\n        }\n      });\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n    return true;\n  }\n  setUniforms() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (log.priority >= 2) {\n      checkUniformValues(uniforms, this.id, this._uniformSetters);\n    }\n    this.gl.useProgram(this.handle);\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      const uniformSetter = this._uniformSetters[uniformName];\n      if (uniformSetter) {\n        let value = uniform;\n        let textureUpdate = false;\n        if (value instanceof Framebuffer) {\n          value = value.texture;\n        }\n        if (value instanceof Texture) {\n          textureUpdate = this.uniforms[uniformName] !== uniform;\n          if (textureUpdate) {\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            }\n            const texture = value;\n            const {\n              textureIndex\n            } = uniformSetter;\n            texture.bind(textureIndex);\n            value = textureIndex;\n            this._textureUniforms[uniformName] = texture;\n          } else {\n            value = uniformSetter.textureIndex;\n          }\n        } else if (this._textureUniforms[uniformName]) {\n          delete this._textureUniforms[uniformName];\n        }\n        if (uniformSetter(value) || textureUpdate) {\n          copyUniform(this.uniforms, uniformName, uniform);\n        }\n      }\n    }\n    return this;\n  }\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n    for (const uniformName in this._textureUniforms) {\n      const texture = this._textureUniforms[uniformName];\n      texture.update();\n      texturesRenderable = texturesRenderable && texture.loaded;\n    }\n    return texturesRenderable;\n  }\n  _bindTextures() {\n    for (const uniformName in this._textureUniforms) {\n      const textureIndex = this._uniformSetters[uniformName].textureIndex;\n      this._textureUniforms[uniformName].bind(textureIndex);\n    }\n  }\n  _createHandle() {\n    return this.gl.createProgram();\n  }\n  _deleteHandle() {\n    this.gl.deleteProgram(this.handle);\n  }\n  _getOptionsFromHandle(handle) {\n    const shaderHandles = this.gl.getAttachedShaders(handle);\n    const opts = {};\n    for (const shaderHandle of shaderHandles) {\n      const type = this.gl.getShaderParameter(this.handle, 35663);\n      switch (type) {\n        case 35633:\n          opts.vs = new VertexShader({\n            handle: shaderHandle\n          });\n          break;\n        case 35632:\n          opts.fs = new FragmentShader({\n            handle: shaderHandle\n          });\n          break;\n        default:\n      }\n    }\n    return opts;\n  }\n  _getParameter(pname) {\n    return this.gl.getProgramParameter(this.handle, pname);\n  }\n  _setId(id) {\n    if (!id) {\n      const programName = this._getName();\n      this.id = uid(programName);\n    }\n  }\n  _getName() {\n    let programName = this.vs.getName() || this.fs.getName();\n    programName = programName.replace(/shader/i, '');\n    programName = programName ? \"\".concat(programName, \"-program\") : 'program';\n    return programName;\n  }\n  _compileAndLink() {\n    const {\n      gl\n    } = this;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))();\n    if (gl.debug || log.level > 0) {\n      const linked = gl.getProgramParameter(this.handle, 35714);\n      if (!linked) {\n        throw new Error(\"Error linking: \".concat(gl.getProgramInfoLog(this.handle)));\n      }\n      gl.validateProgram(this.handle);\n      const validated = gl.getProgramParameter(this.handle, 35715);\n      if (!validated) {\n        throw new Error(\"Error validating: \".concat(gl.getProgramInfoLog(this.handle)));\n      }\n    }\n  }\n  _readUniformLocationsFromLinkedProgram() {\n    const {\n      gl\n    } = this;\n    this._uniformSetters = {};\n    this._uniformCount = this._getParameter(35718);\n    for (let i = 0; i < this._uniformCount; i++) {\n      const info = this.gl.getActiveUniform(this.handle, i);\n      const {\n        name\n      } = parseUniformName(info.name);\n      let location = gl.getUniformLocation(this.handle, name);\n      this._uniformSetters[name] = getUniformSetter(gl, location, info);\n      if (info.size > 1) {\n        for (let l = 0; l < info.size; l++) {\n          location = gl.getUniformLocation(this.handle, \"\".concat(name, \"[\").concat(l, \"]\"));\n          this._uniformSetters[\"\".concat(name, \"[\").concat(l, \"]\")] = getUniformSetter(gl, location, info);\n        }\n      }\n    }\n    this._textureIndexCounter = 0;\n  }\n  getActiveUniforms(uniformIndices, pname) {\n    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);\n  }\n  getUniformBlockIndex(blockName) {\n    return this.gl2.getUniformBlockIndex(this.handle, blockName);\n  }\n  getActiveUniformBlockParameter(blockIndex, pname) {\n    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n  }\n  uniformBlockBinding(blockIndex, blockBinding) {\n    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n  }\n}","map":{"version":3,"names":["Resource","Texture","Framebuffer","parseUniformName","getUniformSetter","VertexShader","FragmentShader","ProgramConfiguration","copyUniform","checkUniformValues","isWebGL2","assertWebGL2Context","withParameters","log","getKey","getPrimitiveDrawMode","assert","uid","LOG_PROGRAM_PERF_PRIORITY","GL_SEPARATE_ATTRIBS","V6_DEPRECATED_METHODS","Program","Symbol","toStringTag","constructor","gl","props","arguments","length","undefined","stubRemovedMethods","_isCached","initialize","Object","seal","_setId","id","hash","vs","fs","varyings","bufferMode","concat","source","uniforms","_textureUniforms","gl2","transformFeedbackVaryings","handle","_compileAndLink","_readUniformLocationsFromLinkedProgram","configuration","setProps","delete","options","setUniforms","draw","_ref","logPriority","drawMode","vertexCount","offset","start","end","isIndexed","indexType","instanceCount","isInstanced","vertexArray","transformFeedback","framebuffer","parameters","samplers","deprecated","priority","fb","message","useProgram","_areTexturesRenderable","bindForDraw","assign","primitiveMode","begin","_bindTextures","drawElementsInstanced","isNaN","drawRangeElements","drawElements","drawArraysInstanced","drawArrays","_uniformSetters","uniformName","uniform","uniformSetter","value","textureUpdate","texture","textureIndex","_textureIndexCounter","bind","texturesRenderable","update","loaded","_createHandle","createProgram","_deleteHandle","deleteProgram","_getOptionsFromHandle","shaderHandles","getAttachedShaders","opts","shaderHandle","type","getShaderParameter","_getParameter","pname","getProgramParameter","programName","_getName","getName","replace","attachShader","time","linkProgram","timeEnd","debug","level","linked","Error","getProgramInfoLog","validateProgram","validated","_uniformCount","i","info","getActiveUniform","name","location","getUniformLocation","size","l","getActiveUniforms","uniformIndices","getUniformBlockIndex","blockName","getActiveUniformBlockParameter","blockIndex","uniformBlockBinding","blockBinding"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@luma.gl/webgl/src/classes/program.js"],"sourcesContent":["import GL from '@luma.gl/constants';\n\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport {parseUniformName, getUniformSetter} from './uniforms';\nimport {VertexShader, FragmentShader} from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport {copyUniform, checkUniformValues} from './uniforms';\n\nimport {isWebGL2, assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {getKey} from '../webgl-utils/constants-to-keys';\nimport {getPrimitiveDrawMode} from '../webgl-utils/attribute-utils';\nimport {assert} from '../utils/assert';\nimport {uid} from '../utils/utils';\n\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\n\nconst GL_SEPARATE_ATTRIBS = 0x8c8d;\n\nconst V6_DEPRECATED_METHODS = [\n  'setVertexArray',\n  'setAttributes',\n  'setBuffers',\n  'unsetBuffers',\n\n  'use',\n  'getUniformCount',\n  'getUniformInfo',\n  'getUniformLocation',\n  'getUniformValue',\n\n  'getVarying',\n  'getFragDataLocation',\n  'getAttachedShaders',\n  'getAttributeCount',\n  'getAttributeLocation',\n  'getAttributeInfo'\n];\n\nexport default class Program extends Resource {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Program';\n  }\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n\n    // Experimental flag to avoid deleting Program object while it is cached\n    this._isCached = false;\n\n    this.initialize(props);\n\n    Object.seal(this);\n\n    this._setId(props.id);\n  }\n\n  initialize(props = {}) {\n    const {hash, vs, fs, varyings, bufferMode = GL_SEPARATE_ATTRIBS} = props;\n\n    this.hash = hash || ''; // Used by ProgramManager\n\n    // Create shaders if needed\n    this.vs =\n      typeof vs === 'string' ? new VertexShader(this.gl, {id: `${props.id}-vs`, source: vs}) : vs;\n    this.fs =\n      typeof fs === 'string' ? new FragmentShader(this.gl, {id: `${props.id}-fs`, source: fs}) : fs;\n    assert(this.vs instanceof VertexShader);\n    assert(this.fs instanceof FragmentShader);\n\n    // uniforms\n    this.uniforms = {};\n\n    this._textureUniforms = {};\n\n    // Setup varyings if supplied\n    if (varyings && varyings.length > 0) {\n      assertWebGL2Context(this.gl);\n      this.varyings = varyings;\n      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n\n    this._compileAndLink();\n    this._readUniformLocationsFromLinkedProgram();\n    this.configuration = new ProgramConfiguration(this);\n\n    return this.setProps(props);\n  }\n\n  delete(options = {}) {\n    if (this._isCached) {\n      // This object is cached, do not delete\n      return this;\n    }\n    return super.delete(options);\n  }\n\n  setProps(props) {\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n    return this;\n  }\n\n  // A good thing about the WebGL API is that there are so many ways to draw things ;)\n  // This function unifies those ways into a single call using common parameters with sane defaults\n  draw({\n    logPriority, // Probe log priority, enables Model to do more integrated logging\n\n    drawMode = GL.TRIANGLES,\n    vertexCount,\n    offset = 0,\n    start,\n    end,\n    isIndexed = false,\n    indexType = GL.UNSIGNED_SHORT,\n    instanceCount = 0,\n    isInstanced = instanceCount > 0,\n\n    vertexArray = null,\n    transformFeedback,\n    framebuffer,\n    parameters = {},\n\n    // Deprecated\n    uniforms,\n    samplers\n  }) {\n    if (uniforms || samplers) {\n      // DEPRECATED: v7.0 (deprecated earlier but warning not properly implemented)\n      log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n      this.setUniforms(uniforms || {});\n    }\n\n    if (log.priority >= logPriority) {\n      const fb = framebuffer ? framebuffer.id : 'default';\n      const message =\n        `mode=${getKey(this.gl, drawMode)} verts=${vertexCount} ` +\n        `instances=${instanceCount} indexType=${getKey(this.gl, indexType)} ` +\n        `isInstanced=${isInstanced} isIndexed=${isIndexed} ` +\n        `Framebuffer=${fb}`;\n      log.log(logPriority, message)();\n    }\n\n    // TODO - move vertex array binding and transform feedback binding to withParameters?\n    assert(vertexArray);\n\n    this.gl.useProgram(this.handle);\n\n    if (\n      // Note: async textures set as uniforms might still be loading.\n      // Now that all uniforms have been updated, check if any texture\n      // in the uniforms is not yet initialized, then we don't draw\n      !this._areTexturesRenderable() ||\n      // Avoid WebGL draw call when not rendering any data\n      vertexCount === 0 ||\n      (isInstanced && instanceCount === 0)\n    ) {\n      return false;\n    }\n\n    vertexArray.bindForDraw(vertexCount, instanceCount, () => {\n      if (framebuffer !== undefined) {\n        parameters = Object.assign({}, parameters, {framebuffer});\n      }\n\n      if (transformFeedback) {\n        const primitiveMode = getPrimitiveDrawMode(drawMode);\n        transformFeedback.begin(primitiveMode);\n      }\n\n      this._bindTextures();\n\n      withParameters(this.gl, parameters, () => {\n        // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension\n        if (isIndexed && isInstanced) {\n          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n        } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {\n          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n        } else if (isIndexed) {\n          this.gl.drawElements(drawMode, vertexCount, indexType, offset);\n        } else if (isInstanced) {\n          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n        } else {\n          this.gl.drawArrays(drawMode, offset, vertexCount);\n        }\n      });\n\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n\n    return true;\n  }\n\n  setUniforms(uniforms = {}) {\n    if (log.priority >= 2) {\n      checkUniformValues(uniforms, this.id, this._uniformSetters);\n    }\n\n    this.gl.useProgram(this.handle);\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      const uniformSetter = this._uniformSetters[uniformName];\n\n      if (uniformSetter) {\n        let value = uniform;\n        let textureUpdate = false;\n\n        if (value instanceof Framebuffer) {\n          value = value.texture;\n        }\n        if (value instanceof Texture) {\n          textureUpdate = this.uniforms[uniformName] !== uniform;\n\n          if (textureUpdate) {\n            // eslint-disable-next-line max-depth\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            }\n\n            // Bind texture to index\n            const texture = value;\n            const {textureIndex} = uniformSetter;\n\n            texture.bind(textureIndex);\n            value = textureIndex;\n\n            this._textureUniforms[uniformName] = texture;\n          } else {\n            value = uniformSetter.textureIndex;\n          }\n        } else if (this._textureUniforms[uniformName]) {\n          delete this._textureUniforms[uniformName];\n        }\n\n        // NOTE(Tarek): uniformSetter returns whether\n        //   value had to be updated or not.\n        if (uniformSetter(value) || textureUpdate) {\n          copyUniform(this.uniforms, uniformName, uniform);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  // Checks if all texture-values uniforms are renderable (i.e. loaded)\n  // Update a texture if needed (e.g. from video)\n  // Note: This is currently done before every draw call\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n\n    for (const uniformName in this._textureUniforms) {\n      const texture = this._textureUniforms[uniformName];\n      texture.update();\n      texturesRenderable = texturesRenderable && texture.loaded;\n    }\n\n    return texturesRenderable;\n  }\n\n  // Binds textures\n  // Note: This is currently done before every draw call\n  _bindTextures() {\n    for (const uniformName in this._textureUniforms) {\n      const textureIndex = this._uniformSetters[uniformName].textureIndex;\n      this._textureUniforms[uniformName].bind(textureIndex);\n    }\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createProgram();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteProgram(this.handle);\n  }\n\n  // Extract opts needed to initialize a `Program` from an independently created WebGLProgram handle\n  _getOptionsFromHandle(handle) {\n    const shaderHandles = this.gl.getAttachedShaders(handle);\n    const opts = {};\n    for (const shaderHandle of shaderHandles) {\n      const type = this.gl.getShaderParameter(this.handle, GL.SHADER_TYPE);\n      switch (type) {\n        case GL.VERTEX_SHADER:\n          // @ts-ignore\n          opts.vs = new VertexShader({handle: shaderHandle});\n          break;\n        case GL.FRAGMENT_SHADER:\n          // @ts-ignore\n          opts.fs = new FragmentShader({handle: shaderHandle});\n          break;\n        default:\n      }\n    }\n    return opts;\n  }\n\n  _getParameter(pname) {\n    return this.gl.getProgramParameter(this.handle, pname);\n  }\n\n  // If program is not named, name it after shader names\n  // TODO - this.id will already have been initialized\n  _setId(id) {\n    if (!id) {\n      const programName = this._getName();\n      this.id = uid(programName);\n    }\n  }\n\n  // Generate a default name for the program based on names of the shaders\n  _getName() {\n    let programName = this.vs.getName() || this.fs.getName();\n    programName = programName.replace(/shader/i, '');\n    programName = programName ? `${programName}-program` : 'program';\n    return programName;\n  }\n\n  _compileAndLink() {\n    const {gl} = this;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n\n    // Avoid checking program linking error in production\n    // @ts-ignore\n    if (gl.debug || log.level > 0) {\n      const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);\n      if (!linked) {\n        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n\n      gl.validateProgram(this.handle);\n      const validated = gl.getProgramParameter(this.handle, gl.VALIDATE_STATUS);\n      if (!validated) {\n        throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n    }\n  }\n\n  // query uniform locations and build name to setter map.\n  // TODO - This overlaps with ProgramConfiguration?\n  _readUniformLocationsFromLinkedProgram() {\n    const {gl} = this;\n    this._uniformSetters = {};\n    this._uniformCount = this._getParameter(GL.ACTIVE_UNIFORMS);\n    for (let i = 0; i < this._uniformCount; i++) {\n      const info = this.gl.getActiveUniform(this.handle, i);\n      const {name} = parseUniformName(info.name);\n      let location = gl.getUniformLocation(this.handle, name);\n      this._uniformSetters[name] = getUniformSetter(gl, location, info);\n      if (info.size > 1) {\n        for (let l = 0; l < info.size; l++) {\n          location = gl.getUniformLocation(this.handle, `${name}[${l}]`);\n          this._uniformSetters[`${name}[${l}]`] = getUniformSetter(gl, location, info);\n        }\n      }\n    }\n    this._textureIndexCounter = 0;\n  }\n\n  // TO BE REMOVED in v7?\n\n  // Rretrieves information about active uniforms identifed by their indices (`uniformIndices`)\n  // https://\n  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniforms\n  getActiveUniforms(uniformIndices, pname) {\n    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);\n  }\n\n  // Retrieves the index of a uniform block\n  getUniformBlockIndex(blockName) {\n    return this.gl2.getUniformBlockIndex(this.handle, blockName);\n  }\n\n  // Retrieves information about an active uniform block (`blockIndex`)\n  // https://\n  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniformBlockParameter\n  getActiveUniformBlockParameter(blockIndex, pname) {\n    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n  }\n\n  // Binds a uniform block (`blockIndex`) to a specific binding point (`blockBinding`)\n  uniformBlockBinding(blockIndex, blockBinding) {\n    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}