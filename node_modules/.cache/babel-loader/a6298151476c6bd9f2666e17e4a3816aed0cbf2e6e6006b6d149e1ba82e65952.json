{"ast":null,"code":"import { Matrix4 } from '@math.gl/core';\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_MODULE_OPTIONS = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;\n  let prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const uniforms = {};\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);\n  }\n  return uniforms;\n}\nconst common = \"varying vec4 project_vPositionWorld;\\nvarying vec3 project_vNormalWorld;\\n\\nvec4 project_getPosition_World() {\\n  return project_vPositionWorld;\\n}\\n\\nvec3 project_getNormal_World() {\\n  return project_vNormalWorld;\\n}\\n\";\nconst vs = \"\".concat(common, \"\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewProjectionMatrix;\\nuniform vec3 cameraPositionWorld;\\n\\nstruct World {\\n  vec3 position;\\n  vec3 normal;\\n};\\n\\nWorld world;\\n\\nvoid project_setPosition(vec4 position) {\\n  project_vPositionWorld = position;\\n}\\n\\nvoid project_setNormal(vec3 normal) {\\n  project_vNormalWorld = normal;\\n}\\n\\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\\n  world.position = position;\\n  world.normal = normal;\\n}\\n\\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\\n  world.normal = mat3(modelMatrix) * normal;\\n}\\n\\nvec4 project_model_to_clipspace(vec4 position) {\\n  return viewProjectionMatrix * modelMatrix * position;\\n}\\n\\nvec4 project_model_to_clipspace(vec3 position) {\\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\\n}\\n\\nvec4 project_world_to_clipspace(vec3 position) {\\n  return viewProjectionMatrix * vec4(position, 1.);\\n}\\n\\nvec4 project_view_to_clipspace(vec3 position) {\\n  return projectionMatrix * vec4(position, 1.);\\n}\\n\\nvec4 project_to_clipspace(vec3 position) {\\n  return viewProjectionMatrix * vec4(position, 1.);\\n}\\n\");\nconst fs = \"\\n\".concat(common);\nexport const project = {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n};","map":{"version":3,"names":["Matrix4","IDENTITY_MATRIX","DEFAULT_MODULE_OPTIONS","modelMatrix","viewMatrix","projectionMatrix","cameraPositionWorld","getUniforms","opts","arguments","length","undefined","prevUniforms","uniforms","viewProjectionMatrix","multiplyRight","common","vs","concat","fs","project","name"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@luma.gl/shadertools/src/modules/project/project.js"],"sourcesContent":["/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport {Matrix4} from '@math.gl/core';\n\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nconst DEFAULT_MODULE_OPTIONS = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {\n  // const viewProjectionInverse = viewProjection.invert();\n  // viewInverseMatrix: view.invert(),\n  // viewProjectionInverseMatrix: viewProjectionInverse\n\n  const uniforms = {};\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n\n  // COMPOSITE UNIFORMS\n  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(\n      opts.viewMatrix\n    );\n  }\n\n  return uniforms;\n}\n\nconst common = `\\\nvarying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n`;\n\nconst vs = `\\\n${common}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`;\n\nconst fs = `\n${common}\\\n`;\n\n/** @type {ShaderModule} */\nexport const project = {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n};\n"],"mappings":"AAEA,SAAQA,OAAR,QAAsB,eAAtB;AAEA,MAAMC,eAAe,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,CAAxB;AAEA,MAAMC,sBAAsB,GAAG;EAC7BC,WAAW,EAAEF,eADgB;EAE7BG,UAAU,EAAEH,eAFiB;EAG7BI,gBAAgB,EAAEJ,eAHW;EAI7BK,mBAAmB,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP;AAJQ,CAA/B;AAOA,SAASC,WAATA,CAAA,EAAuE;EAAA,IAAlDC,IAAkD,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA3CP,sBAA2C;EAAA,IAAnBU,YAAmB,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAJ,EAAI;EAKrE,MAAMI,QAAQ,GAAG,EAAjB;EACA,IAAIL,IAAI,CAACL,WAAL,KAAqBQ,SAAzB,EAAoC;IAClCE,QAAQ,CAACV,WAAT,GAAuBK,IAAI,CAACL,WAA5B;EACD;EACD,IAAIK,IAAI,CAACJ,UAAL,KAAoBO,SAAxB,EAAmC;IACjCE,QAAQ,CAACT,UAAT,GAAsBI,IAAI,CAACJ,UAA3B;EACD;EACD,IAAII,IAAI,CAACH,gBAAL,KAA0BM,SAA9B,EAAyC;IACvCE,QAAQ,CAACR,gBAAT,GAA4BG,IAAI,CAACH,gBAAjC;EACD;EACD,IAAIG,IAAI,CAACF,mBAAL,KAA6BK,SAAjC,EAA4C;IAC1CE,QAAQ,CAACP,mBAAT,GAA+BE,IAAI,CAACF,mBAApC;EACD;EAGD,IAAIE,IAAI,CAACH,gBAAL,KAA0BM,SAA1B,IAAuCH,IAAI,CAACJ,UAAL,KAAoBO,SAA/D,EAA0E;IACxEE,QAAQ,CAACC,oBAAT,GAAgC,IAAId,OAAJ,CAAYQ,IAAI,CAACH,gBAAjB,EAAmCU,aAAnC,CAC9BP,IAAI,CAACJ,UADyB,CAAhC;EAGD;EAED,OAAOS,QAAP;AACD;AAED,MAAMG,MAAM,iOAAZ;AAaA,MAAMC,EAAE,MAAAC,MAAA,CACNF,MADM,4uCAAR;AAwDA,MAAMG,EAAE,QAAAD,MAAA,CACNF,MADM,CAAR;AAKA,OAAO,MAAMI,OAAO,GAAG;EACrBC,IAAI,EAAE,SADe;EAErBd,WAFqB;EAGrBU,EAHqB;EAIrBE;AAJqB,CAAhB"},"metadata":{},"sourceType":"module","externalDependencies":[]}