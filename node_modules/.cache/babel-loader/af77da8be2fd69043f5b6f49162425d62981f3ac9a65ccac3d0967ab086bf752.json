{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/webgl';\nexport default class Tesselator {\n  constructor(opts) {\n    _defineProperty(this, \"opts\", void 0);\n    _defineProperty(this, \"typedArrayManager\", void 0);\n    _defineProperty(this, \"indexStarts\", [0]);\n    _defineProperty(this, \"vertexStarts\", [0]);\n    _defineProperty(this, \"vertexCount\", 0);\n    _defineProperty(this, \"instanceCount\", 0);\n    _defineProperty(this, \"attributes\", void 0);\n    _defineProperty(this, \"_attributeDefs\", void 0);\n    _defineProperty(this, \"data\", void 0);\n    _defineProperty(this, \"getGeometry\", void 0);\n    _defineProperty(this, \"geometryBuffer\", void 0);\n    _defineProperty(this, \"buffers\", void 0);\n    _defineProperty(this, \"positionSize\", void 0);\n    _defineProperty(this, \"normalize\", void 0);\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n  }\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n    if (geometryBuffer) {\n      assert(data.startIndices);\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n      if (!normalize) {\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n    if (Array.isArray(dataChanged)) {\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n  updatePartialGeometry(_ref) {\n    let {\n      startRow,\n      endRow\n    } = _ref;\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      return null;\n    }\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n  _allocate(instanceCount, copy) {\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n  _rebuildGeometry(dataRange) {\n    if (!this.data) {\n      return;\n    }\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n    if (!dataRange) {\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = normalizedGeometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n      }, startRow, endRow);\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n    this._allocate(instanceCount, Boolean(dataRange));\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    const context = {};\n    this._forEachGeometry((geometry, dataIndex) => {\n      const normalizedGeometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(normalizedGeometry, context);\n    }, startRow, endRow);\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}","map":{"version":3,"names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","constructor","opts","_defineProperty","attributes","typedArrayManager","_attributeDefs","updateGeometry","Object","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","_ref","startRow","endRow","value","ArrayBuffer","isView","offset","stride","_allocate","instanceCount","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","geometry","indexStarts","vertexStarts","Infinity","normalizedData","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","length","byteStride","accessor","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/utils/tesselator.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}