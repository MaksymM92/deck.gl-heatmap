{"ast":null,"code":"import { log } from '@deck.gl/core';\nexport function getScale(domain, range, scaleFunction) {\n  const scale = scaleFunction;\n  scale.domain = () => domain;\n  scale.range = () => range;\n  return scale;\n}\nexport function getQuantizeScale(domain, range) {\n  const scaleFunction = value => quantizeScale(domain, range, value);\n  return getScale(domain, range, scaleFunction);\n}\nexport function getLinearScale(domain, range) {\n  const scaleFunction = value => linearScale(domain, range, value);\n  return getScale(domain, range, scaleFunction);\n}\nexport function getQuantileScale(domain, range) {\n  const sortedDomain = domain.sort(ascending);\n  let i = 0;\n  const n = Math.max(1, range.length);\n  const thresholds = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n  const scaleFunction = value => thresholdsScale(thresholds, range, value);\n  scaleFunction.thresholds = () => thresholds;\n  return getScale(domain, range, scaleFunction);\n}\nfunction ascending(a, b) {\n  return a - b;\n}\nfunction threshold(domain, fraction) {\n  const domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\nfunction bisectRight(a, x) {\n  let lo = 0;\n  let hi = a.length;\n  while (lo < hi) {\n    const mid = lo + hi >>> 1;\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nfunction thresholdsScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\nfunction ordinalScale(domain, domainMap, range, value) {\n  const key = \"\".concat(value);\n  let d = domainMap.get(key);\n  if (d === undefined) {\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n  return range[(d - 1) % range.length];\n}\nexport function getOrdinalScale(domain, range) {\n  const domainMap = new Map();\n  const uniqueDomain = [];\n  for (const d of domain) {\n    const key = \"\".concat(d);\n    if (!domainMap.has(key)) {\n      domainMap.set(key, uniqueDomain.push(d));\n    }\n  }\n  const scaleFunction = value => ordinalScale(uniqueDomain, domainMap, range, value);\n  return getScale(domain, range, scaleFunction);\n}\nexport function quantizeScale(domain, range, value) {\n  const domainRange = domain[1] - domain[0];\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n  const step = domainRange / range.length;\n  const idx = Math.floor((value - domain[0]) / step);\n  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n  return range[clampIdx];\n}\nexport function linearScale(domain, range, value) {\n  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];\n}\nfunction notNullOrUndefined(d) {\n  return d !== undefined && d !== null;\n}\nexport function unique(values) {\n  const results = [];\n  values.forEach(v => {\n    if (!results.includes(v) && notNullOrUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\nfunction getTruthyValues(data, valueAccessor) {\n  const values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n  return values.filter(notNullOrUndefined);\n}\nexport function getLinearDomain(data, valueAccessor) {\n  const sorted = getTruthyValues(data, valueAccessor).sort();\n  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\nexport function getQuantileDomain(data, valueAccessor) {\n  return getTruthyValues(data, valueAccessor);\n}\nexport function getOrdinalDomain(data, valueAccessor) {\n  return unique(getTruthyValues(data, valueAccessor));\n}\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n  switch (scaleType) {\n    case 'quantize':\n    case 'linear':\n      return getLinearDomain(data, valueAccessor);\n    case 'quantile':\n      return getQuantileDomain(data, valueAccessor);\n    case 'ordinal':\n      return getOrdinalDomain(data, valueAccessor);\n    default:\n      return getLinearDomain(data, valueAccessor);\n  }\n}\nexport function clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nexport function getScaleFunctionByScaleType(scaleType) {\n  switch (scaleType) {\n    case 'quantize':\n      return getQuantizeScale;\n    case 'linear':\n      return getLinearScale;\n    case 'quantile':\n      return getQuantileScale;\n    case 'ordinal':\n      return getOrdinalScale;\n    default:\n      return getQuantizeScale;\n  }\n}","map":{"version":3,"names":["log","getScale","domain","range","scaleFunction","scale","getQuantizeScale","value","quantizeScale","getLinearScale","linearScale","getQuantileScale","sortedDomain","sort","ascending","i","n","Math","max","length","thresholds","Array","threshold","thresholdsScale","a","b","fraction","domainLength","domainFraction","lowIndex","floor","low","high","bisectRight","x","lo","hi","mid","ordinalScale","domainMap","key","concat","d","get","undefined","push","set","getOrdinalScale","Map","uniqueDomain","has","domainRange","warn","step","idx","clampIdx","min","notNullOrUndefined","unique","values","results","forEach","v","includes","getTruthyValues","data","valueAccessor","map","filter","getLinearDomain","sorted","getQuantileDomain","getOrdinalDomain","getScaleDomain","scaleType","clamp","getScaleFunctionByScaleType"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/scale-utils.js"],"sourcesContent":["import { log } from '@deck.gl/core';\nexport function getScale(domain, range, scaleFunction) {\n  const scale = scaleFunction;\n\n  scale.domain = () => domain;\n\n  scale.range = () => range;\n\n  return scale;\n}\nexport function getQuantizeScale(domain, range) {\n  const scaleFunction = value => quantizeScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function getLinearScale(domain, range) {\n  const scaleFunction = value => linearScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function getQuantileScale(domain, range) {\n  const sortedDomain = domain.sort(ascending);\n  let i = 0;\n  const n = Math.max(1, range.length);\n  const thresholds = new Array(n - 1);\n\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n\n  const scaleFunction = value => thresholdsScale(thresholds, range, value);\n\n  scaleFunction.thresholds = () => thresholds;\n\n  return getScale(domain, range, scaleFunction);\n}\n\nfunction ascending(a, b) {\n  return a - b;\n}\n\nfunction threshold(domain, fraction) {\n  const domainLength = domain.length;\n\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a, x) {\n  let lo = 0;\n  let hi = a.length;\n\n  while (lo < hi) {\n    const mid = lo + hi >>> 1;\n\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  return lo;\n}\n\nfunction thresholdsScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\n\nfunction ordinalScale(domain, domainMap, range, value) {\n  const key = \"\".concat(value);\n  let d = domainMap.get(key);\n\n  if (d === undefined) {\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n\n  return range[(d - 1) % range.length];\n}\n\nexport function getOrdinalScale(domain, range) {\n  const domainMap = new Map();\n  const uniqueDomain = [];\n\n  for (const d of domain) {\n    const key = \"\".concat(d);\n\n    if (!domainMap.has(key)) {\n      domainMap.set(key, uniqueDomain.push(d));\n    }\n  }\n\n  const scaleFunction = value => ordinalScale(uniqueDomain, domainMap, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function quantizeScale(domain, range, value) {\n  const domainRange = domain[1] - domain[0];\n\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n\n  const step = domainRange / range.length;\n  const idx = Math.floor((value - domain[0]) / step);\n  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n  return range[clampIdx];\n}\nexport function linearScale(domain, range, value) {\n  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];\n}\n\nfunction notNullOrUndefined(d) {\n  return d !== undefined && d !== null;\n}\n\nexport function unique(values) {\n  const results = [];\n  values.forEach(v => {\n    if (!results.includes(v) && notNullOrUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\n\nfunction getTruthyValues(data, valueAccessor) {\n  const values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n  return values.filter(notNullOrUndefined);\n}\n\nexport function getLinearDomain(data, valueAccessor) {\n  const sorted = getTruthyValues(data, valueAccessor).sort();\n  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\nexport function getQuantileDomain(data, valueAccessor) {\n  return getTruthyValues(data, valueAccessor);\n}\nexport function getOrdinalDomain(data, valueAccessor) {\n  return unique(getTruthyValues(data, valueAccessor));\n}\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n  switch (scaleType) {\n    case 'quantize':\n    case 'linear':\n      return getLinearDomain(data, valueAccessor);\n\n    case 'quantile':\n      return getQuantileDomain(data, valueAccessor);\n\n    case 'ordinal':\n      return getOrdinalDomain(data, valueAccessor);\n\n    default:\n      return getLinearDomain(data, valueAccessor);\n  }\n}\nexport function clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nexport function getScaleFunctionByScaleType(scaleType) {\n  switch (scaleType) {\n    case 'quantize':\n      return getQuantizeScale;\n\n    case 'linear':\n      return getLinearScale;\n\n    case 'quantile':\n      return getQuantileScale;\n\n    case 'ordinal':\n      return getOrdinalScale;\n\n    default:\n      return getQuantizeScale;\n  }\n}\n//# sourceMappingURL=scale-utils.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}