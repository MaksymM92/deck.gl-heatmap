{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { LineLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { generateContours } from './contour-utils';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\nconst defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM',\n  contours: {\n    type: 'object',\n    value: [{\n      threshold: DEFAULT_THRESHOLD\n    }],\n    optional: true,\n    compare: 3\n  },\n  zOffset: 0.005\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ContourLayer extends GridAggregationLayer {\n  initializeState() {\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n  updateState(opts) {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {\n      oldProps,\n      props\n    } = opts;\n    const {\n      aggregationDirty\n    } = this.state;\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n      this._updateThresholdData(opts.props);\n    }\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n  renderLayers() {\n    const {\n      contourSegments,\n      contourPolygons\n    } = this.state.contourData;\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n    const lineLayer = contourSegments && contourSegments.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({\n      id: 'lines'\n    }), {\n      data: this.state.contourData.contourSegments,\n      getSourcePosition: d => d.start,\n      getTargetPosition: d => d.end,\n      getColor: d => d.contour.color || DEFAULT_COLOR,\n      getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n    });\n    const bandsLayer = contourPolygons && contourPolygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({\n      id: 'bands'\n    }), {\n      data: this.state.contourData.contourPolygons,\n      getPolygon: d => d.vertices,\n      getFillColor: d => d.contour.color || DEFAULT_COLOR\n    });\n    return [lineLayer, bandsLayer];\n  }\n  updateAggregationState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const {\n      cellSize,\n      coordinateSystem\n    } = props;\n    const {\n      viewport\n    } = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const {\n      dimensions\n    } = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      data,\n      weights\n    } = dimensions;\n    let {\n      boundingBox\n    } = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({\n        boundingBox\n      });\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {\n        gridOffset,\n        translation,\n        width,\n        height,\n        numCol,\n        numRow\n      } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(),\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || this.isAggregationDirty(opts, {\n      dimension: data,\n      compareAll: gpuAggregation\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n  _generateContours() {\n    const {\n      numCol,\n      numRow,\n      gridOrigin,\n      gridOffset,\n      thresholdData\n    } = this.state;\n    const {\n      count\n    } = this.state.weights;\n    let {\n      aggregationData\n    } = count;\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n    const {\n      cellWeights\n    } = GPUGridAggregator.getCellData({\n      countsData: aggregationData\n    });\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n    this.setState({\n      contourData\n    });\n  }\n  _updateThresholdData(props) {\n    const {\n      contours,\n      zOffset\n    } = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n    this.setState({\n      thresholdData\n    });\n  }\n}\n_defineProperty(ContourLayer, \"layerName\", 'ContourLayer');\n_defineProperty(ContourLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["LineLayer","SolidPolygonLayer","generateContours","log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","getBoundingBox","getGridParams","GridAggregationLayer","DEFAULT_COLOR","DEFAULT_STROKE_WIDTH","DEFAULT_THRESHOLD","defaultProps","cellSize","type","min","max","value","getPosition","x","position","getWeight","gpuAggregation","aggregation","contours","threshold","optional","compare","zOffset","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ContourLayer","initializeState","initializeAggregationLayer","dimensions","setState","contourData","projectPoints","count","size","operation","SUM","attributeManager","getAttributeManager","add","accessor","fp64","use64bitPositions","updateState","opts","contoursChanged","oldProps","aggregationDirty","state","_updateThresholdData","getNumInstances","_generateContours","renderLayers","contourSegments","contourPolygons","LinesSubLayerClass","getSubLayerClass","BandsSubLayerClass","lineLayer","length","getSubLayerProps","id","getSourcePosition","d","start","getTargetPosition","end","getColor","contour","color","getWidth","strokeWidth","bandsLayer","getPolygon","vertices","getFillColor","updateAggregationState","coordinateSystem","viewport","context","cellSizeChanged","isSupported","gl","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","boundingBox","getAttributes","gridOffset","translation","width","height","numCol","numRow","allocateResources","posOffset","slice","gridOrigin","aggregationDataDirty","isAggregationDirty","dimension","compareAll","aggregationWeightsDirty","_updateAccessors","_resetResults","getValue","aggregationData","thresholdData","aggregationBuffer","getData","cellWeights","getCellData","countsData","gridSize","xOffset","yOffset","Array","i","zIndex"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/src/contour-layer/contour-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {LineLayer, SolidPolygonLayer} from '@deck.gl/layers';\nimport {generateContours} from './contour-utils';\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  Layer,\n  log,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\n\nconst defaultProps: DefaultProps<ContourLayerProps> = {\n  // grid aggregation\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  gpuAggregation: true,\n  aggregation: 'SUM',\n\n  // contour lines\n  contours: {\n    type: 'object',\n    value: [{threshold: DEFAULT_THRESHOLD}],\n    optional: true,\n    compare: 3\n  },\n\n  zOffset: 0.005\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\n/** All properties supported by ContourLayer. */\nexport type ContourLayerProps<DataT = any> = _ContourLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by ContourLayer. */\nexport type _ContourLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Definition of contours to be drawn.\n   * @default [{threshold: 1}]\n   */\n  contours: {\n    /**\n     * Isolines: `threshold` value must be a single `Number`, Isolines are generated based on this threshold value.\n     *\n     * Isobands: `threshold` value must be an Array of two `Number`s. Isobands are generated using `[threshold[0], threshold[1])` as threshold range, i.e area that has values `>= threshold[0]` and `< threshold[1]` are rendered with corresponding color. NOTE: `threshold[0]` is inclusive and `threshold[1]` is not inclusive.\n     */\n    threshold: number | number[];\n\n    /**\n     * RGBA color array to be used to render the contour.\n     * @default [255, 255, 255, 255]\n     */\n    color?: Color;\n\n    /**\n     * Applicable for `Isoline`s only, width of the Isoline in pixels.\n     * @default 1\n     */\n    strokeWidth?: number;\n\n    /** Defines z order of the contour. */\n    zIndex?: number;\n  }[];\n\n  /**\n   * A very small z offset that is added for each vertex of a contour (Isoline or Isoband).\n   * @default 0.005\n   */\n  zOffset?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\n/** Aggregate data into iso-lines or iso-bands for a given threshold and cell size. */\nexport default class ContourLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraPropsT & Required<_ContourLayerProps<DataT>>> {\n  static layerName = 'ContourLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>): void {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {oldProps, props} = opts;\n    const {aggregationDirty} = this.state;\n\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n      this._updateThresholdData(opts.props);\n    }\n\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n\n  renderLayers(): Layer[] {\n    const {contourSegments, contourPolygons} = this.state.contourData;\n\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n\n    // Contour lines layer\n    const lineLayer =\n      contourSegments &&\n      contourSegments.length > 0 &&\n      new LinesSubLayerClass(\n        this.getSubLayerProps({\n          id: 'lines'\n        }),\n        {\n          data: this.state.contourData.contourSegments,\n          getSourcePosition: d => d.start,\n          getTargetPosition: d => d.end,\n          getColor: d => d.contour.color || DEFAULT_COLOR,\n          getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n        }\n      );\n\n    // Contour bands layer\n    const bandsLayer =\n      contourPolygons &&\n      contourPolygons.length > 0 &&\n      new BandsSubLayerClass(\n        this.getSubLayerProps({\n          id: 'bands'\n        }),\n        {\n          data: this.state.contourData.contourPolygons,\n          getPolygon: d => d.vertices,\n          getFillColor: d => d.contour.color || DEFAULT_COLOR\n        }\n      );\n\n    return [lineLayer, bandsLayer];\n  }\n\n  // Aggregation Overrides\n\n  /* eslint-disable max-statements, complexity */\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const {dimensions} = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {data, weights} = dimensions;\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(), // Used for CPU aggregation, to offset points\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: data,\n        compareAll: gpuAggregation // check for all (including extentions props) when using gpu aggregation\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n  /* eslint-enable max-statements, complexity */\n\n  // Private (Aggregation)\n\n  private _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  private _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n  // Private (Contours)\n\n  private _generateContours() {\n    const {numCol, numRow, gridOrigin, gridOffset, thresholdData} = this.state;\n    const {count} = this.state.weights;\n    let {aggregationData} = count;\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n\n    const {cellWeights} = GPUGridAggregator.getCellData({countsData: aggregationData});\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n\n    // contourData contains both iso-lines and iso-bands if requested.\n    this.setState({contourData});\n  }\n\n  private _updateThresholdData(props) {\n    const {contours, zOffset} = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n    this.setState({thresholdData});\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}