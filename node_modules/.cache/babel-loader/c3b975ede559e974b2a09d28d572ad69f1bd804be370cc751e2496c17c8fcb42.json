{"ast":null,"code":"import { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nconst REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\nexport default class GPUGridAggregator {\n  static getAggregationData(_ref) {\n    let {\n      aggregationData,\n      maxData,\n      minData,\n      maxMinData,\n      pixelIndex\n    } = _ref;\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n  static getCellData(_ref2) {\n    let {\n      countsData,\n      size = 1\n    } = _ref2;\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {\n      cellCounts,\n      cellWeights\n    };\n  }\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n  delete() {\n    const {\n      gridAggregationModel,\n      allAggregationModel,\n      meanTransform\n    } = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n    gridAggregationModel === null || gridAggregationModel === void 0 ? void 0 : gridAggregationModel.delete();\n    allAggregationModel === null || allAggregationModel === void 0 ? void 0 : allAggregationModel.delete();\n    meanTransform === null || meanTransform === void 0 ? void 0 : meanTransform.delete();\n    deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n  }\n  run() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.setState({\n      results: {}\n    });\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n  updateShaders() {\n    let shaderOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.setState({\n      shaderOptions,\n      modelDirty: true\n    });\n  }\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {\n      ...DEFAULT_RUN_PARAMS,\n      ...opts\n    };\n    const {\n      weights\n    } = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    for (const id in weights) {\n      results[id] = {};\n      const {\n        needMin,\n        needMax,\n        combineMaxMin\n      } = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer,\n        sourceType: 5126\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer,\n          sourceType: 5126\n        });\n        results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer,\n            sourceType: 5126\n          });\n          results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer,\n            sourceType: 5126\n          });\n          results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [1, 1]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax\n      } = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {\n            ...parameters,\n            blendEquation: MAX_MIN_BLEND_EQUATION\n          },\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {\n            clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n          },\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {\n              ...parameters,\n              blendEquation: MIN_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {\n              clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n            },\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {\n              ...parameters,\n              blendEquation: MAX_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, 0]\n            },\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n  _renderToMaxMinTexture(opts) {\n    const {\n      id,\n      parameters,\n      gridSize,\n      minOrMaxFb,\n      combineMaxMin,\n      clearParams = {}\n    } = opts;\n    const {\n      framebuffers\n    } = this.state;\n    const {\n      gl,\n      allAggregationModel\n    } = this;\n    withParameters(gl, {\n      ...clearParams,\n      framebuffer: minOrMaxFb,\n      viewport: [0, 0, gridSize[0], gridSize[1]]\n    }, () => {\n      gl.clear(16384);\n      allAggregationModel.draw({\n        parameters,\n        uniforms: {\n          uSampler: framebuffers[id].texture,\n          gridSize,\n          combineMaxMin\n        }\n      });\n    });\n  }\n  _renderToWeightsTexture(opts) {\n    const {\n      id,\n      parameters,\n      moduleSettings,\n      uniforms,\n      gridSize,\n      weights\n    } = opts;\n    const {\n      framebuffers,\n      equations,\n      weightAttributes\n    } = this.state;\n    const {\n      gl,\n      gridAggregationModel\n    } = this;\n    const {\n      operation\n    } = weights[id];\n    const clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n    withParameters(gl, {\n      framebuffer: framebuffers[id],\n      viewport: [0, 0, gridSize[0], gridSize[1]],\n      clearColor\n    }, () => {\n      gl.clear(16384);\n      const attributes = {\n        weights: weightAttributes[id]\n      };\n      gridAggregationModel.draw({\n        parameters: {\n          ...parameters,\n          blendEquation: equations[id]\n        },\n        moduleSettings,\n        uniforms,\n        attributes\n      });\n    });\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {\n        meanTextures,\n        textures\n      } = this.state;\n      const transformOptions = {\n        _sourceTextures: {\n          aggregationValues: meanTextures[id]\n        },\n        _targetTexture: textures[id],\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n      framebuffers[id].attach({\n        [36064]: textures[id]\n      });\n    }\n  }\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({\n      results\n    });\n    return results;\n  }\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    const {\n      numCol,\n      numRow\n    } = opts;\n    const framebufferSize = {\n      width: numCol,\n      height: numRow\n    };\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax,\n        combineMaxMin,\n        operation\n      } = weights[id];\n      textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n        id: \"\".concat(id, \"-texture\"),\n        width: numCol,\n        height: numRow\n      });\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-mean-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({\n          [36064]: texture\n        });\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: \"\".concat(id, \"-fb\"),\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n              id: \"\".concat(id, \"-maxMinFb\"),\n              texture\n            });\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-minFb\"),\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxFb\"),\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  _getMinMaxTexture(name) {\n    const {\n      resources\n    } = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {\n        id: \"resourceName\"\n      });\n    }\n    return resources[name];\n  }\n  _setupModels() {\n    let {\n      numCol = 0,\n      numRow = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _this$gridAggregation;\n    const {\n      gl\n    } = this;\n    const {\n      shaderOptions\n    } = this.state;\n    (_this$gridAggregation = this.gridAggregationModel) === null || _this$gridAggregation === void 0 ? void 0 : _this$gridAggregation.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n  _setupWeightAttributes(opts) {\n    const {\n      weightAttributes\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n  _trackGPUResultBuffers(results, weights) {\n    const {\n      resources\n    } = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            const name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  _updateModels(opts) {\n    const {\n      vertexCount,\n      attributes,\n      numCol,\n      numRow\n    } = opts;\n    const {\n      modelDirty\n    } = this.state;\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({\n        modelDirty: false\n      });\n    }\n    this._setupWeightAttributes(opts);\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {\n      ...DEFAULT_WEIGHT_PARAMS,\n      ...weights[id]\n    };\n  }\n  return result;\n}\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0,\n    ...shaders\n  });\n}\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}","map":{"version":3,"names":["Model","Transform","FEATURES","hasFeatures","isWebGL2","readPixelsToBuffer","withParameters","fp64arithmetic","log","project32","_mergeShaders","mergeShaders","DEFAULT_RUN_PARAMS","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","DEFAULT_WEIGHT_PARAMS","PIXEL_SIZE","AGGREGATION_OPERATION","AGGREGATE_TO_GRID_VS","AGGREGATE_TO_GRID_FS","AGGREGATE_ALL_VS","AGGREGATE_ALL_FS","TRANSFORM_MEAN_VS","getFloatTexture","getFramebuffer","BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","GPUGridAggregator","getAggregationData","_ref","aggregationData","pixelIndex","index","results","cellCount","cellWeight","maxCellWieght","minCellWeight","totalCount","getCellData","_ref2","countsData","size","numCells","length","cellWeights","Float32Array","cellCounts","Uint32Array","i","sizeIndex","isSupported","gl","constructor","opts","arguments","undefined","id","state","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","_hasGPUSupport","_setupModels","delete","gridAggregationModel","allAggregationModel","meanTransform","deleteResources","run","setState","aggregationParams","_normalizeAggregationParams","_runAggregation","getData","weightId","data","aggregationBuffer","arrayName","bufferName","updateShaders","shaderOptions","modelDirty","weights","normalizeWeightParams","updateObject","Object","assign","_getAggregateData","needMin","needMax","combineMaxMin","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","concat","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","_renderAggregateData","cellSize","projectPoints","attributes","moduleSettings","numCol","numRow","translation","scaling","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","framebuffer","viewport","clear","draw","uSampler","texture","operation","MIN","MEAN","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","width","height","update","getMeanTransform","attach","_updateModels","_setupFramebuffers","framebufferSize","resize","SUM","_getMinMaxTexture","name","_this$gridAggregation","getAggregationModel","instanceCount","getAllAggregationModel","_setupWeightAttributes","vertexCount","setVertexCount","setAttributes","setInstanceCount","result","Array","isArray","forEach","obj","shaders","vs","fs","modules","drawMode","isInstanced","position","_targetTextureVarying"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel?.delete();\n    allAggregationModel?.delete();\n    meanTransform?.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {...DEFAULT_RUN_PARAMS, ...opts};\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {...parameters, blendEquation: MAX_MIN_BLEND_EQUATION},\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MIN_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MAX_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: {...parameters, blendEquation: equations[id]},\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    this.gridAggregationModel?.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {...DEFAULT_WEIGHT_PARAMS, ...weights[id]};\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}