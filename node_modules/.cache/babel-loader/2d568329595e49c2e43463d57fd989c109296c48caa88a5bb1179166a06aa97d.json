{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, fp64LowPart, project32, gouraudLighting, picking } from '@deck.gl/core';\nimport { Model, CubeGeometry } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\nconst COLOR_DATA_UBO_INDEX = 0;\nconst ELEVATION_DATA_UBO_INDEX = 1;\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  gridSize: {\n    type: 'array',\n    value: [1, 1]\n  },\n  gridOrigin: {\n    type: 'array',\n    value: [0, 0]\n  },\n  gridOffset: {\n    type: 'array',\n    value: [0, 0]\n  },\n  cellSize: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 1000\n  },\n  offset: {\n    type: 'array',\n    value: [1, 1]\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  extruded: true,\n  material: true\n};\nexport default class GPUGridCellLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudLighting, picking, fp64arithmetic]\n    });\n  }\n  initializeState(_ref) {\n    let {\n      gl\n    } = _ref;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      colors: {\n        size: 4,\n        noAlloc: true\n      },\n      elevations: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n    const model = this._getModel(gl);\n    this._setupUniformBuffer(model);\n    this.setState({\n      model\n    });\n  }\n  _getModel(gl) {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new CubeGeometry(),\n      isInstanced: true\n    });\n  }\n  draw(_ref2) {\n    let {\n      uniforms\n    } = _ref2;\n    const {\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOffset,\n      elevationRange,\n      colorMaxMinBuffer,\n      elevationMaxMinBuffer\n    } = this.props;\n    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n    const domainUniforms = this.getDomainUniforms();\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n    this.state.model.setUniforms(uniforms).setUniforms(domainUniforms).setUniforms({\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOriginLow,\n      gridOffset,\n      gridOffsetLow,\n      colorRange,\n      elevationRange\n    }).draw();\n    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n  }\n  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.bind({\n      target: 35345,\n      index: COLOR_DATA_UBO_INDEX\n    });\n    elevationMaxMinBuffer.bind({\n      target: 35345,\n      index: ELEVATION_DATA_UBO_INDEX\n    });\n  }\n  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.unbind({\n      target: 35345,\n      index: COLOR_DATA_UBO_INDEX\n    });\n    elevationMaxMinBuffer.unbind({\n      target: 35345,\n      index: ELEVATION_DATA_UBO_INDEX\n    });\n  }\n  getDomainUniforms() {\n    const {\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const domainUniforms = {};\n    if (colorDomain !== null) {\n      domainUniforms.colorDomainValid = true;\n      domainUniforms.colorDomain = colorDomain;\n    } else {\n      domainUniforms.colorDomainValid = false;\n    }\n    if (elevationDomain !== null) {\n      domainUniforms.elevationDomainValid = true;\n      domainUniforms.elevationDomain = elevationDomain;\n    } else {\n      domainUniforms.elevationDomainValid = false;\n    }\n    return domainUniforms;\n  }\n  _setupUniformBuffer(model) {\n    const gl = this.context.gl;\n    const programHandle = model.program.handle;\n    const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n    const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n  }\n}\n_defineProperty(GPUGridCellLayer, \"layerName\", 'GPUGridCellLayer');\n_defineProperty(GPUGridCellLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["Layer","fp64LowPart","project32","gouraudLighting","picking","Model","CubeGeometry","fp64arithmetic","defaultColorRange","colorRangeToFlatArray","vs","fs","COLOR_DATA_UBO_INDEX","ELEVATION_DATA_UBO_INDEX","defaultProps","colorDomain","colorRange","elevationDomain","elevationRange","elevationScale","type","min","value","gridSize","gridOrigin","gridOffset","cellSize","max","offset","coverage","extruded","material","GPUGridCellLayer","getShaders","modules","initializeState","_ref","gl","attributeManager","getAttributeManager","addInstanced","colors","size","noAlloc","elevations","model","_getModel","_setupUniformBuffer","setState","id","props","geometry","isInstanced","draw","_ref2","uniforms","colorMaxMinBuffer","elevationMaxMinBuffer","gridOriginLow","gridOffsetLow","domainUniforms","getDomainUniforms","bindUniformBuffers","state","setUniforms","unbindUniformBuffers","bind","target","index","unbind","colorDomainValid","elevationDomainValid","context","programHandle","program","handle","colorIndex","getUniformBlockIndex","elevationIndex","uniformBlockBinding"],"sources":["../../../src/gpu-grid-layer/gpu-grid-cell-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Layer,\n  fp64LowPart,\n  project32,\n  gouraudLighting,\n  picking,\n  LayerContext,\n  LayerProps,\n  DefaultProps\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, CubeGeometry, Buffer} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport type {_GPUGridLayerProps} from './gpu-grid-layer';\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\n\nconst COLOR_DATA_UBO_INDEX = 0;\nconst ELEVATION_DATA_UBO_INDEX = 1;\n\nconst defaultProps: DefaultProps<_GPUGridCellLayerProps & LayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  gridSize: {type: 'array', value: [1, 1]},\n  gridOrigin: {type: 'array', value: [0, 0]},\n  gridOffset: {type: 'array', value: [0, 0]},\n\n  cellSize: {type: 'number', min: 0, max: 1000, value: 1000},\n  offset: {type: 'array', value: [1, 1]},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: true,\n\n  material: true // Use lighting module defaults\n};\n\ntype _GPUGridCellLayerProps = _GPUGridLayerProps<any> & {\n  offset: number[];\n  gridSize: number[];\n  gridOrigin: number[];\n  gridOffset: number[];\n  colorMaxMinBuffer: Buffer;\n  elevationMaxMinBuffer: Buffer;\n};\n\nexport default class GPUGridCellLayer extends Layer<_GPUGridCellLayerProps> {\n  static layerName = 'GPUGridCellLayer';\n  static defaultProps = defaultProps;\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudLighting, picking, fp64arithmetic]\n    });\n  }\n\n  initializeState({gl}: LayerContext) {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.addInstanced({\n      colors: {\n        size: 4,\n        noAlloc: true\n      },\n      elevations: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n    const model = this._getModel(gl);\n    this._setupUniformBuffer(model);\n    this.setState({model});\n  }\n\n  _getModel(gl: WebGLRenderingContext): Model {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new CubeGeometry(),\n      isInstanced: true\n    });\n  }\n\n  draw({uniforms}) {\n    const {\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOffset,\n      elevationRange,\n      colorMaxMinBuffer,\n      elevationMaxMinBuffer\n    } = this.props;\n\n    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n    const domainUniforms = this.getDomainUniforms();\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms(domainUniforms)\n      .setUniforms({\n        cellSize,\n        offset,\n        extruded,\n        elevationScale,\n        coverage,\n        gridSize,\n        gridOrigin,\n        gridOriginLow,\n        gridOffset,\n        gridOffsetLow,\n        colorRange,\n        elevationRange\n      })\n      .draw();\n    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n  }\n\n  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.bind({target: GL.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});\n    elevationMaxMinBuffer.bind({target: GL.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});\n  }\n\n  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.unbind({target: GL.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});\n    elevationMaxMinBuffer.unbind({target: GL.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});\n  }\n\n  getDomainUniforms() {\n    const {colorDomain, elevationDomain} = this.props;\n    const domainUniforms: Record<string, any> = {};\n    if (colorDomain !== null) {\n      domainUniforms.colorDomainValid = true;\n      domainUniforms.colorDomain = colorDomain;\n    } else {\n      domainUniforms.colorDomainValid = false;\n    }\n    if (elevationDomain !== null) {\n      domainUniforms.elevationDomainValid = true;\n      domainUniforms.elevationDomain = elevationDomain;\n    } else {\n      domainUniforms.elevationDomainValid = false;\n    }\n    return domainUniforms;\n  }\n\n  private _setupUniformBuffer(model: Model): void {\n    const gl = this.context.gl as WebGL2RenderingContext;\n    const programHandle = model.program.handle;\n\n    const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n    const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}