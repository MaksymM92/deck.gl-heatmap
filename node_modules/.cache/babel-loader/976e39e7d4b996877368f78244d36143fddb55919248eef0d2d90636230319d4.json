{"ast":null,"code":"import { log } from '@deck.gl/core';\nimport { ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP } from './marching-squares-codes';\nexport const CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\nconst DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\nfunction getVertexCode(weight, threshold) {\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  return weight >= threshold ? 1 : 0;\n}\nexport function getCode(opts) {\n  const {\n    cellWeights,\n    x,\n    y,\n    width,\n    height\n  } = opts;\n  let threshold = opts.threshold;\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n  const isLeftBoundary = x < 0;\n  const isRightBoundary = x >= width - 1;\n  const isBottomBoundary = y < 0;\n  const isTopBoundary = y >= height - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n  const weights = {};\n  const codes = {};\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n  const {\n    top,\n    topRight,\n    right,\n    current\n  } = codes;\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = top << 3 | topRight << 2 | right << 1 | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = top << 6 | topRight << 4 | right << 2 | current;\n  }\n  let meanCode = 0;\n  if (!isBoundary) {\n    meanCode = getVertexCode((weights.top + weights.topRight + weights.right + weights.current) / 4, threshold);\n  }\n  return {\n    code,\n    meanCode\n  };\n}\nexport function getVertices(opts) {\n  const {\n    gridOrigin,\n    cellSize,\n    x,\n    y,\n    code,\n    meanCode,\n    type = CONTOUR_TYPE.ISO_LINES\n  } = opts;\n  const thresholdData = {\n    ...DEFAULT_THRESHOLD_DATA,\n    ...opts.thresholdData\n  };\n  let offsets = type === CONTOUR_TYPE.ISO_BANDS ? ISOBANDS_CODE_OFFSET_MAP[code] : ISOLINES_CODE_OFFSET_MAP[code];\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n  const vZ = thresholdData.zIndex * thresholdData.zOffset;\n  const rX = (x + 1) * cellSize[0];\n  const rY = (y + 1) * cellSize[1];\n  const refVertexX = gridOrigin[0] + rX;\n  const refVertexY = gridOrigin[1] + rY;\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    const polygons = [];\n    offsets.forEach(polygonOffsets => {\n      const polygon = [];\n      polygonOffsets.forEach(xyOffset => {\n        const vX = refVertexX + xyOffset[0] * cellSize[0];\n        const vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n  const lines = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = refVertexX + offset[0] * cellSize[0];\n      const vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}","map":{"version":3,"names":["log","ISOLINES_CODE_OFFSET_MAP","ISOBANDS_CODE_OFFSET_MAP","CONTOUR_TYPE","ISO_LINES","ISO_BANDS","DEFAULT_THRESHOLD_DATA","zIndex","zOffset","getVertexCode","weight","threshold","Array","isArray","getCode","opts","cellWeights","x","y","width","height","thresholdValue","deprecated","isLeftBoundary","isRightBoundary","isBottomBoundary","isTopBoundary","isBoundary","weights","codes","top","topRight","right","current","code","Number","isFinite","meanCode","getVertices","gridOrigin","cellSize","type","thresholdData","offsets","vZ","rX","rY","refVertexX","refVertexY","polygons","forEach","polygonOffsets","polygon","xyOffset","vX","vY","push","lines","xyOffsets","offset"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/contour-layer/marching-squares.js"],"sourcesContent":["import { log } from '@deck.gl/core';\nimport { ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP } from './marching-squares-codes';\nexport const CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\nconst DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\n\nfunction getVertexCode(weight, threshold) {\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n\n    return weight < threshold[1] ? 1 : 2;\n  }\n\n  return weight >= threshold ? 1 : 0;\n}\n\nexport function getCode(opts) {\n  const {\n    cellWeights,\n    x,\n    y,\n    width,\n    height\n  } = opts;\n  let threshold = opts.threshold;\n\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n\n  const isLeftBoundary = x < 0;\n  const isRightBoundary = x >= width - 1;\n  const isBottomBoundary = y < 0;\n  const isTopBoundary = y >= height - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n  const weights = {};\n  const codes = {};\n\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n\n  const {\n    top,\n    topRight,\n    right,\n    current\n  } = codes;\n  let code = -1;\n\n  if (Number.isFinite(threshold)) {\n    code = top << 3 | topRight << 2 | right << 1 | current;\n  }\n\n  if (Array.isArray(threshold)) {\n    code = top << 6 | topRight << 4 | right << 2 | current;\n  }\n\n  let meanCode = 0;\n\n  if (!isBoundary) {\n    meanCode = getVertexCode((weights.top + weights.topRight + weights.right + weights.current) / 4, threshold);\n  }\n\n  return {\n    code,\n    meanCode\n  };\n}\nexport function getVertices(opts) {\n  const {\n    gridOrigin,\n    cellSize,\n    x,\n    y,\n    code,\n    meanCode,\n    type = CONTOUR_TYPE.ISO_LINES\n  } = opts;\n  const thresholdData = { ...DEFAULT_THRESHOLD_DATA,\n    ...opts.thresholdData\n  };\n  let offsets = type === CONTOUR_TYPE.ISO_BANDS ? ISOBANDS_CODE_OFFSET_MAP[code] : ISOLINES_CODE_OFFSET_MAP[code];\n\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  const vZ = thresholdData.zIndex * thresholdData.zOffset;\n  const rX = (x + 1) * cellSize[0];\n  const rY = (y + 1) * cellSize[1];\n  const refVertexX = gridOrigin[0] + rX;\n  const refVertexY = gridOrigin[1] + rY;\n\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    const polygons = [];\n    offsets.forEach(polygonOffsets => {\n      const polygon = [];\n      polygonOffsets.forEach(xyOffset => {\n        const vX = refVertexX + xyOffset[0] * cellSize[0];\n        const vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n\n  const lines = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = refVertexX + offset[0] * cellSize[0];\n      const vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}\n//# sourceMappingURL=marching-squares.js.map"],"mappings":"AAAA,SAASA,GAAG,QAAQ,eAAe;AACnC,SAASC,wBAAwB,EAAEC,wBAAwB,QAAQ,0BAA0B;AAC7F,OAAO,MAAMC,YAAY,GAAG;EAC1BC,SAAS,EAAE,CAAC;EACZC,SAAS,EAAE;AACb,CAAC;AACD,MAAMC,sBAAsB,GAAG;EAC7BC,MAAM,EAAE,CAAC;EACTC,OAAO,EAAE;AACX,CAAC;AAED,SAASC,aAAaA,CAACC,MAAM,EAAEC,SAAS,EAAE;EACxC,IAAIC,KAAK,CAACC,OAAO,CAACF,SAAS,CAAC,EAAE;IAC5B,IAAID,MAAM,GAAGC,SAAS,CAAC,CAAC,CAAC,EAAE;MACzB,OAAO,CAAC;IACV;IAEA,OAAOD,MAAM,GAAGC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;EACtC;EAEA,OAAOD,MAAM,IAAIC,SAAS,GAAG,CAAC,GAAG,CAAC;AACpC;AAEA,OAAO,SAASG,OAAOA,CAACC,IAAI,EAAE;EAC5B,MAAM;IACJC,WAAW;IACXC,CAAC;IACDC,CAAC;IACDC,KAAK;IACLC;EACF,CAAC,GAAGL,IAAI;EACR,IAAIJ,SAAS,GAAGI,IAAI,CAACJ,SAAS;EAE9B,IAAII,IAAI,CAACM,cAAc,EAAE;IACvBrB,GAAG,CAACsB,UAAU,CAAC,gBAAgB,EAAE,WAAW,CAAC,EAAE;IAC/CX,SAAS,GAAGI,IAAI,CAACM,cAAc;EACjC;EAEA,MAAME,cAAc,GAAGN,CAAC,GAAG,CAAC;EAC5B,MAAMO,eAAe,GAAGP,CAAC,IAAIE,KAAK,GAAG,CAAC;EACtC,MAAMM,gBAAgB,GAAGP,CAAC,GAAG,CAAC;EAC9B,MAAMQ,aAAa,GAAGR,CAAC,IAAIE,MAAM,GAAG,CAAC;EACrC,MAAMO,UAAU,GAAGJ,cAAc,IAAIC,eAAe,IAAIC,gBAAgB,IAAIC,aAAa;EACzF,MAAME,OAAO,GAAG,CAAC,CAAC;EAClB,MAAMC,KAAK,GAAG,CAAC,CAAC;EAEhB,IAAIN,cAAc,IAAIG,aAAa,EAAE;IACnCG,KAAK,CAACC,GAAG,GAAG,CAAC;EACf,CAAC,MAAM;IACLF,OAAO,CAACE,GAAG,GAAGd,WAAW,CAAC,CAACE,CAAC,GAAG,CAAC,IAAIC,KAAK,GAAGF,CAAC,CAAC;IAC9CY,KAAK,CAACC,GAAG,GAAGrB,aAAa,CAACmB,OAAO,CAACE,GAAG,EAAEnB,SAAS,CAAC;EACnD;EAEA,IAAIa,eAAe,IAAIE,aAAa,EAAE;IACpCG,KAAK,CAACE,QAAQ,GAAG,CAAC;EACpB,CAAC,MAAM;IACLH,OAAO,CAACG,QAAQ,GAAGf,WAAW,CAAC,CAACE,CAAC,GAAG,CAAC,IAAIC,KAAK,GAAGF,CAAC,GAAG,CAAC,CAAC;IACvDY,KAAK,CAACE,QAAQ,GAAGtB,aAAa,CAACmB,OAAO,CAACG,QAAQ,EAAEpB,SAAS,CAAC;EAC7D;EAEA,IAAIa,eAAe,IAAIC,gBAAgB,EAAE;IACvCI,KAAK,CAACG,KAAK,GAAG,CAAC;EACjB,CAAC,MAAM;IACLJ,OAAO,CAACI,KAAK,GAAGhB,WAAW,CAACE,CAAC,GAAGC,KAAK,GAAGF,CAAC,GAAG,CAAC,CAAC;IAC9CY,KAAK,CAACG,KAAK,GAAGvB,aAAa,CAACmB,OAAO,CAACI,KAAK,EAAErB,SAAS,CAAC;EACvD;EAEA,IAAIY,cAAc,IAAIE,gBAAgB,EAAE;IACtCI,KAAK,CAACI,OAAO,GAAG,CAAC;EACnB,CAAC,MAAM;IACLL,OAAO,CAACK,OAAO,GAAGjB,WAAW,CAACE,CAAC,GAAGC,KAAK,GAAGF,CAAC,CAAC;IAC5CY,KAAK,CAACI,OAAO,GAAGxB,aAAa,CAACmB,OAAO,CAACK,OAAO,EAAEtB,SAAS,CAAC;EAC3D;EAEA,MAAM;IACJmB,GAAG;IACHC,QAAQ;IACRC,KAAK;IACLC;EACF,CAAC,GAAGJ,KAAK;EACT,IAAIK,IAAI,GAAG,CAAC,CAAC;EAEb,IAAIC,MAAM,CAACC,QAAQ,CAACzB,SAAS,CAAC,EAAE;IAC9BuB,IAAI,GAAGJ,GAAG,IAAI,CAAC,GAAGC,QAAQ,IAAI,CAAC,GAAGC,KAAK,IAAI,CAAC,GAAGC,OAAO;EACxD;EAEA,IAAIrB,KAAK,CAACC,OAAO,CAACF,SAAS,CAAC,EAAE;IAC5BuB,IAAI,GAAGJ,GAAG,IAAI,CAAC,GAAGC,QAAQ,IAAI,CAAC,GAAGC,KAAK,IAAI,CAAC,GAAGC,OAAO;EACxD;EAEA,IAAII,QAAQ,GAAG,CAAC;EAEhB,IAAI,CAACV,UAAU,EAAE;IACfU,QAAQ,GAAG5B,aAAa,CAAC,CAACmB,OAAO,CAACE,GAAG,GAAGF,OAAO,CAACG,QAAQ,GAAGH,OAAO,CAACI,KAAK,GAAGJ,OAAO,CAACK,OAAO,IAAI,CAAC,EAAEtB,SAAS,CAAC;EAC7G;EAEA,OAAO;IACLuB,IAAI;IACJG;EACF,CAAC;AACH;AACA,OAAO,SAASC,WAAWA,CAACvB,IAAI,EAAE;EAChC,MAAM;IACJwB,UAAU;IACVC,QAAQ;IACRvB,CAAC;IACDC,CAAC;IACDgB,IAAI;IACJG,QAAQ;IACRI,IAAI,GAAGtC,YAAY,CAACC;EACtB,CAAC,GAAGW,IAAI;EACR,MAAM2B,aAAa,GAAG;IAAE,GAAGpC,sBAAsB;IAC/C,GAAGS,IAAI,CAAC2B;EACV,CAAC;EACD,IAAIC,OAAO,GAAGF,IAAI,KAAKtC,YAAY,CAACE,SAAS,GAAGH,wBAAwB,CAACgC,IAAI,CAAC,GAAGjC,wBAAwB,CAACiC,IAAI,CAAC;EAE/G,IAAI,CAACtB,KAAK,CAACC,OAAO,CAAC8B,OAAO,CAAC,EAAE;IAC3BA,OAAO,GAAGA,OAAO,CAACN,QAAQ,CAAC;EAC7B;EAEA,MAAMO,EAAE,GAAGF,aAAa,CAACnC,MAAM,GAAGmC,aAAa,CAAClC,OAAO;EACvD,MAAMqC,EAAE,GAAG,CAAC5B,CAAC,GAAG,CAAC,IAAIuB,QAAQ,CAAC,CAAC,CAAC;EAChC,MAAMM,EAAE,GAAG,CAAC5B,CAAC,GAAG,CAAC,IAAIsB,QAAQ,CAAC,CAAC,CAAC;EAChC,MAAMO,UAAU,GAAGR,UAAU,CAAC,CAAC,CAAC,GAAGM,EAAE;EACrC,MAAMG,UAAU,GAAGT,UAAU,CAAC,CAAC,CAAC,GAAGO,EAAE;EAErC,IAAIL,IAAI,KAAKtC,YAAY,CAACE,SAAS,EAAE;IACnC,MAAM4C,QAAQ,GAAG,EAAE;IACnBN,OAAO,CAACO,OAAO,CAACC,cAAc,IAAI;MAChC,MAAMC,OAAO,GAAG,EAAE;MAClBD,cAAc,CAACD,OAAO,CAACG,QAAQ,IAAI;QACjC,MAAMC,EAAE,GAAGP,UAAU,GAAGM,QAAQ,CAAC,CAAC,CAAC,GAAGb,QAAQ,CAAC,CAAC,CAAC;QACjD,MAAMe,EAAE,GAAGP,UAAU,GAAGK,QAAQ,CAAC,CAAC,CAAC,GAAGb,QAAQ,CAAC,CAAC,CAAC;QACjDY,OAAO,CAACI,IAAI,CAAC,CAACF,EAAE,EAAEC,EAAE,EAAEX,EAAE,CAAC,CAAC;MAC5B,CAAC,CAAC;MACFK,QAAQ,CAACO,IAAI,CAACJ,OAAO,CAAC;IACxB,CAAC,CAAC;IACF,OAAOH,QAAQ;EACjB;EAEA,MAAMQ,KAAK,GAAG,EAAE;EAChBd,OAAO,CAACO,OAAO,CAACQ,SAAS,IAAI;IAC3BA,SAAS,CAACR,OAAO,CAACS,MAAM,IAAI;MAC1B,MAAML,EAAE,GAAGP,UAAU,GAAGY,MAAM,CAAC,CAAC,CAAC,GAAGnB,QAAQ,CAAC,CAAC,CAAC;MAC/C,MAAMe,EAAE,GAAGP,UAAU,GAAGW,MAAM,CAAC,CAAC,CAAC,GAAGnB,QAAQ,CAAC,CAAC,CAAC;MAC/CiB,KAAK,CAACD,IAAI,CAAC,CAACF,EAAE,EAAEC,EAAE,EAAEX,EAAE,CAAC,CAAC;IAC1B,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOa,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}