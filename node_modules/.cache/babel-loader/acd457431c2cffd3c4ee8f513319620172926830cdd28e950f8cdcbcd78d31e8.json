{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { clamp } from '@math.gl/core';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport { mod } from '../utils/math-utils';\nimport LinearInterpolator from '../transitions/linear-interpolator';\nexport class OrbitState extends ViewState {\n  constructor(options) {\n    const {\n      width,\n      height,\n      rotationX = 0,\n      rotationOrbit = 0,\n      target = [0, 0, 0],\n      zoom = 0,\n      minRotationX = -90,\n      maxRotationX = 90,\n      minZoom = -Infinity,\n      maxZoom = Infinity,\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    } = options;\n    super({\n      width,\n      height,\n      rotationX,\n      rotationOrbit,\n      target,\n      zoom,\n      minRotationX,\n      maxRotationX,\n      minZoom,\n      maxZoom\n    }, {\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    });\n    _defineProperty(this, \"makeViewport\", void 0);\n    this.makeViewport = options.makeViewport;\n  }\n  panStart(_ref) {\n    let {\n      pos\n    } = _ref;\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n  pan(_ref2) {\n    let {\n      pos,\n      startPosition\n    } = _ref2;\n    const startPanPosition = this.getState().startPanPosition || startPosition;\n    if (!startPanPosition) {\n      return this;\n    }\n    const viewport = this.makeViewport(this.getViewportProps());\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n    return this._getUpdatedState(newProps);\n  }\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n  rotateStart(_ref3) {\n    let {\n      pos\n    } = _ref3;\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this.getViewportProps().rotationX,\n      startRotationOrbit: this.getViewportProps().rotationOrbit\n    });\n  }\n  rotate(_ref4) {\n    let {\n      pos,\n      deltaAngleX = 0,\n      deltaAngleY = 0\n    } = _ref4;\n    const {\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit\n    } = this.getState();\n    const {\n      width,\n      height\n    } = this.getViewportProps();\n    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {\n      return this;\n    }\n    let newRotation;\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n      if (startRotationX < -90 || startRotationX > 90) {\n        deltaScaleX *= -1;\n      }\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n    return this._getUpdatedState(newRotation);\n  }\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = {\n      ...this.getViewportProps()\n    };\n    const {\n      rotationOrbit\n    } = props;\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n    return props;\n  }\n  zoomStart(_ref5) {\n    let {\n      pos\n    } = _ref5;\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this.getViewportProps().zoom\n    });\n  }\n  zoom(_ref6) {\n    let {\n      pos,\n      startPos,\n      scale\n    } = _ref6;\n    let {\n      startZoom,\n      startZoomPosition\n    } = this.getState();\n    if (!startZoomPosition) {\n      startZoom = this.getViewportProps().zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n    if (!startZoomPosition) {\n      return this;\n    }\n    const newZoom = this._calculateNewZoom({\n      scale,\n      startZoom\n    });\n    const zoomedViewport = this.makeViewport({\n      ...this.getViewportProps(),\n      zoom: newZoom\n    });\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n  zoomIn() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: speed\n      })\n    });\n  }\n  zoomOut() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: 1 / speed\n      })\n    });\n  }\n  moveLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([-speed, 0]);\n  }\n  moveRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([speed, 0]);\n  }\n  moveUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([0, -speed]);\n  }\n  moveDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([0, speed]);\n  }\n  rotateLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit - speed\n    });\n  }\n  rotateRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit + speed\n    });\n  }\n  rotateUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX - speed\n    });\n  }\n  rotateDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX + speed\n    });\n  }\n  _unproject(pos) {\n    const viewport = this.makeViewport(this.getViewportProps());\n    return pos && viewport.unproject(pos);\n  }\n  _calculateNewZoom(_ref7) {\n    let {\n      scale,\n      startZoom\n    } = _ref7;\n    const {\n      maxZoom,\n      minZoom\n    } = this.getViewportProps();\n    if (startZoom === undefined) {\n      startZoom = this.getViewportProps().zoom;\n    }\n    const zoom = startZoom + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n  _panFromCenter(offset) {\n    const {\n      width,\n      height,\n      target\n    } = this.getViewportProps();\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n  _getUpdatedState(newProps) {\n    return new this.constructor({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n  applyConstraints(props) {\n    const {\n      maxZoom,\n      minZoom,\n      zoom,\n      maxRotationX,\n      minRotationX,\n      rotationOrbit\n    } = props;\n    props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n    return props;\n  }\n}\nexport default class OrbitController extends Controller {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"ControllerState\", OrbitState);\n    _defineProperty(this, \"transition\", {\n      transitionDuration: 300,\n      transitionInterpolator: new LinearInterpolator({\n        transitionProps: {\n          compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],\n          required: ['target', 'zoom']\n        }\n      })\n    });\n  }\n}","map":{"version":3,"names":["clamp","Controller","ViewState","mod","LinearInterpolator","OrbitState","constructor","options","width","height","rotationX","rotationOrbit","target","zoom","minRotationX","maxRotationX","minZoom","Infinity","maxZoom","startPanPosition","startRotatePos","startRotationX","startRotationOrbit","startZoomPosition","startZoom","_defineProperty","makeViewport","panStart","_ref","pos","_getUpdatedState","_unproject","pan","_ref2","startPosition","getState","viewport","getViewportProps","newProps","panByPosition","panEnd","rotateStart","_ref3","rotate","_ref4","deltaAngleX","deltaAngleY","undefined","newRotation","deltaScaleX","deltaScaleY","rotateEnd","shortestPathFrom","viewState","fromProps","props","Math","abs","zoomStart","_ref5","_ref6","startPos","scale","newZoom","_calculateNewZoom","zoomedViewport","zoomEnd","zoomIn","speed","arguments","length","zoomOut","moveLeft","_panFromCenter","moveRight","moveUp","moveDown","rotateLeft","rotateRight","rotateUp","rotateDown","unproject","_ref7","log2","offset","applyConstraints","Array","isArray","OrbitController","transitionDuration","transitionInterpolator","transitionProps","compare","required"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/controllers/orbit-controller.ts"],"sourcesContent":["import {clamp} from '@math.gl/core';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport {mod} from '../utils/math-utils';\n\nimport type Viewport from '../viewports/viewport';\nimport LinearInterpolator from '../transitions/linear-interpolator';\n\nexport type OrbitStateProps = {\n  width: number;\n  height: number;\n  target?: number[];\n  zoom?: number | number[];\n  rotationX?: number;\n  rotationOrbit?: number;\n\n  /** Viewport constraints */\n  maxZoom?: number;\n  minZoom?: number;\n  minRotationX?: number;\n  maxRotationX?: number;\n};\n\ntype OrbitStateInternal = {\n  startPanPosition?: number[];\n  startRotatePos?: number[];\n  startRotationX?: number;\n  startRotationOrbit?: number;\n  startZoomPosition?: number[];\n  startZoom?: number | number[];\n};\n\nexport class OrbitState extends ViewState<OrbitState, OrbitStateProps, OrbitStateInternal> {\n  makeViewport: (props: Record<string, any>) => Viewport;\n\n  constructor(\n    options: OrbitStateProps &\n      OrbitStateInternal & {\n        makeViewport: (props: Record<string, any>) => Viewport;\n      }\n  ) {\n    const {\n      /* Viewport arguments */\n      width, // Width of viewport\n      height, // Height of viewport\n      rotationX = 0, // Rotation around x axis\n      rotationOrbit = 0, // Rotation around orbit axis\n      target = [0, 0, 0],\n      zoom = 0,\n\n      /* Viewport constraints */\n      minRotationX = -90,\n      maxRotationX = 90,\n      minZoom = -Infinity,\n      maxZoom = Infinity,\n\n      /** Interaction states, required to calculate change during transform */\n      // Model state when the pan operation first started\n      startPanPosition,\n      // Model state when the rotate operation first started\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      // Model state when the zoom operation first started\n      startZoomPosition,\n      startZoom\n    } = options;\n\n    super(\n      {\n        width,\n        height,\n        rotationX,\n        rotationOrbit,\n        target,\n        zoom,\n        minRotationX,\n        maxRotationX,\n        minZoom,\n        maxZoom\n      },\n      {\n        startPanPosition,\n        startRotatePos,\n        startRotationX,\n        startRotationOrbit,\n        startZoomPosition,\n        startZoom\n      }\n    );\n\n    this.makeViewport = options.makeViewport;\n  }\n\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan({pos, startPosition}: {pos: [number, number]; startPosition?: number[]}): OrbitState {\n    const startPanPosition = this.getState().startPanPosition || startPosition;\n\n    if (!startPanPosition) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this.getViewportProps());\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n\n    return this._getUpdatedState(newProps);\n  }\n\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd(): OrbitState {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this.getViewportProps().rotationX,\n      startRotationOrbit: this.getViewportProps().rotationOrbit\n    });\n  }\n\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate({\n    pos,\n    deltaAngleX = 0,\n    deltaAngleY = 0\n  }: {\n    pos?: [number, number];\n    deltaAngleX?: number;\n    deltaAngleY?: number;\n  }): OrbitState {\n    const {startRotatePos, startRotationX, startRotationOrbit} = this.getState();\n    const {width, height} = this.getViewportProps();\n\n    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {\n      return this;\n    }\n\n    let newRotation;\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n\n      if (startRotationX < -90 || startRotationX > 90) {\n        // When looking at the \"back\" side of the scene, invert horizontal drag\n        // so that the camera movement follows user input\n        deltaScaleX *= -1;\n      }\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd(): OrbitState {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n\n  // shortest path between two view states\n  shortestPathFrom(viewState: OrbitState): OrbitStateProps {\n    const fromProps = viewState.getViewportProps();\n    const props = {...this.getViewportProps()};\n    const {rotationOrbit} = props;\n\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n\n    return props;\n  }\n\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this.getViewportProps().zoom\n    });\n  }\n\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current target is\n   * @param {[Number, Number]} startPos - the target position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom({\n    pos,\n    startPos,\n    scale\n  }: {\n    pos: [number, number];\n    startPos?: [number, number];\n    scale: number;\n  }): OrbitState {\n    let {startZoom, startZoomPosition} = this.getState();\n    if (!startZoomPosition) {\n      // We have two modes of zoom:\n      // scroll zoom that are discrete events (transform from the current zoom level),\n      // and pinch zoom that are continuous events (transform from the zoom level when\n      // pinch started).\n      // If startZoom state is defined, then use the startZoom state;\n      // otherwise assume discrete zooming\n      startZoom = this.getViewportProps().zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n    if (!startZoomPosition) {\n      return this;\n    }\n    const newZoom = this._calculateNewZoom({scale, startZoom});\n    const zoomedViewport = this.makeViewport({...this.getViewportProps(), zoom: newZoom});\n\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd(): OrbitState {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn(speed: number = 2): OrbitState {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: speed})\n    });\n  }\n\n  zoomOut(speed: number = 2): OrbitState {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: 1 / speed})\n    });\n  }\n\n  moveLeft(speed: number = 50): OrbitState {\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveRight(speed: number = 50): OrbitState {\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveUp(speed: number = 50): OrbitState {\n    return this._panFromCenter([0, -speed]);\n  }\n\n  moveDown(speed: number = 50): OrbitState {\n    return this._panFromCenter([0, speed]);\n  }\n\n  rotateLeft(speed: number = 15): OrbitState {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit - speed\n    });\n  }\n\n  rotateRight(speed: number = 15): OrbitState {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit + speed\n    });\n  }\n\n  rotateUp(speed: number = 10): OrbitState {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX - speed\n    });\n  }\n\n  rotateDown(speed: number = 10): OrbitState {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX + speed\n    });\n  }\n\n  /* Private methods */\n\n  _unproject(pos?: number[]): number[] | undefined {\n    const viewport = this.makeViewport(this.getViewportProps());\n    // @ts-ignore\n    return pos && viewport.unproject(pos);\n  }\n\n  // Calculates new zoom\n  _calculateNewZoom({\n    scale,\n    startZoom\n  }: {\n    scale: number;\n    startZoom?: number | number[];\n  }): number | number[] {\n    const {maxZoom, minZoom} = this.getViewportProps();\n    if (startZoom === undefined) {\n      startZoom = this.getViewportProps().zoom;\n    }\n    const zoom = (startZoom as number) + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n\n  _panFromCenter(offset) {\n    const {width, height, target} = this.getViewportProps();\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps): OrbitState {\n    // @ts-ignore\n    return new this.constructor({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  applyConstraints(props: Required<OrbitStateProps>): Required<OrbitStateProps> {\n    // Ensure zoom is within specified range\n    const {maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit} = props;\n\n    props.zoom = Array.isArray(zoom)\n      ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)]\n      : clamp(zoom, minZoom, maxZoom);\n\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n\n    return props;\n  }\n}\n\nexport default class OrbitController extends Controller<OrbitState> {\n  ControllerState = OrbitState;\n\n  transition = {\n    transitionDuration: 300,\n    transitionInterpolator: new LinearInterpolator({\n      transitionProps: {\n        compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],\n        required: ['target', 'zoom']\n      }\n    })\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}