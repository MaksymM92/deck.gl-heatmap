{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { deepEqual } from '../utils/deep-equal';\nimport LightingEffect from '../effects/lighting/lighting-effect';\nconst DEFAULT_LIGHTING_EFFECT = new LightingEffect();\nfunction compareEffects(e1, e2) {\n  var _e1$order, _e2$order;\n  const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;\n  const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;\n  return o1 - o2;\n}\nexport default class EffectManager {\n  constructor() {\n    _defineProperty(this, \"effects\", void 0);\n    _defineProperty(this, \"_resolvedEffects\", []);\n    _defineProperty(this, \"_defaultEffects\", []);\n    _defineProperty(this, \"_needsRedraw\", void 0);\n    this.effects = [];\n    this._needsRedraw = 'Initial render';\n    this._setEffects([]);\n  }\n  addDefaultEffect(effect) {\n    const defaultEffects = this._defaultEffects;\n    if (!defaultEffects.find(e => e.id === effect.id)) {\n      const index = defaultEffects.findIndex(e => compareEffects(e, effect) > 0);\n      if (index < 0) {\n        defaultEffects.push(effect);\n      } else {\n        defaultEffects.splice(index, 0, effect);\n      }\n      this._setEffects(this.effects);\n    }\n  }\n  setProps(props) {\n    if ('effects' in props) {\n      if (!deepEqual(props.effects, this.effects, 1)) {\n        this._setEffects(props.effects);\n      }\n    }\n  }\n  needsRedraw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clearRedrawFlags: false\n    };\n    const redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    return redraw;\n  }\n  getEffects() {\n    return this._resolvedEffects;\n  }\n  _setEffects(effects) {\n    const oldEffectsMap = {};\n    for (const effect of this.effects) {\n      oldEffectsMap[effect.id] = effect;\n    }\n    const nextEffects = [];\n    for (const effect of effects) {\n      const oldEffect = oldEffectsMap[effect.id];\n      if (oldEffect && oldEffect !== effect) {\n        if (oldEffect.setProps) {\n          oldEffect.setProps(effect.props);\n          nextEffects.push(oldEffect);\n        } else {\n          oldEffect.cleanup();\n          nextEffects.push(effect);\n        }\n      } else {\n        nextEffects.push(effect);\n      }\n      delete oldEffectsMap[effect.id];\n    }\n    for (const removedEffectId in oldEffectsMap) {\n      oldEffectsMap[removedEffectId].cleanup();\n    }\n    this.effects = nextEffects;\n    this._resolvedEffects = nextEffects.concat(this._defaultEffects);\n    if (!effects.some(effect => effect instanceof LightingEffect)) {\n      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);\n    }\n    this._needsRedraw = 'effects changed';\n  }\n  finalize() {\n    for (const effect of this._resolvedEffects) {\n      effect.cleanup();\n    }\n    this.effects.length = 0;\n    this._resolvedEffects.length = 0;\n    this._defaultEffects.length = 0;\n  }\n}","map":{"version":3,"names":["deepEqual","LightingEffect","DEFAULT_LIGHTING_EFFECT","compareEffects","e1","e2","_e1$order","_e2$order","o1","order","Infinity","o2","EffectManager","constructor","_defineProperty","effects","_needsRedraw","_setEffects","addDefaultEffect","effect","defaultEffects","_defaultEffects","find","e","id","index","findIndex","push","splice","setProps","props","needsRedraw","opts","arguments","length","undefined","clearRedrawFlags","redraw","getEffects","_resolvedEffects","oldEffectsMap","nextEffects","oldEffect","cleanup","removedEffectId","concat","some","finalize"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/lib/effect-manager.ts"],"sourcesContent":["import {deepEqual} from '../utils/deep-equal';\nimport LightingEffect from '../effects/lighting/lighting-effect';\nimport type {Effect} from './effect';\n\nconst DEFAULT_LIGHTING_EFFECT = new LightingEffect();\n\n/** Sort two effects. Returns 0 if equal, negative if e1 < e2, positive if e1 > e2 */\nfunction compareEffects(e1: Effect, e2: Effect): number {\n  const o1 = e1.order ?? Infinity;\n  const o2 = e2.order ?? Infinity;\n  return o1 - o2;\n}\n\nexport default class EffectManager {\n  effects: Effect[];\n  private _resolvedEffects: Effect[] = [];\n  /** Effect instances and order preference pairs, sorted by order */\n  private _defaultEffects: Effect[] = [];\n  private _needsRedraw: false | string;\n\n  constructor() {\n    this.effects = [];\n    this._needsRedraw = 'Initial render';\n    this._setEffects([]);\n  }\n\n  /**\n   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects\n   */\n  addDefaultEffect(effect: Effect) {\n    const defaultEffects = this._defaultEffects;\n    if (!defaultEffects.find(e => e.id === effect.id)) {\n      const index = defaultEffects.findIndex(e => compareEffects(e, effect) > 0);\n      if (index < 0) {\n        defaultEffects.push(effect);\n      } else {\n        defaultEffects.splice(index, 0, effect);\n      }\n      this._setEffects(this.effects);\n    }\n  }\n\n  setProps(props) {\n    if ('effects' in props) {\n      // Compare effects against each other shallowly\n      if (!deepEqual(props.effects, this.effects, 1)) {\n        this._setEffects(props.effects);\n      }\n    }\n  }\n\n  needsRedraw(opts = {clearRedrawFlags: false}): false | string {\n    const redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    return redraw;\n  }\n\n  getEffects() {\n    return this._resolvedEffects;\n  }\n\n  private _setEffects(effects: Effect[]) {\n    const oldEffectsMap: Record<string, Effect> = {};\n    for (const effect of this.effects) {\n      oldEffectsMap[effect.id] = effect;\n    }\n\n    const nextEffects: Effect[] = [];\n    for (const effect of effects) {\n      const oldEffect = oldEffectsMap[effect.id];\n      if (oldEffect && oldEffect !== effect) {\n        if (oldEffect.setProps) {\n          oldEffect.setProps(effect.props);\n          nextEffects.push(oldEffect);\n        } else {\n          oldEffect.cleanup();\n          nextEffects.push(effect);\n        }\n      } else {\n        nextEffects.push(effect);\n      }\n      delete oldEffectsMap[effect.id];\n    }\n    for (const removedEffectId in oldEffectsMap) {\n      oldEffectsMap[removedEffectId].cleanup();\n    }\n    this.effects = nextEffects;\n\n    this._resolvedEffects = nextEffects.concat(this._defaultEffects);\n    // Special case for lighting: only add default instance if no LightingEffect is specified\n    if (!effects.some(effect => effect instanceof LightingEffect)) {\n      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);\n    }\n    this._needsRedraw = 'effects changed';\n  }\n\n  finalize() {\n    for (const effect of this._resolvedEffects) {\n      effect.cleanup();\n    }\n\n    this.effects.length = 0;\n    this._resolvedEffects.length = 0;\n    this._defaultEffects.length = 0;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}