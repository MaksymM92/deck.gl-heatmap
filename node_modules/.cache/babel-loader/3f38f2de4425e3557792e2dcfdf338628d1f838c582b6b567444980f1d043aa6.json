{"ast":null,"code":"import { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nconst DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n};\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n  constructor() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = event => {\n      const {\n        srcEvent\n      } = event;\n      const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        this.manager.emit(alias, event);\n      }\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n    this._onOtherEvent = event => {\n      // console.log('onotherevent', event.type, event)\n      this.manager.emit(event.type, event);\n    };\n    this.options = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n    this.events = new Map();\n    this.setElement(element);\n    // Register all passed events.\n    const {\n      events\n    } = this.options;\n    if (events) {\n      this.on(events);\n    }\n  }\n  getElement() {\n    return this.element;\n  }\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n    this.element = element;\n    if (!element) {\n      return;\n    }\n    const {\n      options\n    } = this;\n    const ManagerClass = options.Manager;\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    }\n    // Set recognizer options\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName];\n        // `enable` is managed by the event registrations\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    }\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    // Register all existing events\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  }\n  // Tear down internal event management implementations.\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n  /** Register an event handler function to be called on `event` */\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {\n      manager\n    } = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    // @ts-ignore\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({\n        enable: enabled\n      });\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n      return;\n    }\n    const {\n      manager,\n      events\n    } = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    let eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar);\n      // Enable recognizer for this event.\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n      // Listen to the event\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n      return;\n    }\n    const {\n      events\n    } = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    const eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      return;\n    }\n    eventRegistrar.remove(event, handler);\n    if (eventRegistrar.isEmpty()) {\n      const {\n        recognizerName\n      } = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n}","map":{"version":3,"names":["Manager","WheelInput","MoveInput","KeyInput","ContextmenuInput","EventRegistrar","BASIC_EVENT_ALIASES","EVENT_RECOGNIZER_MAP","GESTURE_EVENT_ALIASES","RECOGNIZERS","RECOGNIZER_COMPATIBLE_MAP","RECOGNIZER_FALLBACK_MAP","DEFAULT_OPTIONS","events","recognizers","recognizerOptions","touchAction","tabIndex","EventManager","constructor","element","arguments","length","undefined","options","_onBasicInput","event","srcEvent","alias","type","manager","emit","_onOtherEvent","Map","setElement","on","getElement","destroy","ManagerClass","Object","keys","forEach","name","recognizer","get","otherName","recognizeWith","recognizerName","recognizerOption","enable","set","wheelInput","moveInput","keyInput","contextmenuInput","eventAlias","eventRegistrar","isEmpty","_toggleRecognizer","handleEvent","handler","opts","_addEventHandler","once","watch","off","_removeEventHandler","enabled","fallbackRecognizers","otherRecognizer","requireFailure","dropRequireFailure","enableEventType","passive","eventName","add","remove","isRecognizerUsed","eh","values"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/mjolnir.js/src/event-manager.ts"],"sourcesContent":["import {Manager} from './utils/hammer';\nimport type {\n  HammerManager,\n  HammerManagerConstructor,\n  MjolnirEventRaw,\n  MjolnirEvent,\n  RecognizerOptions,\n  RecognizerTuple,\n  MjolnirEventHandlers\n} from './types';\n\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\n\nimport EventRegistrar, {HandlerOptions} from './utils/event-registrar';\n\nimport {\n  BASIC_EVENT_ALIASES,\n  EVENT_RECOGNIZER_MAP,\n  GESTURE_EVENT_ALIASES,\n  RECOGNIZERS,\n  RECOGNIZER_COMPATIBLE_MAP,\n  RECOGNIZER_FALLBACK_MAP\n} from './constants';\n\nexport type EventManagerOptions = {\n  events?: MjolnirEventHandlers;\n  recognizers?: RecognizerTuple[];\n  recognizerOptions?: {[type: string]: RecognizerOptions};\n  Manager?: HammerManagerConstructor;\n  touchAction?: string;\n  tabIndex?: number;\n};\n\nconst DEFAULT_OPTIONS: EventManagerOptions = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n};\n\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n  private manager: HammerManager;\n  private element: HTMLElement;\n  private options: EventManagerOptions;\n  private events: Map<string, EventRegistrar>;\n\n  // Custom handlers\n  private wheelInput: WheelInput;\n  private moveInput: MoveInput;\n  private contextmenuInput: ContextmenuInput;\n  private keyInput: KeyInput;\n\n  constructor(element: HTMLElement = null, options: EventManagerOptions) {\n    this.options = {...DEFAULT_OPTIONS, ...options};\n    this.events = new Map();\n\n    this.setElement(element);\n\n    // Register all passed events.\n    const {events} = this.options;\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  getElement(): HTMLElement {\n    return this.element;\n  }\n\n  setElement(element: HTMLElement): void {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n    this.element = element;\n    if (!element) {\n      return;\n    }\n\n    const {options} = this;\n    const ManagerClass = options.Manager;\n\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    }\n\n    // Set recognizer options\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName];\n        // `enable` is managed by the event registrations\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    }\n\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n\n    // Register all existing events\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  }\n\n  // Tear down internal event management implementations.\n  destroy(): void {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n\n  /** Register multiple event handlers */\n  on(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  on<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (event: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  /** Register an event handler function to be called on `event` */\n  on(event, handler, opts?: any) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  /** Register an event handler function to be called on `event`, then remove it */\n  once(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  once<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (event: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  once(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  /** Register an event handler function to be called on `event`\n   * This handler does not ask the event to be recognized at all times.\n   * Instead, it only \"intercepts\" the event if some other handler is getting it.\n   */\n  watch(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  watch<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (event: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  watch(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  /**\n   * Deregister a previously-registered event handler.\n   */\n  off(events: MjolnirEventHandlers): void;\n  off<EventT extends MjolnirEvent>(event: EventT['type'], handler: (event: EventT) => void): void;\n\n  off(event: any, handler?: any) {\n    this._removeEventHandler(event, handler);\n  }\n\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  private _toggleRecognizer(name: string, enabled: boolean): void {\n    const {manager} = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    // @ts-ignore\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({enable: enabled});\n\n      const fallbackRecognizers: string[] = RECOGNIZER_FALLBACK_MAP[name];\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  private _addEventHandler(\n    event: string | MjolnirEventHandlers,\n    handler: (event: MjolnirEvent) => void,\n    opts?: HandlerOptions,\n    once?: boolean,\n    passive?: boolean\n  ) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n      return;\n    }\n\n    const {manager, events} = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias: string = GESTURE_EVENT_ALIASES[event] || event;\n\n    let eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar);\n      // Enable recognizer for this event.\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n      // Listen to the event\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  private _removeEventHandler(\n    event: string | MjolnirEventHandlers,\n    handler?: (event: MjolnirEvent) => void\n  ) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n      return;\n    }\n\n    const {events} = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n\n    const eventRegistrar = events.get(eventAlias);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler);\n\n    if (eventRegistrar.isEmpty()) {\n      const {recognizerName} = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n  /**\n   * Handle basic events using the 'hammer.input' Hammer.js API:\n   * Before running Recognizers, Hammer emits a 'hammer.input' event\n   * with the basic event info. This function emits all basic events\n   * aliased to the \"class\" of event received.\n   * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n   */\n  private _onBasicInput = (event: MjolnirEventRaw) => {\n    const {srcEvent} = event;\n    const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n    if (alias) {\n      // fire all events aliased to srcEvent.type\n      this.manager.emit(alias, event);\n    }\n  };\n\n  /**\n   * Handle events not supported by Hammer.js,\n   * and pipe back out through same (Hammer) channel used by other events.\n   */\n  private _onOtherEvent = (event: MjolnirEventRaw) => {\n    // console.log('onotherevent', event.type, event)\n    this.manager.emit(event.type, event);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}