{"ast":null,"code":"import Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nconst {\n  MOUSE_EVENTS\n} = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport default class MoveInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    this.handleEvent = event => {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleEnterEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    };\n    this.pressed = false;\n    const {\n      enable\n    } = this.options;\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n    this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === MOVE_EVENT_TYPE) {\n      this.enableMoveEvent = enabled;\n    }\n    if (eventType === OVER_EVENT_TYPE) {\n      this.enableOverEvent = enabled;\n    }\n    if (eventType === OUT_EVENT_TYPE) {\n      this.enableOutEvent = enabled;\n    }\n    if (eventType === ENTER_EVENT_TYPE) {\n      this.enableEnterEvent = enabled;\n    }\n    if (eventType === LEAVE_EVENT_TYPE) {\n      this.enableLeaveEvent = enabled;\n    }\n  }\n  handleOverEvent(event) {\n    if (this.enableOverEvent) {\n      if (event.type === 'mouseover') {\n        this._emit(OVER_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleOutEvent(event) {\n    if (this.enableOutEvent) {\n      if (event.type === 'mouseout') {\n        this._emit(OUT_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleEnterEvent(event) {\n    if (this.enableEnterEvent) {\n      if (event.type === 'mouseenter') {\n        this._emit(ENTER_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent) {\n      if (event.type === 'mouseleave') {\n        this._emit(LEAVE_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `which` to track the button being pressed\n          if (event.which === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit(MOVE_EVENT_TYPE, event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n  _emit(type, event) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n}","map":{"version":3,"names":["Input","INPUT_EVENT_TYPES","MOUSE_EVENTS","MOVE_EVENT_TYPE","OVER_EVENT_TYPE","OUT_EVENT_TYPE","ENTER_EVENT_TYPE","LEAVE_EVENT_TYPE","MoveInput","constructor","element","callback","options","handleEvent","event","handleOverEvent","handleOutEvent","handleEnterEvent","handleLeaveEvent","handleMoveEvent","pressed","enable","enableMoveEvent","enableLeaveEvent","enableEnterEvent","enableOutEvent","enableOverEvent","events","concat","forEach","addEventListener","destroy","removeEventListener","enableEventType","eventType","enabled","type","_emit","button","which","center","x","clientX","y","clientY","srcEvent","pointerType","target"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/mjolnir.js/src/inputs/move-input.ts"],"sourcesContent":["import type {MjolnirPointerEventRaw} from '../types';\nimport Input, {InputOptions} from './input';\nimport {INPUT_EVENT_TYPES} from '../constants';\n\nconst {MOUSE_EVENTS} = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport default class MoveInput extends Input<MjolnirPointerEventRaw, InputOptions> {\n  pressed: boolean;\n  enableMoveEvent: boolean;\n  enableEnterEvent: boolean;\n  enableLeaveEvent: boolean;\n  enableOutEvent: boolean;\n  enableOverEvent: boolean;\n\n  events: string[];\n\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirPointerEventRaw) => void,\n    options: InputOptions\n  ) {\n    super(element, callback, options);\n\n    this.pressed = false;\n    const {enable} = this.options;\n\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n\n    this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    if (eventType === MOVE_EVENT_TYPE) {\n      this.enableMoveEvent = enabled;\n    }\n    if (eventType === OVER_EVENT_TYPE) {\n      this.enableOverEvent = enabled;\n    }\n    if (eventType === OUT_EVENT_TYPE) {\n      this.enableOutEvent = enabled;\n    }\n    if (eventType === ENTER_EVENT_TYPE) {\n      this.enableEnterEvent = enabled;\n    }\n    if (eventType === LEAVE_EVENT_TYPE) {\n      this.enableLeaveEvent = enabled;\n    }\n  }\n\n  handleEvent = (event: PointerEvent) => {\n    this.handleOverEvent(event);\n    this.handleOutEvent(event);\n    this.handleEnterEvent(event);\n    this.handleLeaveEvent(event);\n    this.handleMoveEvent(event);\n  };\n\n  handleOverEvent(event: PointerEvent) {\n    if (this.enableOverEvent) {\n      if (event.type === 'mouseover') {\n        this._emit(OVER_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleOutEvent(event: PointerEvent) {\n    if (this.enableOutEvent) {\n      if (event.type === 'mouseout') {\n        this._emit(OUT_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleEnterEvent(event: PointerEvent) {\n    if (this.enableEnterEvent) {\n      if (event.type === 'mouseenter') {\n        this._emit(ENTER_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleLeaveEvent(event: PointerEvent) {\n    if (this.enableLeaveEvent) {\n      if (event.type === 'mouseleave') {\n        this._emit(LEAVE_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleMoveEvent(event: PointerEvent) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `which` to track the button being pressed\n          if (event.which === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit(MOVE_EVENT_TYPE, event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n\n  _emit(\n    type: 'pointermove' | 'pointerover' | 'pointerout' | 'pointerenter' | 'pointerleave',\n    event: PointerEvent\n  ) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target as HTMLElement\n    });\n  }\n}\n"],"mappings":"AACA,OAAOA,KAAqB,MAAM,SAAS;AAC3C,SAAQC,iBAAiB,QAAO,cAAc;AAE9C,MAAM;EAACC;AAAY,CAAC,GAAGD,iBAAiB;AACxC,MAAME,eAAe,GAAG,aAAa;AACrC,MAAMC,eAAe,GAAG,aAAa;AACrC,MAAMC,cAAc,GAAG,YAAY;AACnC,MAAMC,gBAAgB,GAAG,cAAc;AACvC,MAAMC,gBAAgB,GAAG,cAAc;AAEvC;;;;;;;;AAQA,eAAc,MAAOC,SAAU,SAAQR,KAA2C;EAUhFS,YACEC,OAAoB,EACpBC,QAAiD,EACjDC,OAAqB;IAErB,KAAK,CAACF,OAAO,EAAEC,QAAQ,EAAEC,OAAO,CAAC;IA0CnC,KAAAC,WAAW,GAAIC,KAAmB,IAAI;MACpC,IAAI,CAACC,eAAe,CAACD,KAAK,CAAC;MAC3B,IAAI,CAACE,cAAc,CAACF,KAAK,CAAC;MAC1B,IAAI,CAACG,gBAAgB,CAACH,KAAK,CAAC;MAC5B,IAAI,CAACI,gBAAgB,CAACJ,KAAK,CAAC;MAC5B,IAAI,CAACK,eAAe,CAACL,KAAK,CAAC;IAC7B,CAAC;IA9CC,IAAI,CAACM,OAAO,GAAG,KAAK;IACpB,MAAM;MAACC;IAAM,CAAC,GAAG,IAAI,CAACT,OAAO;IAE7B,IAAI,CAACU,eAAe,GAAGD,MAAM;IAC7B,IAAI,CAACE,gBAAgB,GAAGF,MAAM;IAC9B,IAAI,CAACG,gBAAgB,GAAGH,MAAM;IAC9B,IAAI,CAACI,cAAc,GAAGJ,MAAM;IAC5B,IAAI,CAACK,eAAe,GAAGL,MAAM;IAE7B,IAAI,CAACM,MAAM,GAAG,CAAC,IAAI,CAACf,OAAO,CAACe,MAAM,IAAI,EAAE,EAAEC,MAAM,CAAC1B,YAAY,CAAC;IAE9D,IAAI,CAACyB,MAAM,CAACE,OAAO,CAACf,KAAK,IAAIJ,OAAO,CAACoB,gBAAgB,CAAChB,KAAK,EAAE,IAAI,CAACD,WAAW,CAAC,CAAC;EACjF;EAEAkB,OAAOA,CAAA;IACL,IAAI,CAACJ,MAAM,CAACE,OAAO,CAACf,KAAK,IAAI,IAAI,CAACJ,OAAO,CAACsB,mBAAmB,CAAClB,KAAK,EAAE,IAAI,CAACD,WAAW,CAAC,CAAC;EACzF;EAEA;;;;EAIAoB,eAAeA,CAACC,SAAiB,EAAEC,OAAgB;IACjD,IAAID,SAAS,KAAK/B,eAAe,EAAE;MACjC,IAAI,CAACmB,eAAe,GAAGa,OAAO;;IAEhC,IAAID,SAAS,KAAK9B,eAAe,EAAE;MACjC,IAAI,CAACsB,eAAe,GAAGS,OAAO;;IAEhC,IAAID,SAAS,KAAK7B,cAAc,EAAE;MAChC,IAAI,CAACoB,cAAc,GAAGU,OAAO;;IAE/B,IAAID,SAAS,KAAK5B,gBAAgB,EAAE;MAClC,IAAI,CAACkB,gBAAgB,GAAGW,OAAO;;IAEjC,IAAID,SAAS,KAAK3B,gBAAgB,EAAE;MAClC,IAAI,CAACgB,gBAAgB,GAAGY,OAAO;;EAEnC;EAUApB,eAAeA,CAACD,KAAmB;IACjC,IAAI,IAAI,CAACY,eAAe,EAAE;MACxB,IAAIZ,KAAK,CAACsB,IAAI,KAAK,WAAW,EAAE;QAC9B,IAAI,CAACC,KAAK,CAACjC,eAAe,EAAEU,KAAK,CAAC;;;EAGxC;EAEAE,cAAcA,CAACF,KAAmB;IAChC,IAAI,IAAI,CAACW,cAAc,EAAE;MACvB,IAAIX,KAAK,CAACsB,IAAI,KAAK,UAAU,EAAE;QAC7B,IAAI,CAACC,KAAK,CAAChC,cAAc,EAAES,KAAK,CAAC;;;EAGvC;EAEAG,gBAAgBA,CAACH,KAAmB;IAClC,IAAI,IAAI,CAACU,gBAAgB,EAAE;MACzB,IAAIV,KAAK,CAACsB,IAAI,KAAK,YAAY,EAAE;QAC/B,IAAI,CAACC,KAAK,CAAC/B,gBAAgB,EAAEQ,KAAK,CAAC;;;EAGzC;EAEAI,gBAAgBA,CAACJ,KAAmB;IAClC,IAAI,IAAI,CAACS,gBAAgB,EAAE;MACzB,IAAIT,KAAK,CAACsB,IAAI,KAAK,YAAY,EAAE;QAC/B,IAAI,CAACC,KAAK,CAAC9B,gBAAgB,EAAEO,KAAK,CAAC;;;EAGzC;EAEAK,eAAeA,CAACL,KAAmB;IACjC,IAAI,IAAI,CAACQ,eAAe,EAAE;MACxB,QAAQR,KAAK,CAACsB,IAAI;QAChB,KAAK,WAAW;UACd,IAAItB,KAAK,CAACwB,MAAM,IAAI,CAAC,EAAE;YACrB;YACA,IAAI,CAAClB,OAAO,GAAG,IAAI;;UAErB;QACF,KAAK,WAAW;UACd;UACA,IAAIN,KAAK,CAACyB,KAAK,KAAK,CAAC,EAAE;YACrB;YACA,IAAI,CAACnB,OAAO,GAAG,KAAK;;UAEtB,IAAI,CAAC,IAAI,CAACA,OAAO,EAAE;YACjB;YACA;YACA,IAAI,CAACiB,KAAK,CAAClC,eAAe,EAAEW,KAAK,CAAC;;UAEpC;QACF,KAAK,SAAS;UACZ,IAAI,CAACM,OAAO,GAAG,KAAK;UACpB;QACF;MAAQ;;EAGd;EAEAiB,KAAKA,CACHD,IAAoF,EACpFtB,KAAmB;IAEnB,IAAI,CAACH,QAAQ,CAAC;MACZyB,IAAI;MACJI,MAAM,EAAE;QACNC,CAAC,EAAE3B,KAAK,CAAC4B,OAAO;QAChBC,CAAC,EAAE7B,KAAK,CAAC8B;OACV;MACDC,QAAQ,EAAE/B,KAAK;MACfgC,WAAW,EAAE,OAAO;MACpBC,MAAM,EAAEjC,KAAK,CAACiC;KACf,CAAC;EACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}