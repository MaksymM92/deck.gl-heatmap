{"ast":null,"code":"export function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\nexport function copy(target, source) {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset) {\n  let out = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}","map":{"version":3,"names":["push","target","source","size","length","startIndex","isDuplicate","i","copy","getPointAtIndex","positions","index","offset","out","arguments","undefined","startI"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@math.gl/polygon/src/utils.ts"],"sourcesContent":["import type {NumericArray} from '@math.gl/core';\n\nexport function push(target: number[], source: number[]): boolean {\n  const size = source.length;\n  const startIndex = target.length;\n\n  // dedupe, if source is the same point as the last vertex\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\n\nexport function copy(target: number[], source: Readonly<NumericArray>): void {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function getPointAtIndex(\n  positions: Readonly<NumericArray>,\n  index: number,\n  size: number,\n  offset: number,\n  out: number[] = []\n): number[] {\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}\n"],"mappings":"AAEA,OAAO,SAASA,IAATA,CAAcC,MAAd,EAAgCC,MAAhC,EAA2D;EAChE,MAAMC,IAAI,GAAGD,MAAM,CAACE,MAApB;EACA,MAAMC,UAAU,GAAGJ,MAAM,CAACG,MAA1B;EAGA,IAAIC,UAAU,GAAG,CAAjB,EAAoB;IAClB,IAAIC,WAAW,GAAG,IAAlB;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;MAC7B,IAAIN,MAAM,CAACI,UAAU,GAAGF,IAAb,GAAoBI,CAArB,CAAN,KAAkCL,MAAM,CAACK,CAAD,CAA5C,EAAiD;QAC/CD,WAAW,GAAG,KAAd;QACA;MACD;IACF;IACD,IAAIA,WAAJ,EAAiB;MACf,OAAO,KAAP;IACD;EACF;EAED,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;IAC7BN,MAAM,CAACI,UAAU,GAAGE,CAAd,CAAN,GAAyBL,MAAM,CAACK,CAAD,CAA/B;EACD;EACD,OAAO,IAAP;AACD;AAED,OAAO,SAASC,IAATA,CAAcP,MAAd,EAAgCC,MAAhC,EAAsE;EAC3E,MAAMC,IAAI,GAAGD,MAAM,CAACE,MAApB;EACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;IAC7BN,MAAM,CAACM,CAAD,CAAN,GAAYL,MAAM,CAACK,CAAD,CAAlB;EACD;AACF;AAED,OAAO,SAASE,eAATA,CACLC,SADK,EAELC,KAFK,EAGLR,IAHK,EAILS,MAJK,EAMK;EAAA,IADVC,GAAa,GAAAC,SAAA,CAAAV,MAAA,QAAAU,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EALX;EAOL,MAAME,MAAM,GAAGJ,MAAM,GAAGD,KAAK,GAAGR,IAAhC;EACA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAApB,EAA0BI,CAAC,EAA3B,EAA+B;IAC7BM,GAAG,CAACN,CAAD,CAAH,GAASG,SAAS,CAACM,MAAM,GAAGT,CAAV,CAAlB;EACD;EACD,OAAOM,GAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}