{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Texture2D, copyToTexture } from '@luma.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { createIterable } from '@deck.gl/core';\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\nconst noop = () => {};\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [10241]: 9987,\n  [10240]: 9729,\n  [10242]: 33071,\n  [10243]: 33071\n};\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nfunction resizeImage(ctx, imageData, maxWidth, maxHeight) {\n  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);\n  const width = Math.floor(imageData.width * resizeRatio);\n  const height = Math.floor(imageData.height * resizeRatio);\n  if (resizeRatio === 1) {\n    return {\n      data: imageData,\n      width,\n      height\n    };\n  }\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, width, height);\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return {\n    data: ctx.canvas,\n    width,\n    height\n  };\n}\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\nfunction resizeTexture(texture, width, height, parameters) {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n  const newTexture = new Texture2D(texture.gl, {\n    width,\n    height,\n    parameters\n  });\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n  texture.delete();\n  return newTexture;\n}\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {\n      icon,\n      xOffset\n    } = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\nexport function buildMapping(_ref) {\n  let {\n    icons,\n    buffer,\n    mapping = {},\n    xOffset = 0,\n    yOffset = 0,\n    rowHeight = 0,\n    canvasWidth\n  } = _ref;\n  let columns = [];\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n    if (!mapping[id]) {\n      const {\n        height,\n        width\n      } = icon;\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n      columns.push({\n        icon,\n        xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = {\n        ...icon,\n        source: object,\n        sourceIndex: objectInfo.index\n      };\n    }\n  }\n  return icons;\n}\nexport default class IconManager {\n  constructor(gl, _ref2) {\n    let {\n      onUpdate = noop,\n      onError = noop\n    } = _ref2;\n    _defineProperty(this, \"gl\", void 0);\n    _defineProperty(this, \"onUpdate\", void 0);\n    _defineProperty(this, \"onError\", void 0);\n    _defineProperty(this, \"_loadOptions\", null);\n    _defineProperty(this, \"_texture\", null);\n    _defineProperty(this, \"_externalTexture\", null);\n    _defineProperty(this, \"_mapping\", {});\n    _defineProperty(this, \"_textureParameters\", null);\n    _defineProperty(this, \"_pendingCount\", 0);\n    _defineProperty(this, \"_autoPacking\", false);\n    _defineProperty(this, \"_xOffset\", 0);\n    _defineProperty(this, \"_yOffset\", 0);\n    _defineProperty(this, \"_rowHeight\", 0);\n    _defineProperty(this, \"_buffer\", DEFAULT_BUFFER);\n    _defineProperty(this, \"_canvasWidth\", DEFAULT_CANVAS_WIDTH);\n    _defineProperty(this, \"_canvasHeight\", 0);\n    _defineProperty(this, \"_canvas\", null);\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n  finalize() {\n    var _this$_texture;\n    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();\n  }\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || {};\n  }\n  setProps(_ref3) {\n    let {\n      loadOptions,\n      autoPacking,\n      iconAtlas,\n      iconMapping,\n      textureParameters\n    } = _ref3;\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n    if (iconAtlas) {\n      var _this$_texture2;\n      (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n    if (textureParameters) {\n      this._textureParameters = textureParameters;\n    }\n  }\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n  packIcons(data, getIcon) {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n    if (icons.length > 0) {\n      const {\n        mapping,\n        xOffset,\n        yOffset,\n        rowHeight,\n        canvasHeight\n      } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS);\n      }\n      this.onUpdate();\n      this._canvas = this._canvas || document.createElement('canvas');\n      this._loadIcons(icons);\n    }\n  }\n  _loadIcons(icons) {\n    const ctx = this._canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, this._loadOptions).then(imageData => {\n        const id = getIconId(icon);\n        const iconDef = this._mapping[id];\n        const {\n          x,\n          y,\n          width: maxWidth,\n          height: maxHeight\n        } = iconDef;\n        const {\n          data,\n          width,\n          height\n        } = resizeImage(ctx, imageData, maxWidth, maxHeight);\n        this._texture.setSubImageData({\n          data,\n          x: x + (maxWidth - width) / 2,\n          y: y + (maxHeight - height) / 2,\n          width,\n          height\n        });\n        iconDef.width = width;\n        iconDef.height = height;\n        this._texture.generateMipmap();\n        this.onUpdate();\n      }).catch(error => {\n        this.onError({\n          url: icon.url,\n          source: icon.source,\n          sourceIndex: icon.sourceIndex,\n          loadOptions: this._loadOptions,\n          error\n        });\n      }).finally(() => {\n        this._pendingCount--;\n      });\n    }\n  }\n}","map":{"version":3,"names":["Texture2D","copyToTexture","load","createIterable","DEFAULT_CANVAS_WIDTH","DEFAULT_BUFFER","noop","DEFAULT_TEXTURE_PARAMETERS","nextPowOfTwo","number","Math","pow","ceil","log2","resizeImage","ctx","imageData","maxWidth","maxHeight","resizeRatio","min","width","height","floor","data","canvas","clearRect","drawImage","getIconId","icon","id","url","resizeTexture","texture","parameters","oldWidth","oldHeight","newTexture","gl","targetY","delete","buildRowMapping","mapping","columns","yOffset","i","length","xOffset","x","y","buildMapping","_ref","icons","buffer","rowHeight","canvasWidth","push","max","canvasHeight","getDiffIcons","getIcon","cachedIcons","iterable","objectInfo","object","index","Error","source","sourceIndex","IconManager","constructor","_ref2","onUpdate","onError","_defineProperty","finalize","_this$_texture","_texture","getTexture","_externalTexture","getIconMapping","_autoPacking","_mapping","setProps","_ref3","loadOptions","autoPacking","iconAtlas","iconMapping","textureParameters","_loadOptions","undefined","_this$_texture2","_textureParameters","isLoaded","_pendingCount","packIcons","document","Object","values","_buffer","_canvasWidth","_rowHeight","_xOffset","_yOffset","_canvasHeight","_canvas","createElement","_loadIcons","getContext","willReadFrequently","then","iconDef","setSubImageData","generateMipmap","catch","error","finally"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/layers/src/icon-layer/icon-manager.ts"],"sourcesContent":["/* global document */\nimport GL from '@luma.gl/constants';\nimport {Texture2D, copyToTexture} from '@luma.gl/core';\nimport {load} from '@loaders.gl/core';\nimport {createIterable} from '@deck.gl/core';\n\nimport type {AccessorFunction} from '@deck.gl/core';\n\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\ntype IconDef = {\n  /** Width of the icon */\n  width: number;\n  /** Height of the icon */\n  height: number;\n  /** Horizontal position of icon anchor. Default: half width. */\n  anchorX?: number;\n  /** Vertical position of icon anchor. Default: half height. */\n  anchorY?: number;\n  /**\n   * Whether the icon is treated as a transparency mask.\n   * If `true`, color defined by `getColor` is applied.\n   * If `false`, pixel color from the icon image is applied.\n   * @default false\n   */\n  mask?: boolean;\n};\n\nexport type UnpackedIcon = {\n  /** Url to fetch the icon */\n  url: string;\n  /** Unique identifier of the icon. Icons of the same id are only fetched once. Fallback to `url` if not specified. */\n  id?: string;\n} & IconDef;\n\ntype PrepackedIcon = {\n  /** Left position of the icon on the atlas */\n  x: number;\n  /** Top position of the icon on the atlas */\n  y: number;\n} & IconDef;\n\nexport type IconMapping = Record<string, PrepackedIcon>;\n\nexport type LoadIconErrorContext = {\n  error: Error;\n  /** The URL that was trying to fetch */\n  url: string;\n  /** The original data object that requested this icon */\n  source: any;\n  /** The index of the original data object that requested this icon */\n  sourceIndex: number;\n  /** The load options used for the fetch */\n  loadOptions: any;\n};\n\nfunction nextPowOfTwo(number: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n// update comment to create a new texture and copy original data.\nfunction resizeImage(\n  ctx: CanvasRenderingContext2D,\n  imageData: HTMLImageElement | ImageBitmap,\n  maxWidth: number,\n  maxHeight: number\n): {\n  data: HTMLImageElement | HTMLCanvasElement | ImageBitmap;\n  width: number;\n  height: number;\n} {\n  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);\n  const width = Math.floor(imageData.width * resizeRatio);\n  const height = Math.floor(imageData.height * resizeRatio);\n\n  if (resizeRatio === 1) {\n    // No resizing required\n    return {data: imageData, width, height};\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n\n  ctx.clearRect(0, 0, width, height);\n\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return {data: ctx.canvas, width, height};\n}\n\nfunction getIconId(icon: UnpackedIcon): string {\n  return icon && (icon.id || icon.url);\n}\n\n// resize texture without losing original data\nfunction resizeTexture(\n  texture: Texture2D,\n  width: number,\n  height: number,\n  parameters: any\n): Texture2D {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n\n  const newTexture = new Texture2D(texture.gl, {width, height, parameters});\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n\n  texture.delete();\n  return newTexture;\n}\n\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(\n  mapping: IconMapping,\n  columns: {\n    icon: UnpackedIcon;\n    xOffset: number;\n  }[],\n  yOffset: number\n): void {\n  for (let i = 0; i < columns.length; i++) {\n    const {icon, xOffset} = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}: {\n  /** list of icon definitions */\n  icons: UnpackedIcon[];\n  /** add bleeding buffer to the right and bottom side of the image */\n  buffer: number;\n  /** right position of last icon in old mapping */\n  xOffset: number;\n  /** top position in last icon in old mapping */\n  yOffset: number;\n  /** height of the last icon's row */\n  rowHeight: number;\n  /** max width of canvas */\n  canvasWidth: number;\n  mapping: IconMapping;\n}): {\n  mapping: IconMapping;\n  rowHeight: number;\n  xOffset: number;\n  yOffset: number;\n  canvasWidth: number;\n  canvasHeight: number;\n} {\n  let columns: {\n    icon: UnpackedIcon;\n    xOffset: number;\n  }[] = [];\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {height, width} = icon;\n\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\n\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(\n  data: any,\n  getIcon: AccessorFunction<any, UnpackedIcon> | null,\n  cachedIcons: Record<string, PrepackedIcon & {url?: string}>\n): Record<\n  string,\n  UnpackedIcon & {\n    source: any;\n    sourceIndex: number;\n  }\n> | null {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {iterable, objectInfo} = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = {...icon, source: object, sourceIndex: objectInfo.index};\n    }\n  }\n  return icons;\n}\n\nexport default class IconManager {\n  gl: WebGLRenderingContext;\n\n  private onUpdate: () => void;\n  private onError: (context: LoadIconErrorContext) => void;\n  private _loadOptions: any = null;\n  private _texture: Texture2D | null = null;\n  private _externalTexture: Texture2D | null = null;\n  private _mapping: IconMapping = {};\n  private _textureParameters: Record<number, number> | null = null;\n\n  /** count of pending requests to fetch icons */\n  private _pendingCount: number = 0;\n\n  private _autoPacking: boolean = false;\n\n  // / internal state used for autoPacking\n\n  private _xOffset: number = 0;\n  private _yOffset: number = 0;\n  private _rowHeight: number = 0;\n  private _buffer: number = DEFAULT_BUFFER;\n  private _canvasWidth: number = DEFAULT_CANVAS_WIDTH;\n  private _canvasHeight: number = 0;\n  private _canvas: HTMLCanvasElement | null = null;\n\n  constructor(\n    gl: WebGLRenderingContext,\n    {\n      onUpdate = noop,\n      onError = noop\n    }: {\n      /** Callback when the texture updates */\n      onUpdate: () => void;\n      /** Callback when an error is encountered */\n      onError: (context: LoadIconErrorContext) => void;\n    }\n  ) {\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n\n  finalize(): void {\n    this._texture?.delete();\n  }\n\n  getTexture(): Texture2D | null {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon: string | UnpackedIcon): PrepackedIcon {\n    const id = this._autoPacking ? getIconId(icon as UnpackedIcon) : (icon as string);\n    return this._mapping[id] || {};\n  }\n\n  setProps({\n    loadOptions,\n    autoPacking,\n    iconAtlas,\n    iconMapping,\n    textureParameters\n  }: {\n    loadOptions?: any;\n    autoPacking?: boolean;\n    iconAtlas?: Texture2D | null;\n    iconMapping?: IconMapping | null;\n    textureParameters?: Record<number, number> | null;\n  }) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      this._texture?.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n\n    if (textureParameters) {\n      this._textureParameters = textureParameters;\n    }\n  }\n\n  get isLoaded(): boolean {\n    return this._pendingCount === 0;\n  }\n\n  packIcons(data: any, getIcon: AccessorFunction<any, UnpackedIcon>): void {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      // generate icon mapping\n      const {mapping, xOffset, yOffset, rowHeight, canvasHeight} = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      // create new texture\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(\n          this._texture,\n          this._canvasWidth,\n          this._canvasHeight,\n          this._textureParameters || DEFAULT_TEXTURE_PARAMETERS\n        );\n      }\n\n      this.onUpdate();\n\n      // load images\n      this._canvas = this._canvas || document.createElement('canvas');\n      this._loadIcons(icons);\n    }\n  }\n\n  private _loadIcons(\n    icons: (UnpackedIcon & {\n      source: any;\n      sourceIndex: number;\n    })[]\n  ): void {\n    // This method is only called in the auto packing case, where _canvas is defined\n    const ctx = this._canvas!.getContext('2d', {\n      willReadFrequently: true\n    }) as CanvasRenderingContext2D;\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, this._loadOptions)\n        .then(imageData => {\n          const id = getIconId(icon);\n\n          const iconDef = this._mapping[id];\n          const {x, y, width: maxWidth, height: maxHeight} = iconDef;\n\n          const {data, width, height} = resizeImage(ctx, imageData, maxWidth, maxHeight);\n\n          this._texture.setSubImageData({\n            data,\n            x: x + (maxWidth - width) / 2,\n            y: y + (maxHeight - height) / 2,\n            width,\n            height\n          });\n          iconDef.width = width;\n          iconDef.height = height;\n\n          // Call to regenerate mipmaps after modifying texture(s)\n          this._texture.generateMipmap();\n\n          this.onUpdate();\n        })\n        .catch(error => {\n          this.onError({\n            url: icon.url,\n            source: icon.source,\n            sourceIndex: icon.sourceIndex,\n            loadOptions: this._loadOptions,\n            error\n          });\n        })\n        .finally(() => {\n          this._pendingCount--;\n        });\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}