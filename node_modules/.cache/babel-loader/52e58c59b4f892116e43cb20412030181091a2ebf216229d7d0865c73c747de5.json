{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport { createIterable, getAccessorFromBuffer } from '../../utils/iterable-utils';\nimport { fillArray } from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport { normalizeTransitionSettings } from './attribute-transition-utils';\nexport default class Attribute extends DataColumn {\n  constructor(gl, opts) {\n    super(gl, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL\n    });\n    _defineProperty(this, \"constant\", false);\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n    Object.seal(this.settings);\n    Object.seal(this.state);\n    this._validateAttributeUpdaters();\n  }\n  get startIndices() {\n    return this.state.startIndices;\n  }\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n  needsRedraw() {\n    let {\n      clearChangedFlags = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n  getUpdateTriggers() {\n    const {\n      accessor\n    } = this.settings;\n    return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n  }\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {\n      accessor\n    } = this.settings;\n    const layerSettings = this.settings.transition;\n    const userSettings = Array.isArray(accessor) ? opts[accessor.find(a => opts[a])] : opts[accessor];\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n  setNeedsUpdate() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n    let dataRange = arguments.length > 1 ? arguments[1] : undefined;\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {\n        startRow = 0,\n        endRow = Infinity\n      } = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n  setNeedsRedraw() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n  allocate(numInstances) {\n    const {\n      state,\n      settings\n    } = this;\n    if (settings.noAlloc) {\n      return false;\n    }\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n    return false;\n  }\n  updateBuffer(_ref) {\n    let {\n      numInstances,\n      data,\n      props,\n      context\n    } = _ref;\n    if (!this.needsUpdate()) {\n      return false;\n    }\n    const {\n      state: {\n        updateRanges\n      },\n      settings: {\n        update,\n        noAlloc\n      }\n    } = this;\n    let updated = true;\n    if (update) {\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {\n          data,\n          startRow,\n          endRow,\n          props,\n          numInstances\n        });\n      }\n      if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n          super.updateSubBuffer({\n            startOffset,\n            endOffset\n          });\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n    return updated;\n  }\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n    const hasChanged = this.setData({\n      constant: true,\n      value\n    });\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n  setExternalBuffer(buffer) {\n    const {\n      state\n    } = this;\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n    this.clearNeedsUpdate();\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n  setBinaryValue(buffer) {\n    let startIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const {\n      state,\n      settings\n    } = this;\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n    if (settings.noAlloc) {\n      return false;\n    }\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {\n          value: buffer\n        };\n      }\n      const binaryValue = buffer;\n      assert(ArrayBuffer.isView(binaryValue.value), \"invalid \".concat(settings.accessor));\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices,\n        nested: needsNormalize\n      });\n      return false;\n    }\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n  getVertexOffset(row) {\n    const {\n      startIndices\n    } = this;\n    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;\n    return vertexIndex * this.size;\n  }\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {\n      [this.id]: null\n    };\n    const shaderAttributes = {};\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n    }\n    return shaderAttributes;\n  }\n  _autoUpdater(attribute, _ref2) {\n    let {\n      data,\n      startRow,\n      endRow,\n      props,\n      numInstances\n    } = _ref2;\n    if (attribute.constant) {\n      return;\n    }\n    const {\n      settings,\n      state,\n      value,\n      size,\n      startIndices\n    } = attribute;\n    const {\n      accessor,\n      transform\n    } = settings;\n    const accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n    assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n    let i = attribute.getVertexOffset(startRow);\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        objectValue = transform.call(this, objectValue);\n      }\n      if (startIndices) {\n        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n  }\n  _validateAttributeUpdaters() {\n    const {\n      settings\n    } = this;\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n    }\n  }\n  _checkAttributeArray() {\n    const {\n      value\n    } = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n      if (!valid) {\n        throw new Error(\"Illegal attribute generated for \".concat(this.id));\n      }\n    }\n  }\n}","map":{"version":3,"names":["DataColumn","assert","createIterable","getAccessorFromBuffer","fillArray","range","normalizeTransitionSettings","Attribute","constructor","gl","opts","startIndices","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","FULL","_defineProperty","settings","update","accessor","_autoUpdater","undefined","Object","seal","state","_validateAttributeUpdaters","layout","clearChangedFlags","arguments","length","getUpdateTriggers","id","concat","supportsTransition","Boolean","transition","getTransitionSetting","layerSettings","userSettings","Array","isArray","find","a","setNeedsUpdate","reason","dataRange","setNeedsRedraw","startRow","endRow","Infinity","add","clearNeedsUpdate","EMPTY","allocate","numInstances","noAlloc","updateBuffer","_ref","data","props","context","updated","call","value","constant","buffer","byteLength","byteOffset","setData","startOffset","Number","isFinite","getVertexOffset","endOffset","size","updateSubBuffer","_checkAttributeArray","setConstantValue","hasChanged","setExternalBuffer","setBinaryValue","transform","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","getShaderAttributes","shaderAttributeDefs","shaderAttributes","shaderAttributeName","assign","attribute","_ref2","accessorFunc","i","iterable","objectInfo","object","index","objectValue","numVertices","startIndex","item","_normalizeValue","set","target","source","start","count","hasUpdater","Error","limit","Math","min","valid"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/lib/attribute/attribute.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport DataColumn, {DataColumnOptions, ShaderAttributeOptions, BufferAccessor} from './data-column';\nimport {IShaderAttribute} from './shader-attribute';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings, TransitionSettings} from './attribute-transition-utils';\nimport type {Buffer} from '@luma.gl/webgl';\n\nimport type {NumericArray, TypedArray} from '../../types/types';\n\nexport type Accessor<DataType, ReturnType> = (\n  object: DataType,\n  context: {\n    data: any;\n    index: number;\n    target: number[];\n  }\n) => ReturnType;\n\nexport type Updater = (\n  attribute: Attribute,\n  {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }: {\n    data: any;\n    startRow: number;\n    endRow: number;\n    props: any;\n    numInstances: number;\n  }\n) => void;\n\nexport type AttributeOptions = DataColumnOptions<{\n  transition?: boolean | Partial<TransitionSettings>;\n  noAlloc?: boolean;\n  update?: Updater;\n  accessor?: Accessor<any, any> | string | string[];\n  transform?: (value: any) => any;\n  shaderAttributes?: Record<string, Partial<ShaderAttributeOptions>>;\n}>;\n\nexport type BinaryAttribute = Partial<BufferAccessor> & {value?: TypedArray; buffer?: Buffer};\n\ntype AttributeInternalState = {\n  startIndices: NumericArray | null;\n  /** Legacy: external binary supplied via attribute name */\n  lastExternalBuffer: TypedArray | Buffer | BinaryAttribute | null;\n  /** External binary supplied via accessor name */\n  binaryValue: TypedArray | Buffer | BinaryAttribute | null;\n  binaryAccessor: Accessor<any, any> | null;\n  needsUpdate: string | boolean;\n  needsRedraw: string | boolean;\n  updateRanges: number[][];\n};\n\nexport default class Attribute extends DataColumn<AttributeOptions, AttributeInternalState> {\n  /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */\n  constant: boolean = false;\n\n  constructor(gl: WebGLRenderingContext, opts: AttributeOptions) {\n    super(gl, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL\n    });\n\n    // eslint-disable-next-line\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices(): NumericArray | null {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout: NumericArray | null) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate(): string | boolean {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false}: {clearChangedFlags?: boolean} = {}): string | boolean {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers(): string[] {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition(): boolean {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts: Record<string, any>): TransitionSettings | null {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? // @ts-ignore\n        opts[accessor.find(a => opts[a])]\n      : // @ts-ignore\n        opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason: string = this.id, dataRange?: {startRow?: number; endRow?: number}): void {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate(): void {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason: string = this.id): void {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  allocate(numInstances: number): boolean {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }: {\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }): boolean {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < (this.value as TypedArray).byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n            ? this.value.length\n            : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value?: NumericArray): boolean {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer?: TypedArray | Buffer | BinaryAttribute): boolean {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(\n    buffer?: TypedArray | Buffer | BinaryAttribute,\n    startIndices: NumericArray | null = null\n  ): boolean {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {value: buffer};\n      }\n      const binaryValue = buffer as BinaryAttribute;\n      assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices as NumericArray,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row: number): number {\n    const {startIndices} = this;\n    const vertexIndex = startIndices\n      ? row < startIndices.length\n        ? startIndices[row]\n        : this.numInstances\n      : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes(): Record<string, IShaderAttribute> {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes: Record<string, IShaderAttribute> = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  private _autoUpdater(\n    attribute: Attribute,\n    {\n      data,\n      startRow,\n      endRow,\n      props,\n      numInstances\n    }: {\n      data: any;\n      startRow: number;\n      endRow: number;\n      props: any;\n      numInstances: number;\n    }\n  ): void {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc: Accessor<any, any> =\n      state.binaryAccessor ||\n      // @ts-ignore\n      (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value as TypedArray, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          (value as TypedArray).set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value as TypedArray, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  private _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  private _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}