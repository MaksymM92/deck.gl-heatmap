{"ast":null,"code":"import earcut from 'earcut';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\nconst windingOptions = {\n  isClosed: true\n};\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\nexport function getPositions(polygon) {\n  return 'positions' in polygon ? polygon.positions : polygon;\n}\nexport function getHoleIndices(polygon) {\n  return 'holeIndices' in polygon ? polygon.holeIndices : null;\n}\nfunction isNested(polygon) {\n  return Array.isArray(polygon[0]);\n}\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\nfunction isNestedRingClosed(simplePolygon) {\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\nfunction copyFlatRing(target, targetStartIndex, positions, size) {\n  let srcStartIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let srcEndIndex = arguments.length > 5 ? arguments[5] : undefined;\n  let windingDirection = arguments.length > 6 ? arguments[6] : undefined;\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n  const positions = [];\n  const holeIndices = [];\n  if ('positions' in polygon) {\n    const {\n      positions: srcPositions,\n      holeIndices: srcHoleIndices\n    } = polygon;\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n        holeIndices.push(targetIndex);\n      }\n      holeIndices.pop();\n      return {\n        positions,\n        holeIndices\n      };\n    }\n    polygon = srcPositions;\n  }\n  if (!isNested(polygon)) {\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    let targetIndex = 0;\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n      holeIndices.push(targetIndex);\n    }\n    holeIndices.pop();\n    return {\n      positions,\n      holeIndices\n    };\n  }\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\nfunction getPlaneArea(positions, xIndex, yIndex) {\n  const numVerts = positions.length / 3;\n  let area = 0;\n  for (let i = 0; i < numVerts; i++) {\n    const j = (i + 1) % numVerts;\n    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];\n    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];\n  }\n  return Math.abs(area / 2);\n}\nfunction permutePositions(positions, xIndex, yIndex, zIndex) {\n  const numVerts = positions.length / 3;\n  for (let i = 0; i < numVerts; i++) {\n    const o = i * 3;\n    const x = positions[o + 0];\n    const y = positions[o + 1];\n    const z = positions[o + 2];\n    positions[o + xIndex] = x;\n    positions[o + yIndex] = y;\n    positions[o + zIndex] = z;\n  }\n}\nexport function getSurfaceIndices(polygon, positionSize, preproject, full3d) {\n  let holeIndices = getHoleIndices(polygon);\n  if (holeIndices) {\n    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = getPositions(polygon);\n  const is3d = full3d && positionSize === 3;\n  if (preproject) {\n    const n = positions.length;\n    positions = positions.slice();\n    const p = [];\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      if (is3d) {\n        p[2] = positions[i + 2];\n      }\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n      if (is3d) {\n        positions[i + 2] = xy[2];\n      }\n    }\n  }\n  if (is3d) {\n    const xyArea = getPlaneArea(positions, 0, 1);\n    const xzArea = getPlaneArea(positions, 0, 2);\n    const yzArea = getPlaneArea(positions, 1, 2);\n    if (!xyArea && !xzArea && !yzArea) {\n      return [];\n    }\n    if (xyArea > xzArea && xyArea > yzArea) {} else if (xzArea > yzArea) {\n      if (!preproject) {\n        positions = positions.slice();\n      }\n      permutePositions(positions, 0, 2, 1);\n    } else {\n      if (!preproject) {\n        positions = positions.slice();\n      }\n      permutePositions(positions, 1, 2, 0);\n    }\n  }\n  return earcut(positions, holeIndices, positionSize);\n}","map":{"version":3,"names":["earcut","modifyPolygonWindingDirection","WINDING","OUTER_POLYGON_WINDING","CLOCKWISE","HOLE_POLYGON_WINDING","COUNTER_CLOCKWISE","windingOptions","isClosed","validate","polygon","positions","Array","isArray","ArrayBuffer","isView","Error","getPositions","getHoleIndices","holeIndices","isNested","isSimple","length","Number","isFinite","isNestedRingClosed","simplePolygon","p0","p1","isFlatRingClosed","size","startIndex","endIndex","i","copyNestedRing","target","targetStartIndex","windingDirection","targetIndex","len","j","start","end","copyFlatRing","srcStartIndex","arguments","undefined","srcEndIndex","srcLength","normalize","positionSize","srcPositions","srcHoleIndices","push","pop","polygonIndex","entries","getPlaneArea","xIndex","yIndex","numVerts","area","Math","abs","permutePositions","zIndex","o","x","y","z","getSurfaceIndices","preproject","full3d","map","positionIndex","is3d","n","slice","p","xy","xyArea","xzArea","yzArea"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js"],"sourcesContent":["import earcut from 'earcut';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\nconst windingOptions = {\n  isClosed: true\n};\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nexport function getPositions(polygon) {\n  return 'positions' in polygon ? polygon.positions : polygon;\n}\nexport function getHoleIndices(polygon) {\n  return 'holeIndices' in polygon ? polygon.holeIndices : null;\n}\n\nfunction isNested(polygon) {\n  return Array.isArray(polygon[0]);\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n  const positions = [];\n  const holeIndices = [];\n\n  if ('positions' in polygon) {\n    const {\n      positions: srcPositions,\n      holeIndices: srcHoleIndices\n    } = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions,\n        holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (!isNested(polygon)) {\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n\n  if (!isSimple(polygon)) {\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n      holeIndices.push(targetIndex);\n    }\n\n    holeIndices.pop();\n    return {\n      positions,\n      holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\n\nfunction getPlaneArea(positions, xIndex, yIndex) {\n  const numVerts = positions.length / 3;\n  let area = 0;\n\n  for (let i = 0; i < numVerts; i++) {\n    const j = (i + 1) % numVerts;\n    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];\n    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];\n  }\n\n  return Math.abs(area / 2);\n}\n\nfunction permutePositions(positions, xIndex, yIndex, zIndex) {\n  const numVerts = positions.length / 3;\n\n  for (let i = 0; i < numVerts; i++) {\n    const o = i * 3;\n    const x = positions[o + 0];\n    const y = positions[o + 1];\n    const z = positions[o + 2];\n    positions[o + xIndex] = x;\n    positions[o + yIndex] = y;\n    positions[o + zIndex] = z;\n  }\n}\n\nexport function getSurfaceIndices(polygon, positionSize, preproject, full3d) {\n  let holeIndices = getHoleIndices(polygon);\n\n  if (holeIndices) {\n    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n\n  let positions = getPositions(polygon);\n  const is3d = full3d && positionSize === 3;\n\n  if (preproject) {\n    const n = positions.length;\n    positions = positions.slice();\n    const p = [];\n\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n\n      if (is3d) {\n        p[2] = positions[i + 2];\n      }\n\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n\n      if (is3d) {\n        positions[i + 2] = xy[2];\n      }\n    }\n  }\n\n  if (is3d) {\n    const xyArea = getPlaneArea(positions, 0, 1);\n    const xzArea = getPlaneArea(positions, 0, 2);\n    const yzArea = getPlaneArea(positions, 1, 2);\n\n    if (!xyArea && !xzArea && !yzArea) {\n      return [];\n    }\n\n    if (xyArea > xzArea && xyArea > yzArea) {} else if (xzArea > yzArea) {\n      if (!preproject) {\n        positions = positions.slice();\n      }\n\n      permutePositions(positions, 0, 2, 1);\n    } else {\n      if (!preproject) {\n        positions = positions.slice();\n      }\n\n      permutePositions(positions, 1, 2, 0);\n    }\n  }\n\n  return earcut(positions, holeIndices, positionSize);\n}\n//# sourceMappingURL=polygon.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}