{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Texture2D, ProgramManager } from '@luma.gl/core';\nimport { AmbientLight } from './ambient-light';\nimport { DirectionalLight } from './directional-light';\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport ShadowPass from '../../passes/shadow-pass';\nimport shadow from '../../shaderlib/shadow/shadow';\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {\n  color: [255, 255, 255],\n  intensity: 1.0\n};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{\n  color: [255, 255, 255],\n  intensity: 1.0,\n  direction: [-1, 3, -1]\n}, {\n  color: [255, 255, 255],\n  intensity: 0.9,\n  direction: [1, -8, -2.5]\n}];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\nexport default class LightingEffect {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"id\", 'lighting-effect');\n    _defineProperty(this, \"props\", void 0);\n    _defineProperty(this, \"shadowColor\", DEFAULT_SHADOW_COLOR);\n    _defineProperty(this, \"shadow\", void 0);\n    _defineProperty(this, \"ambientLight\", void 0);\n    _defineProperty(this, \"directionalLights\", void 0);\n    _defineProperty(this, \"pointLights\", void 0);\n    _defineProperty(this, \"shadowPasses\", []);\n    _defineProperty(this, \"shadowMaps\", []);\n    _defineProperty(this, \"dummyShadowMap\", null);\n    _defineProperty(this, \"programManager\", void 0);\n    _defineProperty(this, \"shadowMatrices\", void 0);\n    this.setProps(props);\n  }\n  setProps(props) {\n    this.ambientLight = null;\n    this.directionalLights = [];\n    this.pointLights = [];\n    for (const key in props) {\n      const lightSource = props[key];\n      switch (lightSource.type) {\n        case 'ambient':\n          this.ambientLight = lightSource;\n          break;\n        case 'directional':\n          this.directionalLights.push(lightSource);\n          break;\n        case 'point':\n          this.pointLights.push(lightSource);\n          break;\n        default:\n      }\n    }\n    this._applyDefaultLights();\n    this.shadow = this.directionalLights.some(light => light.shadow);\n    this.props = props;\n  }\n  preRender(gl, _ref) {\n    let {\n      layers,\n      layerFilter,\n      viewports,\n      onViewportActive,\n      views\n    } = _ref;\n    if (!this.shadow) return;\n    this.shadowMatrices = this._calculateMatrices();\n    if (this.shadowPasses.length === 0) {\n      this._createShadowPasses(gl);\n    }\n    if (!this.programManager) {\n      this.programManager = ProgramManager.getDefaultProgramManager(gl);\n      if (shadow) {\n        this.programManager.addDefaultModule(shadow);\n      }\n    }\n    if (!this.dummyShadowMap) {\n      this.dummyShadowMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n    for (let i = 0; i < this.shadowPasses.length; i++) {\n      const shadowPass = this.shadowPasses[i];\n      shadowPass.render({\n        layers,\n        layerFilter,\n        viewports,\n        onViewportActive,\n        views,\n        moduleParameters: {\n          shadowLightId: i,\n          dummyShadowMap: this.dummyShadowMap,\n          shadowMatrices: this.shadowMatrices\n        }\n      });\n    }\n  }\n  getModuleParameters(layer) {\n    const parameters = this.shadow ? {\n      shadowMaps: this.shadowMaps,\n      dummyShadowMap: this.dummyShadowMap,\n      shadowColor: this.shadowColor,\n      shadowMatrices: this.shadowMatrices\n    } : {};\n    parameters.lightSources = {\n      ambientLight: this.ambientLight,\n      directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({\n        layer\n      })),\n      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({\n        layer\n      }))\n    };\n    return parameters;\n  }\n  cleanup() {\n    for (const shadowPass of this.shadowPasses) {\n      shadowPass.delete();\n    }\n    this.shadowPasses.length = 0;\n    this.shadowMaps.length = 0;\n    if (this.dummyShadowMap) {\n      this.dummyShadowMap.delete();\n      this.dummyShadowMap = null;\n    }\n    if (this.shadow && this.programManager) {\n      this.programManager.removeDefaultModule(shadow);\n      this.programManager = null;\n    }\n  }\n  _calculateMatrices() {\n    const lightMatrices = [];\n    for (const light of this.directionalLights) {\n      const viewMatrix = new Matrix4().lookAt({\n        eye: new Vector3(light.direction).negate()\n      });\n      lightMatrices.push(viewMatrix);\n    }\n    return lightMatrices;\n  }\n  _createShadowPasses(gl) {\n    for (let i = 0; i < this.directionalLights.length; i++) {\n      const shadowPass = new ShadowPass(gl);\n      this.shadowPasses[i] = shadowPass;\n      this.shadowMaps[i] = shadowPass.shadowMap;\n    }\n  }\n  _applyDefaultLights() {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = this;\n    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n      this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));\n    }\n  }\n}","map":{"version":3,"names":["Texture2D","ProgramManager","AmbientLight","DirectionalLight","Matrix4","Vector3","ShadowPass","shadow","DEFAULT_AMBIENT_LIGHT_PROPS","color","intensity","DEFAULT_DIRECTIONAL_LIGHT_PROPS","direction","DEFAULT_SHADOW_COLOR","LightingEffect","constructor","props","arguments","length","undefined","_defineProperty","setProps","ambientLight","directionalLights","pointLights","key","lightSource","type","push","_applyDefaultLights","some","light","preRender","gl","_ref","layers","layerFilter","viewports","onViewportActive","views","shadowMatrices","_calculateMatrices","shadowPasses","_createShadowPasses","programManager","getDefaultProgramManager","addDefaultModule","dummyShadowMap","width","height","i","shadowPass","render","moduleParameters","shadowLightId","getModuleParameters","layer","parameters","shadowMaps","shadowColor","lightSources","map","directionalLight","getProjectedLight","pointLight","cleanup","delete","removeDefaultModule","lightMatrices","viewMatrix","lookAt","eye","negate","shadowMap"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/effects/lighting/lighting-effect.ts"],"sourcesContent":["import {Texture2D, ProgramManager} from '@luma.gl/core';\nimport {AmbientLight} from './ambient-light';\nimport {DirectionalLight} from './directional-light';\nimport {PointLight} from './point-light';\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport ShadowPass from '../../passes/shadow-pass';\nimport shadow from '../../shaderlib/shadow/shadow';\n\nimport type Layer from '../../lib/layer';\nimport type {Effect, PreRenderOptions} from '../../lib/effect';\n\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {color: [255, 255, 255], intensity: 1.0};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [\n  {\n    color: [255, 255, 255],\n    intensity: 1.0,\n    direction: [-1, 3, -1]\n  },\n  {\n    color: [255, 255, 255],\n    intensity: 0.9,\n    direction: [1, -8, -2.5]\n  }\n];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\n\ntype LightingEffectProps = Record<string, PointLight | DirectionalLight | AmbientLight>;\n\n// Class to manage ambient, point and directional light sources in deck\nexport default class LightingEffect implements Effect {\n  id = 'lighting-effect';\n  props!: LightingEffectProps;\n  shadowColor: number[] = DEFAULT_SHADOW_COLOR;\n\n  private shadow!: boolean;\n  private ambientLight!: AmbientLight | null;\n  private directionalLights!: DirectionalLight[];\n  private pointLights!: PointLight[];\n  private shadowPasses: ShadowPass[] = [];\n  private shadowMaps: Texture2D[] = [];\n  private dummyShadowMap: Texture2D | null = null;\n  private programManager?: ProgramManager;\n  private shadowMatrices?: Matrix4[];\n\n  constructor(props: LightingEffectProps = {}) {\n    this.setProps(props);\n  }\n\n  setProps(props: LightingEffectProps) {\n    this.ambientLight = null;\n    this.directionalLights = [];\n    this.pointLights = [];\n\n    for (const key in props) {\n      const lightSource = props[key];\n\n      switch (lightSource.type) {\n        case 'ambient':\n          this.ambientLight = lightSource;\n          break;\n\n        case 'directional':\n          this.directionalLights.push(lightSource as DirectionalLight);\n          break;\n\n        case 'point':\n          this.pointLights.push(lightSource as PointLight);\n          break;\n        default:\n      }\n    }\n    this._applyDefaultLights();\n\n    this.shadow = this.directionalLights.some(light => light.shadow);\n    this.props = props;\n  }\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views}: PreRenderOptions\n  ) {\n    if (!this.shadow) return;\n\n    // create light matrix every frame to make sure always updated from light source\n    this.shadowMatrices = this._calculateMatrices();\n\n    if (this.shadowPasses.length === 0) {\n      this._createShadowPasses(gl);\n    }\n    if (!this.programManager) {\n      // TODO - support multiple contexts\n      this.programManager = ProgramManager.getDefaultProgramManager(gl);\n      if (shadow) {\n        this.programManager.addDefaultModule(shadow);\n      }\n    }\n\n    if (!this.dummyShadowMap) {\n      this.dummyShadowMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    for (let i = 0; i < this.shadowPasses.length; i++) {\n      const shadowPass = this.shadowPasses[i];\n      shadowPass.render({\n        layers,\n        layerFilter,\n        viewports,\n        onViewportActive,\n        views,\n        moduleParameters: {\n          shadowLightId: i,\n          dummyShadowMap: this.dummyShadowMap,\n          shadowMatrices: this.shadowMatrices\n        }\n      });\n    }\n  }\n\n  getModuleParameters(layer: Layer) {\n    const parameters: {\n      lightSources?: {\n        ambientLight: AmbientLight | null;\n        directionalLights: DirectionalLight[];\n        pointLights: PointLight[];\n      };\n      shadowMaps?: Texture2D[];\n      dummyShadowMap?: Texture2D;\n      shadowColor?: number[];\n      shadowMatrices?: Matrix4[];\n    } = this.shadow\n      ? {\n          shadowMaps: this.shadowMaps,\n          dummyShadowMap: this.dummyShadowMap,\n          shadowColor: this.shadowColor,\n          shadowMatrices: this.shadowMatrices\n        }\n      : {};\n\n    // when not rendering to screen, turn off lighting by adding empty light source object\n    // lights shader module relies on the `lightSources` to turn on/off lighting\n    parameters.lightSources = {\n      ambientLight: this.ambientLight,\n      directionalLights: this.directionalLights.map(directionalLight =>\n        directionalLight.getProjectedLight({layer})\n      ),\n      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({layer}))\n    };\n\n    return parameters;\n  }\n\n  cleanup(): void {\n    for (const shadowPass of this.shadowPasses) {\n      shadowPass.delete();\n    }\n    this.shadowPasses.length = 0;\n    this.shadowMaps.length = 0;\n\n    if (this.dummyShadowMap) {\n      this.dummyShadowMap.delete();\n      this.dummyShadowMap = null;\n    }\n\n    if (this.shadow && this.programManager) {\n      this.programManager.removeDefaultModule(shadow);\n      this.programManager = null;\n    }\n  }\n\n  private _calculateMatrices(): Matrix4[] {\n    const lightMatrices: Matrix4[] = [];\n    for (const light of this.directionalLights) {\n      const viewMatrix = new Matrix4().lookAt({\n        eye: new Vector3(light.direction).negate()\n      });\n\n      lightMatrices.push(viewMatrix);\n    }\n    return lightMatrices;\n  }\n\n  private _createShadowPasses(gl: WebGLRenderingContext): void {\n    for (let i = 0; i < this.directionalLights.length; i++) {\n      const shadowPass = new ShadowPass(gl);\n      this.shadowPasses[i] = shadowPass;\n      this.shadowMaps[i] = shadowPass.shadowMap;\n    }\n  }\n\n  private _applyDefaultLights(): void {\n    const {ambientLight, pointLights, directionalLights} = this;\n    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n      this.directionalLights.push(\n        new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]),\n        new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1])\n      );\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}