{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Attribute from './attribute';\nimport log from '../../utils/log';\nimport memoize from '../../utils/memoize';\nimport { mergeBounds } from '../../utils/math-utils';\nimport debug from '../../debug';\nimport AttributeTransitionManager from './attribute-transition-manager';\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\nexport default class AttributeManager {\n  constructor(gl) {\n    let {\n      id = 'attribute-manager',\n      stats,\n      timeline\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"gl\", void 0);\n    _defineProperty(this, \"attributes\", void 0);\n    _defineProperty(this, \"updateTriggers\", void 0);\n    _defineProperty(this, \"needsRedraw\", void 0);\n    _defineProperty(this, \"userData\", void 0);\n    _defineProperty(this, \"stats\", void 0);\n    _defineProperty(this, \"attributeTransitionManager\", void 0);\n    _defineProperty(this, \"mergeBoundsMemoized\", memoize(mergeBounds));\n    this.id = id;\n    this.gl = gl;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: \"\".concat(id, \"-transitions\"),\n      timeline\n    });\n    Object.seal(this);\n  }\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n  getNeedsRedraw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clearRedrawFlags: false\n    };\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n  add(attributes) {\n    this._add(attributes);\n  }\n  addInstanced(attributes) {\n    this._add(attributes, {\n      instanced: 1\n    });\n  }\n  remove(attributeNameArray) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n  invalidate(triggerName, dataRange) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n  invalidateAll(dataRange) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n  update(_ref) {\n    let {\n      data,\n      numInstances,\n      startIndices = null,\n      transitions,\n      props = {},\n      buffers = {},\n      context = {}\n    } = _ref;\n    let updated = false;\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n      if (props[attributeName]) {\n        log.removed(\"props.\".concat(attributeName), \"data.attributes.\".concat(attributeName))();\n      }\n      if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {} else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n    if (updated) {\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n  updateTransition() {\n    const {\n      attributeTransitionManager\n    } = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n  getAttributes() {\n    return this.attributes;\n  }\n  getBounds(attributeNames) {\n    const bounds = attributeNames.map(attributeName => {\n      var _this$attributes$attr;\n      return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();\n    });\n    return this.mergeBoundsMemoized(bounds);\n  }\n  getChangedAttributes() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clearChangedFlags: false\n    };\n    const {\n      attributes,\n      attributeTransitionManager\n    } = this;\n    const changedAttributes = {\n      ...attributeTransitionManager.getAttributes()\n    };\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n    return changedAttributes;\n  }\n  getShaderAttributes(attributes) {\n    let excludeAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n    const shaderAttributes = {};\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n    return shaderAttributes;\n  }\n  _add(attributes) {\n    let extraProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n    this._mapUpdateTriggersToAttributes();\n  }\n  _createAttribute(name, attribute, extraProps) {\n    const props = {\n      ...attribute,\n      id: name,\n      size: attribute.isIndexed && 1 || attribute.size || 1,\n      divisor: extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n    return new Attribute(this.gl, props);\n  }\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n    this.updateTriggers = triggers;\n  }\n  _invalidateTrigger(triggerName, dataRange) {\n    const {\n      attributes,\n      updateTriggers\n    } = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n  _updateAttribute(opts) {\n    const {\n      attribute,\n      numInstances\n    } = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n    if (attribute.constant) {\n      attribute.setConstantValue(attribute.value);\n      return;\n    }\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}","map":{"version":3,"names":["Attribute","log","memoize","mergeBounds","debug","AttributeTransitionManager","TRACE_INVALIDATE","TRACE_UPDATE_START","TRACE_UPDATE_END","TRACE_ATTRIBUTE_UPDATE_START","TRACE_ATTRIBUTE_ALLOCATE","TRACE_ATTRIBUTE_UPDATE_END","AttributeManager","constructor","gl","id","stats","timeline","arguments","length","undefined","_defineProperty","attributes","updateTriggers","needsRedraw","userData","attributeTransitionManager","concat","Object","seal","finalize","attributeName","delete","getNeedsRedraw","opts","clearRedrawFlags","redraw","setNeedsRedraw","add","_add","addInstanced","instanced","remove","attributeNameArray","name","invalidate","triggerName","dataRange","invalidatedAttributes","_invalidateTrigger","invalidateAll","setNeedsUpdate","update","_ref","data","numInstances","startIndices","transitions","props","buffers","context","updated","get","timeStart","attribute","accessorName","settings","accessor","removed","setExternalBuffer","setBinaryValue","setConstantValue","needsUpdate","_updateAttribute","timeEnd","updateTransition","transitionUpdated","run","getAttributes","getBounds","attributeNames","bounds","map","_this$attributes$attr","mergeBoundsMemoized","getChangedAttributes","clearChangedFlags","changedAttributes","hasAttribute","getShaderAttributes","excludeAttributes","shaderAttributes","assign","extraProps","_createAttribute","_mapUpdateTriggersToAttributes","size","isIndexed","divisor","triggers","getUpdateTriggers","forEach","push","constant","value","allocate","updateBuffer"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/lib/attribute/attribute-manager.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute, {AttributeOptions} from './attribute';\nimport {IShaderAttribute} from './shader-attribute';\nimport log from '../../utils/log';\nimport memoize from '../../utils/memoize';\nimport {mergeBounds} from '../../utils/math-utils';\nimport debug from '../../debug';\nimport {NumericArray} from '../../types/types';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nimport type {Stats} from '@probe.gl/stats';\nimport type {Timeline} from '@luma.gl/engine';\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nexport default class AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  id: string;\n  gl: WebGLRenderingContext;\n  attributes: Record<string, Attribute>;\n  updateTriggers: {[name: string]: string[]};\n  needsRedraw: string | boolean;\n  userData: any;\n\n  private stats?: Stats;\n  private attributeTransitionManager: AttributeTransitionManager;\n  private mergeBoundsMemoized: any = memoize(mergeBounds);\n\n  constructor(\n    gl: WebGLRenderingContext,\n    {\n      id = 'attribute-manager',\n      stats,\n      timeline\n    }: {\n      id?: string;\n      stats?: Stats;\n      timeline?: Timeline;\n    } = {}\n  ) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`,\n      timeline\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts: {clearRedrawFlags?: boolean} = {clearRedrawFlags: false}): string | false {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n\n  // Adds attributes\n  add(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes);\n  }\n\n  // Adds attributes\n  addInstanced(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray: string[]) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName: string, dataRange?: {startRow?: number; endRow?: number}) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange?: {startRow?: number; endRow?: number}) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  // eslint-disable-next-line complexity\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }: {\n    data: any;\n    numInstances: number;\n    startIndices?: NumericArray | null;\n    transitions: any;\n    props: any;\n    buffers: any;\n    context: any;\n  }) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (\n        attribute.setBinaryValue(\n          typeof accessorName === 'string' ? buffers[accessorName] : undefined,\n          data.startIndices\n        )\n      ) {\n        // Step 2: try set packed value from external typed array\n      } else if (\n        typeof accessorName === 'string' &&\n        !buffers[accessorName] &&\n        attribute.setConstantValue(props[accessorName])\n      ) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes(): {[id: string]: Attribute} {\n    return this.attributes;\n  }\n\n  /**\n   * Computes the spatial bounds of a given set of attributes\n   */\n  getBounds(attributeNames: string[]) {\n    const bounds = attributeNames.map(attributeName => this.attributes[attributeName]?.getBounds());\n    return this.mergeBoundsMemoized(bounds);\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts: {clearChangedFlags?: boolean} = {clearChangedFlags: false}): {\n    [id: string]: Attribute;\n  } {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = {...attributeTransitionManager.getAttributes()};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  // Returns shader attributes\n  getShaderAttributes(\n    attributes?: {[id: string]: Attribute},\n    excludeAttributes: Record<string, boolean> = {}\n  ): {[id: string]: IShaderAttribute} {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n    const shaderAttributes = {};\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n    return shaderAttributes;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  private _add(attributes: {[id: string]: AttributeOptions}, extraProps: any = {}) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  private _createAttribute(name: string, attribute: AttributeOptions, extraProps: any) {\n    // For expected default values see:\n    // https://github.com/visgl/luma.gl/blob/1affe21352e289eeaccee2a876865138858a765c/modules/webgl/src/classes/accessor.js#L5-L13\n    // and https://deck.gl/docs/api-reference/core/attribute-manager#add\n    const props: AttributeOptions = {\n      ...attribute,\n      id: name,\n      size: (attribute.isIndexed && 1) || attribute.size || 1,\n      divisor: extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n\n    return new Attribute(this.gl, props);\n  }\n\n  // build updateTrigger name to attribute name mapping\n  private _mapUpdateTriggersToAttributes() {\n    const triggers: {[name: string]: string[]} = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  private _invalidateTrigger(\n    triggerName: string,\n    dataRange?: {startRow?: number; endRow?: number}\n  ): string[] {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  private _updateAttribute(opts: {\n    attribute: Attribute;\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }) {\n    const {attribute, numInstances} = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      attribute.setConstantValue(attribute.value as NumericArray);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}