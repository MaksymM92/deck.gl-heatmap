{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, createIterable, log } from '@deck.gl/core';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport * as Polygon from '../solid-polygon-layer/polygon';\nimport { replaceInRange } from '../utils';\nconst defaultLineColor = [0, 0, 0, 255];\nconst defaultFillColor = [0, 0, 0, 255];\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  elevationScale: 1,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: defaultFillColor\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: defaultLineColor\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: true\n};\nexport default class PolygonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      paths: []\n    };\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n  updateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {\n      const paths = this.state.paths.slice();\n      const pathsDiff = changeFlags.dataChanged.map(dataRange => replaceInRange({\n        data: paths,\n        getIndex: p => p.__source.index,\n        dataRange,\n        replace: this._getPaths(dataRange)\n      }));\n      this.setState({\n        paths,\n        pathsDiff\n      });\n    } else if (geometryChanged) {\n      this.setState({\n        paths: this._getPaths(),\n        pathsDiff: null\n      });\n    }\n  }\n  _getPaths() {\n    let dataRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      data,\n      getPolygon,\n      positionFormat,\n      _normalize\n    } = this.props;\n    const paths = [];\n    const positionSize = positionFormat === 'XY' ? 2 : 3;\n    const {\n      startRow,\n      endRow\n    } = dataRange;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      let polygon = getPolygon(object, objectInfo);\n      if (_normalize) {\n        polygon = Polygon.normalize(polygon, positionSize);\n      }\n      const {\n        holeIndices\n      } = polygon;\n      const positions = polygon.positions || polygon;\n      if (holeIndices) {\n        for (let i = 0; i <= holeIndices.length; i++) {\n          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);\n          paths.push(this.getSubLayerRow({\n            path\n          }, object, objectInfo.index));\n        }\n      } else {\n        paths.push(this.getSubLayerRow({\n          path: positions\n        }, object, objectInfo.index));\n      }\n    }\n    return paths;\n  }\n  renderLayers() {\n    const {\n      data,\n      _dataDiff,\n      stroked,\n      filled,\n      extruded,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      elevationScale,\n      transitions,\n      positionFormat\n    } = this.props;\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      lineDashJustified\n    } = this.props;\n    const {\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      getPolygon,\n      updateTriggers,\n      material\n    } = this.props;\n    const {\n      paths,\n      pathsDiff\n    } = this.state;\n    const FillLayer = this.getSubLayerClass('fill', SolidPolygonLayer);\n    const StrokeLayer = this.getSubLayerClass('stroke', PathLayer);\n    const polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({\n      _dataDiff,\n      extruded,\n      elevationScale,\n      filled,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      getElevation,\n      getFillColor,\n      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,\n      material,\n      transitions\n    }, this.getSubLayerProps({\n      id: 'fill',\n      updateTriggers: updateTriggers && {\n        getPolygon: updateTriggers.getPolygon,\n        getElevation: updateTriggers.getElevation,\n        getFillColor: updateTriggers.getFillColor,\n        lineColors: extruded && wireframe,\n        getLineColor: updateTriggers.getLineColor\n      }\n    }), {\n      data,\n      positionFormat,\n      getPolygon\n    });\n    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({\n      _dataDiff: pathsDiff && (() => pathsDiff),\n      widthUnits: lineWidthUnits,\n      widthScale: lineWidthScale,\n      widthMinPixels: lineWidthMinPixels,\n      widthMaxPixels: lineWidthMaxPixels,\n      jointRounded: lineJointRounded,\n      miterLimit: lineMiterLimit,\n      dashJustified: lineDashJustified,\n      _pathType: 'loop',\n      transitions: transitions && {\n        getWidth: transitions.getLineWidth,\n        getColor: transitions.getLineColor,\n        getPath: transitions.getPolygon\n      },\n      getColor: this.getSubLayerAccessor(getLineColor),\n      getWidth: this.getSubLayerAccessor(getLineWidth),\n      getDashArray: this.getSubLayerAccessor(getLineDashArray)\n    }, this.getSubLayerProps({\n      id: 'stroke',\n      updateTriggers: updateTriggers && {\n        getWidth: updateTriggers.getLineWidth,\n        getColor: updateTriggers.getLineColor,\n        getDashArray: updateTriggers.getLineDashArray\n      }\n    }), {\n      data: paths,\n      positionFormat,\n      getPath: x => x.path\n    });\n    return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];\n  }\n}\n_defineProperty(PolygonLayer, \"layerName\", 'PolygonLayer');\n_defineProperty(PolygonLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["_defineProperty","CompositeLayer","createIterable","log","SolidPolygonLayer","PathLayer","Polygon","replaceInRange","defaultLineColor","defaultFillColor","defaultProps","stroked","filled","extruded","elevationScale","wireframe","_normalize","_windingOrder","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","Number","MAX_SAFE_INTEGER","lineJointRounded","lineMiterLimit","getPolygon","type","value","f","polygon","getFillColor","getLineColor","getLineWidth","getElevation","material","PolygonLayer","initializeState","state","paths","props","getLineDashArray","removed","updateState","_ref","changeFlags","geometryChanged","dataChanged","updateTriggersChanged","all","Array","isArray","slice","pathsDiff","map","dataRange","data","getIndex","p","__source","index","replace","_getPaths","setState","arguments","length","undefined","positionFormat","positionSize","startRow","endRow","iterable","objectInfo","object","normalize","holeIndices","positions","i","path","push","getSubLayerRow","renderLayers","_dataDiff","transitions","lineDashJustified","updateTriggers","FillLayer","getSubLayerClass","StrokeLayer","polygonLayer","shouldRenderSubLayer","getSubLayerProps","id","lineColors","polygonLineLayer","widthUnits","widthScale","widthMinPixels","widthMaxPixels","jointRounded","miterLimit","dashJustified","_pathType","getWidth","getColor","getPath","getSubLayerAccessor","getDashArray","x"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, createIterable, log } from '@deck.gl/core';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport * as Polygon from '../solid-polygon-layer/polygon';\nimport { replaceInRange } from '../utils';\nconst defaultLineColor = [0, 0, 0, 255];\nconst defaultFillColor = [0, 0, 0, 255];\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  elevationScale: 1,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: defaultFillColor\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: defaultLineColor\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: true\n};\nexport default class PolygonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      paths: []\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({\n    changeFlags\n  }) {\n    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {\n      const paths = this.state.paths.slice();\n      const pathsDiff = changeFlags.dataChanged.map(dataRange => replaceInRange({\n        data: paths,\n        getIndex: p => p.__source.index,\n        dataRange,\n        replace: this._getPaths(dataRange)\n      }));\n      this.setState({\n        paths,\n        pathsDiff\n      });\n    } else if (geometryChanged) {\n      this.setState({\n        paths: this._getPaths(),\n        pathsDiff: null\n      });\n    }\n  }\n\n  _getPaths(dataRange = {}) {\n    const {\n      data,\n      getPolygon,\n      positionFormat,\n      _normalize\n    } = this.props;\n    const paths = [];\n    const positionSize = positionFormat === 'XY' ? 2 : 3;\n    const {\n      startRow,\n      endRow\n    } = dataRange;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      let polygon = getPolygon(object, objectInfo);\n\n      if (_normalize) {\n        polygon = Polygon.normalize(polygon, positionSize);\n      }\n\n      const {\n        holeIndices\n      } = polygon;\n      const positions = polygon.positions || polygon;\n\n      if (holeIndices) {\n        for (let i = 0; i <= holeIndices.length; i++) {\n          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);\n          paths.push(this.getSubLayerRow({\n            path\n          }, object, objectInfo.index));\n        }\n      } else {\n        paths.push(this.getSubLayerRow({\n          path: positions\n        }, object, objectInfo.index));\n      }\n    }\n\n    return paths;\n  }\n\n  renderLayers() {\n    const {\n      data,\n      _dataDiff,\n      stroked,\n      filled,\n      extruded,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      elevationScale,\n      transitions,\n      positionFormat\n    } = this.props;\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      lineDashJustified\n    } = this.props;\n    const {\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      getPolygon,\n      updateTriggers,\n      material\n    } = this.props;\n    const {\n      paths,\n      pathsDiff\n    } = this.state;\n    const FillLayer = this.getSubLayerClass('fill', SolidPolygonLayer);\n    const StrokeLayer = this.getSubLayerClass('stroke', PathLayer);\n    const polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({\n      _dataDiff,\n      extruded,\n      elevationScale,\n      filled,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      getElevation,\n      getFillColor,\n      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,\n      material,\n      transitions\n    }, this.getSubLayerProps({\n      id: 'fill',\n      updateTriggers: updateTriggers && {\n        getPolygon: updateTriggers.getPolygon,\n        getElevation: updateTriggers.getElevation,\n        getFillColor: updateTriggers.getFillColor,\n        lineColors: extruded && wireframe,\n        getLineColor: updateTriggers.getLineColor\n      }\n    }), {\n      data,\n      positionFormat,\n      getPolygon\n    });\n    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({\n      _dataDiff: pathsDiff && (() => pathsDiff),\n      widthUnits: lineWidthUnits,\n      widthScale: lineWidthScale,\n      widthMinPixels: lineWidthMinPixels,\n      widthMaxPixels: lineWidthMaxPixels,\n      jointRounded: lineJointRounded,\n      miterLimit: lineMiterLimit,\n      dashJustified: lineDashJustified,\n      _pathType: 'loop',\n      transitions: transitions && {\n        getWidth: transitions.getLineWidth,\n        getColor: transitions.getLineColor,\n        getPath: transitions.getPolygon\n      },\n      getColor: this.getSubLayerAccessor(getLineColor),\n      getWidth: this.getSubLayerAccessor(getLineWidth),\n      getDashArray: this.getSubLayerAccessor(getLineDashArray)\n    }, this.getSubLayerProps({\n      id: 'stroke',\n      updateTriggers: updateTriggers && {\n        getWidth: updateTriggers.getLineWidth,\n        getColor: updateTriggers.getLineColor,\n        getDashArray: updateTriggers.getLineDashArray\n      }\n    }), {\n      data: paths,\n      positionFormat,\n      getPath: x => x.path\n    });\n    return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];\n  }\n\n}\n\n_defineProperty(PolygonLayer, \"layerName\", 'PolygonLayer');\n\n_defineProperty(PolygonLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=polygon-layer.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}