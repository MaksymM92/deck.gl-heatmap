{"ast":null,"code":"import { createIterable } from '@deck.gl/core';\nimport { getGridOffset } from '../utils/grid-aggregation-utils';\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {\n    data = [],\n    cellSize\n  } = props;\n  const {\n    attributes,\n    viewport,\n    projectPoints,\n    numInstances\n  } = aggregationParams;\n  const positions = attributes.positions.value;\n  const {\n    size\n  } = attributes.positions.getAccessor();\n  const boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {\n      gridHash: {},\n      gridOffset\n    };\n  }\n  const {\n    width,\n    height\n  } = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  const gridHash = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n  const position = new Array(3);\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n      if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {\n        const key = \"\".concat(yIndex, \"-\").concat(xIndex);\n        gridHash[key] = gridHash[key] || {\n          count: 0,\n          points: [],\n          lonIdx: xIndex,\n          latIdx: yIndex\n        };\n        gridHash[key].count += 1;\n        gridHash[key].points.push({\n          source: pt,\n          index: objectInfo.index\n        });\n      }\n    }\n  }\n  return {\n    gridHash,\n    gridOffset,\n    offsets: [offsets[0] * -1, offsets[1] * -1]\n  };\n}\nfunction getGridLayerDataFromGridHash(_ref) {\n  let {\n    gridHash,\n    gridOffset,\n    offsets\n  } = _ref;\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n    data[index] = {\n      index,\n      position: [offsets[0] + gridOffset.xOffset * lonIdx, offsets[1] + gridOffset.yOffset * latIdx],\n      ...gridHash[key]\n    };\n  }\n  return data;\n}\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  const positions = positionAttribute.value;\n  const {\n    size\n  } = positionAttribute.getAccessor();\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n  return {\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  };\n}","map":{"version":3,"names":["createIterable","getGridOffset","pointToDensityGridDataCPU","props","aggregationParams","hashInfo","pointsToGridHashing","result","getGridLayerDataFromGridHash","gridHash","gridOffset","data","cellSize","attributes","viewport","projectPoints","numInstances","positions","value","size","getAccessor","boundingBox","getPositionBoundingBox","offsets","posOffset","xOffset","yOffset","width","height","numCol","Math","ceil","numRow","iterable","objectInfo","position","Array","pt","index","x","y","project","Number","isFinite","yIndex","floor","xIndex","key","concat","count","points","lonIdx","latIdx","push","source","_ref","Object","keys","length","i","idxs","split","parseInt","positionAttribute","numInstance","yMin","Infinity","yMax","xMin","xMax"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/cpu-grid-layer/grid-aggregator.js"],"sourcesContent":["import { createIterable } from '@deck.gl/core';\nimport { getGridOffset } from '../utils/grid-aggregation-utils';\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {\n    data = [],\n    cellSize\n  } = props;\n  const {\n    attributes,\n    viewport,\n    projectPoints,\n    numInstances\n  } = aggregationParams;\n  const positions = attributes.positions.value;\n  const {\n    size\n  } = attributes.positions.getAccessor();\n  const boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {\n      gridHash: {},\n      gridOffset\n    };\n  }\n\n  const {\n    width,\n    height\n  } = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  const gridHash = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n  const position = new Array(3);\n\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n\n      if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {\n        const key = \"\".concat(yIndex, \"-\").concat(xIndex);\n        gridHash[key] = gridHash[key] || {\n          count: 0,\n          points: [],\n          lonIdx: xIndex,\n          latIdx: yIndex\n        };\n        gridHash[key].count += 1;\n        gridHash[key].points.push({\n          source: pt,\n          index: objectInfo.index\n        });\n      }\n    }\n  }\n\n  return {\n    gridHash,\n    gridOffset,\n    offsets: [offsets[0] * -1, offsets[1] * -1]\n  };\n}\n\nfunction getGridLayerDataFromGridHash({\n  gridHash,\n  gridOffset,\n  offsets\n}) {\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n    data[index] = {\n      index,\n      position: [offsets[0] + gridOffset.xOffset * lonIdx, offsets[1] + gridOffset.yOffset * latIdx],\n      ...gridHash[key]\n    };\n  }\n\n  return data;\n}\n\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  const positions = positionAttribute.value;\n  const {\n    size\n  } = positionAttribute.getAccessor();\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  };\n}\n//# sourceMappingURL=grid-aggregator.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}