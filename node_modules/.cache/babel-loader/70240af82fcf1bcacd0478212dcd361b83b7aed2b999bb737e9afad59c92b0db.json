{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport BinSorter from './utils/bin-sorter';\nimport { pointToDensityGridDataCPU } from './cpu-grid-layer/grid-aggregator';\nexport default class GridAggregationLayer extends AggregationLayer {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", void 0);\n  }\n  initializeAggregationLayer(_ref) {\n    let {\n      dimensions\n    } = _ref;\n    const {\n      gl\n    } = this.context;\n    super.initializeAggregationLayer(dimensions);\n    this.setState({\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {\n        id: \"\".concat(this.id, \"-gpu-aggregator\")\n      }),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n  updateState(opts) {\n    super.updateState(opts);\n    this.updateAggregationState(opts);\n    const {\n      aggregationDataDirty,\n      aggregationWeightsDirty,\n      gpuAggregation\n    } = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n    this.setState({\n      aggregationDirty\n    });\n  }\n  finalizeState(context) {\n    var _this$state$gpuGridAg;\n    const {\n      count\n    } = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    (_this$state$gpuGridAg = this.state.gpuGridAggregator) === null || _this$state$gpuGridAg === void 0 ? void 0 : _this$state$gpuGridAg.delete();\n    super.finalizeState(context);\n  }\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n  updateAggregationState(opts) {\n    log.assert(false);\n  }\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {\n        weights\n      } = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: 5126,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n  updateResults(_ref2) {\n    let {\n      aggregationData,\n      maxMinData,\n      maxData,\n      minData\n    } = _ref2;\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      props\n    } = opts;\n    const {\n      viewport\n    } = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {\n        weights\n      } = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n  _updateWeightBins() {\n    const {\n      getValue\n    } = this.state;\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue\n    });\n    this.setState({\n      sortedBins\n    });\n  }\n  _uploadAggregationResults() {\n    const {\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      data\n    } = this.state.layerData;\n    const {\n      aggregatedBins,\n      minValue,\n      maxValue,\n      totalCount\n    } = this.state.sortedBins;\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {\n        lonIdx,\n        latIdx\n      } = data[bin.i];\n      const {\n        value,\n        counts\n      } = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({\n      aggregationData,\n      maxMinData,\n      maxData,\n      minData\n    });\n  }\n}\n_defineProperty(GridAggregationLayer, \"layerName\", 'GridAggregationLayer');","map":{"version":3,"names":["_defineProperty","AggregationLayer","GPUGridAggregator","Buffer","log","BinSorter","pointToDensityGridDataCPU","GridAggregationLayer","constructor","arguments","initializeAggregationLayer","_ref","dimensions","gl","context","setState","layerData","gpuGridAggregator","id","concat","cpuGridAggregator","updateState","opts","updateAggregationState","aggregationDataDirty","aggregationWeightsDirty","gpuAggregation","state","getNumInstances","aggregationDirty","_updateAggregation","_updateWeightBins","_uploadAggregationResults","finalizeState","_this$state$gpuGridAg","count","weights","aggregationBuffer","delete","updateShaders","shaders","assert","allocateResources","numRow","numCol","dataBytes","name","weight","byteLength","accessor","size","type","divisor","updateResults","_ref2","aggregationData","maxMinData","maxData","minData","gridOffset","posOffset","translation","scaling","boundingBox","projectPoints","props","viewport","attributes","getAttributes","vertexCount","result","run","cellSize","xOffset","yOffset","moduleSettings","getModuleSettings","getValue","sortedBins","data","aggregatedBins","minValue","maxValue","totalCount","ELEMENTCOUNT","aggregationSize","Float32Array","fill","bin","lonIdx","latIdx","i","value","counts","cellIndex"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/grid-aggregation-layer.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport BinSorter from './utils/bin-sorter';\nimport { pointToDensityGridDataCPU } from './cpu-grid-layer/grid-aggregator';\nexport default class GridAggregationLayer extends AggregationLayer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  initializeAggregationLayer({\n    dimensions\n  }) {\n    const {\n      gl\n    } = this.context;\n    super.initializeAggregationLayer(dimensions);\n    this.setState({\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {\n        id: \"\".concat(this.id, \"-gpu-aggregator\")\n      }),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    this.updateAggregationState(opts);\n    const {\n      aggregationDataDirty,\n      aggregationWeightsDirty,\n      gpuAggregation\n    } = this.state;\n\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n\n    let aggregationDirty = false;\n\n    if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {\n      this._updateAggregation(opts);\n\n      aggregationDirty = true;\n    }\n\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n\n      this._uploadAggregationResults();\n\n      aggregationDirty = true;\n    }\n\n    this.setState({\n      aggregationDirty\n    });\n  }\n\n  finalizeState(context) {\n    var _this$state$gpuGridAg;\n\n    const {\n      count\n    } = this.state.weights;\n\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n\n    (_this$state$gpuGridAg = this.state.gpuGridAggregator) === null || _this$state$gpuGridAg === void 0 ? void 0 : _this$state$gpuGridAg.delete();\n    super.finalizeState(context);\n  }\n\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  updateAggregationState(opts) {\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {\n        weights\n      } = this.state;\n\n      for (const name in weights) {\n        const weight = weights[name];\n\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: 5126,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({\n    aggregationData,\n    maxMinData,\n    maxData,\n    minData\n  }) {\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      props\n    } = opts;\n    const {\n      viewport\n    } = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {\n        weights\n      } = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {\n      getValue\n    } = this.state;\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue\n    });\n    this.setState({\n      sortedBins\n    });\n  }\n\n  _uploadAggregationResults() {\n    const {\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      data\n    } = this.state.layerData;\n    const {\n      aggregatedBins,\n      minValue,\n      maxValue,\n      totalCount\n    } = this.state.sortedBins;\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n\n    for (const bin of aggregatedBins) {\n      const {\n        lonIdx,\n        latIdx\n      } = data[bin.i];\n      const {\n        value,\n        counts\n      } = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({\n      aggregationData,\n      maxMinData,\n      maxData,\n      minData\n    });\n  }\n\n}\n\n_defineProperty(GridAggregationLayer, \"layerName\", 'GridAggregationLayer');\n//# sourceMappingURL=grid-aggregation-layer.js.map"],"mappings":"AAAA,OAAOA,eAAe,MAAM,2CAA2C;AACvE,OAAOC,gBAAgB,MAAM,qBAAqB;AAClD,OAAOC,iBAAiB,MAAM,kDAAkD;AAChF,SAASC,MAAM,QAAQ,eAAe;AACtC,SAASC,GAAG,QAAQ,eAAe;AACnC,OAAOC,SAAS,MAAM,oBAAoB;AAC1C,SAASC,yBAAyB,QAAQ,kCAAkC;AAC5E,eAAe,MAAMC,oBAAoB,SAASN,gBAAgB,CAAC;EACjEO,WAAWA,CAAA,EAAU;IACnB,KAAK,CAAC,GAAAC,SAAO,CAAC;IAEdT,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;EACxC;EAEAU,0BAA0BA,CAAAC,IAAA,EAEvB;IAAA,IAFwB;MACzBC;IACF,CAAC,GAAAD,IAAA;IACC,MAAM;MACJE;IACF,CAAC,GAAG,IAAI,CAACC,OAAO;IAChB,KAAK,CAACJ,0BAA0B,CAACE,UAAU,CAAC;IAC5C,IAAI,CAACG,QAAQ,CAAC;MACZC,SAAS,EAAE,CAAC,CAAC;MACbC,iBAAiB,EAAE,IAAIf,iBAAiB,CAACW,EAAE,EAAE;QAC3CK,EAAE,EAAE,EAAE,CAACC,MAAM,CAAC,IAAI,CAACD,EAAE,EAAE,iBAAiB;MAC1C,CAAC,CAAC;MACFE,iBAAiB,EAAEd;IACrB,CAAC,CAAC;EACJ;EAEAe,WAAWA,CAACC,IAAI,EAAE;IAChB,KAAK,CAACD,WAAW,CAACC,IAAI,CAAC;IACvB,IAAI,CAACC,sBAAsB,CAACD,IAAI,CAAC;IACjC,MAAM;MACJE,oBAAoB;MACpBC,uBAAuB;MACvBC;IACF,CAAC,GAAG,IAAI,CAACC,KAAK;IAEd,IAAI,IAAI,CAACC,eAAe,EAAE,IAAI,CAAC,EAAE;MAC/B;IACF;IAEA,IAAIC,gBAAgB,GAAG,KAAK;IAE5B,IAAIL,oBAAoB,IAAIE,cAAc,IAAID,uBAAuB,EAAE;MACrE,IAAI,CAACK,kBAAkB,CAACR,IAAI,CAAC;MAE7BO,gBAAgB,GAAG,IAAI;IACzB;IAEA,IAAI,CAACH,cAAc,KAAKF,oBAAoB,IAAIC,uBAAuB,CAAC,EAAE;MACxE,IAAI,CAACM,iBAAiB,EAAE;MAExB,IAAI,CAACC,yBAAyB,EAAE;MAEhCH,gBAAgB,GAAG,IAAI;IACzB;IAEA,IAAI,CAACd,QAAQ,CAAC;MACZc;IACF,CAAC,CAAC;EACJ;EAEAI,aAAaA,CAACnB,OAAO,EAAE;IACrB,IAAIoB,qBAAqB;IAEzB,MAAM;MACJC;IACF,CAAC,GAAG,IAAI,CAACR,KAAK,CAACS,OAAO;IAEtB,IAAID,KAAK,IAAIA,KAAK,CAACE,iBAAiB,EAAE;MACpCF,KAAK,CAACE,iBAAiB,CAACC,MAAM,EAAE;IAClC;IAEA,CAACJ,qBAAqB,GAAG,IAAI,CAACP,KAAK,CAACV,iBAAiB,MAAM,IAAI,IAAIiB,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAACI,MAAM,EAAE;IAC7I,KAAK,CAACL,aAAa,CAACnB,OAAO,CAAC;EAC9B;EAEAyB,aAAaA,CAACC,OAAO,EAAE;IACrB,IAAI,IAAI,CAACb,KAAK,CAACD,cAAc,EAAE;MAC7B,IAAI,CAACC,KAAK,CAACV,iBAAiB,CAACsB,aAAa,CAACC,OAAO,CAAC;IACrD;EACF;EAEAjB,sBAAsBA,CAACD,IAAI,EAAE;IAC3BlB,GAAG,CAACqC,MAAM,CAAC,KAAK,CAAC;EACnB;EAEAC,iBAAiBA,CAACC,MAAM,EAAEC,MAAM,EAAE;IAChC,IAAI,IAAI,CAACjB,KAAK,CAACgB,MAAM,KAAKA,MAAM,IAAI,IAAI,CAAChB,KAAK,CAACiB,MAAM,KAAKA,MAAM,EAAE;MAChE,MAAMC,SAAS,GAAGD,MAAM,GAAGD,MAAM,GAAG,CAAC,GAAG,CAAC;MACzC,MAAM9B,EAAE,GAAG,IAAI,CAACC,OAAO,CAACD,EAAE;MAC1B,MAAM;QACJuB;MACF,CAAC,GAAG,IAAI,CAACT,KAAK;MAEd,KAAK,MAAMmB,IAAI,IAAIV,OAAO,EAAE;QAC1B,MAAMW,MAAM,GAAGX,OAAO,CAACU,IAAI,CAAC;QAE5B,IAAIC,MAAM,CAACV,iBAAiB,EAAE;UAC5BU,MAAM,CAACV,iBAAiB,CAACC,MAAM,EAAE;QACnC;QAEAS,MAAM,CAACV,iBAAiB,GAAG,IAAIlC,MAAM,CAACU,EAAE,EAAE;UACxCmC,UAAU,EAAEH,SAAS;UACrBI,QAAQ,EAAE;YACRC,IAAI,EAAE,CAAC;YACPC,IAAI,EAAE,IAAI;YACVC,OAAO,EAAE;UACX;QACF,CAAC,CAAC;MACJ;IACF;EACF;EAEAC,aAAaA,CAAAC,KAAA,EAKV;IAAA,IALW;MACZC,eAAe;MACfC,UAAU;MACVC,OAAO;MACPC;IACF,CAAC,GAAAJ,KAAA;IACC,MAAM;MACJnB;IACF,CAAC,GAAG,IAAI,CAACR,KAAK,CAACS,OAAO;IAEtB,IAAID,KAAK,EAAE;MACTA,KAAK,CAACoB,eAAe,GAAGA,eAAe;MACvCpB,KAAK,CAACqB,UAAU,GAAGA,UAAU;MAC7BrB,KAAK,CAACsB,OAAO,GAAGA,OAAO;MACvBtB,KAAK,CAACuB,OAAO,GAAGA,OAAO;IACzB;EACF;EAEA5B,kBAAkBA,CAACR,IAAI,EAAE;IACvB,MAAM;MACJF,iBAAiB;MACjBH,iBAAiB;MACjB0C,UAAU;MACVC,SAAS;MACTC,WAAW,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;MACpBC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACnBC,WAAW;MACXC,aAAa;MACbtC,cAAc;MACdkB,MAAM;MACND;IACF,CAAC,GAAG,IAAI,CAAChB,KAAK;IACd,MAAM;MACJsC;IACF,CAAC,GAAG3C,IAAI;IACR,MAAM;MACJ4C;IACF,CAAC,GAAG,IAAI,CAACpD,OAAO;IAChB,MAAMqD,UAAU,GAAG,IAAI,CAACC,aAAa,EAAE;IACvC,MAAMC,WAAW,GAAG,IAAI,CAACzC,eAAe,EAAE;IAE1C,IAAI,CAACF,cAAc,EAAE;MACnB,MAAM4C,MAAM,GAAGlD,iBAAiB,CAAC6C,KAAK,EAAE;QACtCN,UAAU;QACVK,aAAa;QACbG,UAAU;QACVD,QAAQ;QACRN,SAAS;QACTG;MACF,CAAC,CAAC;MACF,IAAI,CAAChD,QAAQ,CAAC;QACZC,SAAS,EAAEsD;MACb,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,MAAM;QACJlC;MACF,CAAC,GAAG,IAAI,CAACT,KAAK;MACdV,iBAAiB,CAACsD,GAAG,CAAC;QACpBnC,OAAO;QACPoC,QAAQ,EAAE,CAACb,UAAU,CAACc,OAAO,EAAEd,UAAU,CAACe,OAAO,CAAC;QAClD9B,MAAM;QACND,MAAM;QACNkB,WAAW;QACXC,OAAO;QACPO,WAAW;QACXL,aAAa;QACbG,UAAU;QACVQ,cAAc,EAAE,IAAI,CAACC,iBAAiB;MACxC,CAAC,CAAC;IACJ;EACF;EAEA7C,iBAAiBA,CAAA,EAAG;IAClB,MAAM;MACJ8C;IACF,CAAC,GAAG,IAAI,CAAClD,KAAK;IACd,MAAMmD,UAAU,GAAG,IAAIzE,SAAS,CAAC,IAAI,CAACsB,KAAK,CAACX,SAAS,CAAC+D,IAAI,IAAI,EAAE,EAAE;MAChEF;IACF,CAAC,CAAC;IACF,IAAI,CAAC9D,QAAQ,CAAC;MACZ+D;IACF,CAAC,CAAC;EACJ;EAEA9C,yBAAyBA,CAAA,EAAG;IAC1B,MAAM;MACJY,MAAM;MACND;IACF,CAAC,GAAG,IAAI,CAAChB,KAAK;IACd,MAAM;MACJoD;IACF,CAAC,GAAG,IAAI,CAACpD,KAAK,CAACX,SAAS;IACxB,MAAM;MACJgE,cAAc;MACdC,QAAQ;MACRC,QAAQ;MACRC;IACF,CAAC,GAAG,IAAI,CAACxD,KAAK,CAACmD,UAAU;IACzB,MAAMM,YAAY,GAAG,CAAC;IACtB,MAAMC,eAAe,GAAGzC,MAAM,GAAGD,MAAM,GAAGyC,YAAY;IACtD,MAAM7B,eAAe,GAAG,IAAI+B,YAAY,CAACD,eAAe,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC;IAEjE,KAAK,MAAMC,GAAG,IAAIR,cAAc,EAAE;MAChC,MAAM;QACJS,MAAM;QACNC;MACF,CAAC,GAAGX,IAAI,CAACS,GAAG,CAACG,CAAC,CAAC;MACf,MAAM;QACJC,KAAK;QACLC;MACF,CAAC,GAAGL,GAAG;MACP,MAAMM,SAAS,GAAG,CAACL,MAAM,GAAGC,MAAM,GAAG9C,MAAM,IAAIwC,YAAY;MAC3D7B,eAAe,CAACuC,SAAS,CAAC,GAAGF,KAAK;MAClCrC,eAAe,CAACuC,SAAS,GAAGV,YAAY,GAAG,CAAC,CAAC,GAAGS,MAAM;IACxD;IAEA,MAAMrC,UAAU,GAAG,IAAI8B,YAAY,CAAC,CAACJ,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAED,QAAQ,CAAC,CAAC;IAC/D,MAAMxB,OAAO,GAAG,IAAI6B,YAAY,CAAC,CAACJ,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAEC,UAAU,CAAC,CAAC;IAC9D,MAAMzB,OAAO,GAAG,IAAI4B,YAAY,CAAC,CAACL,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAEE,UAAU,CAAC,CAAC;IAC9D,IAAI,CAAC9B,aAAa,CAAC;MACjBE,eAAe;MACfC,UAAU;MACVC,OAAO;MACPC;IACF,CAAC,CAAC;EACJ;AAEF;AAEA1D,eAAe,CAACO,oBAAoB,EAAE,WAAW,EAAE,sBAAsB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}