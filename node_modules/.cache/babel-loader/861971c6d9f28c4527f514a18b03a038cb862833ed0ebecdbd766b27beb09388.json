{"ast":null,"code":"import lightingShader from './lights.glsl';\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\nfunction convertColor() {\n  let {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return color.map(component => component * intensity / 255.0);\n}\nfunction getLightSourceUniforms(_ref) {\n  let {\n    ambientLight,\n    pointLights = [],\n    directionalLights = []\n  } = _ref;\n  const lightSourceUniforms = {};\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n      }\n    }\n    return getUniforms({\n      lightSources\n    });\n  }\n  return {};\n}\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};","map":{"version":3,"names":["lightingShader","INITIAL_MODULE_OPTIONS","lightSources","convertColor","color","intensity","arguments","length","undefined","map","component","getLightSourceUniforms","_ref","ambientLight","pointLights","directionalLights","lightSourceUniforms","forEach","pointLight","index","concat","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","getUniforms","opts","hasLights","lighting_uEnabled","Object","assign","light","lights","type","push","name","vs","fs","defines","MAX_LIGHTS"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@luma.gl/shadertools/src/modules/lights/lights.js"],"sourcesContent":["/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport lightingShader from './lights.glsl';\n\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1,\n      0,\n      0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(\n      directionalLight\n    );\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {pointLights: [], directionalLights: []};\n    // @ts-ignore\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/** @type {ShaderModule} */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}