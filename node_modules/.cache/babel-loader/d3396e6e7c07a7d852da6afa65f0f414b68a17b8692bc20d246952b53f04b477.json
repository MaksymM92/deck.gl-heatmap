{"ast":null,"code":"export function cssToDeviceRatio(gl) {\n  const {\n    luma\n  } = gl;\n  if (gl.canvas && luma) {\n    const {\n      clientWidth\n    } = luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n  return 1;\n}\nexport function cssToDevicePixels(gl, cssPixel) {\n  let yInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  if (Number.isFinite(useDevicePixels)) {\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n  return useDevicePixels ? windowRatio : 1;\n}\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  const xHigh = t === width - 1 ? t : t - 1;\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    t = t === 0 ? t : t + 1;\n    yHigh = y;\n    y = t;\n  } else {\n    yHigh = t === height - 1 ? t : t - 1;\n  }\n  return {\n    x,\n    y,\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\nfunction scaleX(x, ratio, width) {\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\nfunction scaleY(y, ratio, height, yInvert) {\n  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);\n}","map":{"version":3,"names":["cssToDeviceRatio","gl","luma","canvas","clientWidth","canvasSizeInfo","drawingBufferWidth","cssToDevicePixels","cssPixel","yInvert","arguments","length","undefined","ratio","width","height","drawingBufferHeight","scalePixels","getDevicePixelRatio","useDevicePixels","windowRatio","window","devicePixelRatio","Number","isFinite","pixel","x","scaleX","y","scaleY","t","xHigh","yHigh","Math","max","r","min","round"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@luma.gl/gltools/src/utils/device-pixels.js"],"sourcesContent":["/** @typedef {import('./device-pixels')} types */\n\n/**\n * Returns multiplier need to convert CSS size to Device size\n * @type {types['cssToDeviceRatio']}\n */\nexport function cssToDeviceRatio(gl) {\n  // @ts-ignore\n  const {luma} = gl;\n\n  if (gl.canvas && luma) {\n    // For headless gl we might have used custom width and height\n    // hence use cached clientWidth\n    const {clientWidth} = luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n  // use default device pixel ratio\n  return 1;\n}\n\n/**\n * Maps CSS pixel position to device pixel position\n * @type {types['cssToDevicePixels']}\n */\nexport function cssToDevicePixels(gl, cssPixel, yInvert = true) {\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\n\n// HELPER METHOD\n\n/**\n * Calulates device pixel ratio, used during context creation\n * @type {types['getDevicePixelRatio']}\n */\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  if (Number.isFinite(useDevicePixels)) {\n    // @ts-ignore Can no longer be boolean after previous line\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n  return useDevicePixels ? windowRatio : 1;\n}\n\n// PRIVATE\n\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locaitons\n\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x, ratio, width) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y, ratio, height, yInvert) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}