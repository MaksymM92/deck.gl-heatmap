{"ast":null,"code":"import { isWebGL2 } from '@luma.gl/core';\nexport function getBounds(points) {\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n  return [xMin, yMin, xMax, yMax];\n}\nexport function boundsContain(currentBounds, targetBounds) {\n  if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {\n    return true;\n  }\n  return false;\n}\nconst scratchArray = new Float32Array(12);\nexport function packVertices(points) {\n  let dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\nexport function scaleToAspectRatio(boundingBox, width, height) {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    newWidth = width / height * currentHeight;\n  } else {\n    newHeight = height / width * currentWidth;\n  }\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n  return [xCenter - newWidth / 2, yCenter - newHeight / 2, xCenter + newWidth / 2, yCenter + newHeight / 2];\n}\nexport function getTextureCoordinates(point, bounds) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\nexport function getTextureParams(_ref) {\n  let {\n    gl,\n    floatTargetSupport\n  } = _ref;\n  return floatTargetSupport ? {\n    format: isWebGL2(gl) ? 34836 : 6408,\n    type: 5126\n  } : {\n    format: 6408,\n    type: 5121\n  };\n}","map":{"version":3,"names":["isWebGL2","getBounds","points","x","map","p","y","xMin","Math","min","apply","xMax","max","yMin","yMax","boundsContain","currentBounds","targetBounds","scratchArray","Float32Array","packVertices","dimensions","arguments","length","undefined","index","point","i","scaleToAspectRatio","boundingBox","width","height","currentWidth","currentHeight","newWidth","newHeight","xCenter","yCenter","getTextureCoordinates","bounds","getTextureParams","_ref","gl","floatTargetSupport","format","type"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/heatmap-layer/heatmap-layer-utils.js"],"sourcesContent":["import { isWebGL2 } from '@luma.gl/core';\nexport function getBounds(points) {\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n  return [xMin, yMin, xMax, yMax];\n}\nexport function boundsContain(currentBounds, targetBounds) {\n  if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {\n    return true;\n  }\n\n  return false;\n}\nconst scratchArray = new Float32Array(12);\nexport function packVertices(points, dimensions = 2) {\n  let index = 0;\n\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n\n  return scratchArray;\n}\nexport function scaleToAspectRatio(boundingBox, width, height) {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n\n  if (currentWidth / currentHeight < width / height) {\n    newWidth = width / height * currentHeight;\n  } else {\n    newHeight = height / width * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n  return [xCenter - newWidth / 2, yCenter - newHeight / 2, xCenter + newWidth / 2, yCenter + newHeight / 2];\n}\nexport function getTextureCoordinates(point, bounds) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\nexport function getTextureParams({\n  gl,\n  floatTargetSupport\n}) {\n  return floatTargetSupport ? {\n    format: isWebGL2(gl) ? 34836 : 6408,\n    type: 5126\n  } : {\n    format: 6408,\n    type: 5121\n  };\n}\n//# sourceMappingURL=heatmap-layer-utils.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}