{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Framebuffer, Texture2D, isWebGL2, readPixelsToArray, cssToDeviceRatio, cssToDevicePixels } from '@luma.gl/core';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport { getClosestObject, getUniqueObjects } from './picking/query-object';\nimport { processPickInfo, getLayerPickingInfo, getEmptyPickingInfo } from './picking/pick-info';\nexport default class DeckPicker {\n  constructor(gl) {\n    _defineProperty(this, \"gl\", void 0);\n    _defineProperty(this, \"pickingFBO\", void 0);\n    _defineProperty(this, \"depthFBO\", void 0);\n    _defineProperty(this, \"pickLayersPass\", void 0);\n    _defineProperty(this, \"layerFilter\", void 0);\n    _defineProperty(this, \"lastPickedInfo\", void 0);\n    _defineProperty(this, \"_pickable\", true);\n    this.gl = gl;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n  getLastPickedObject(_ref) {\n    let {\n      x,\n      y,\n      layers,\n      viewports\n    } = _ref;\n    let lastPickedInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lastPickedInfo.info;\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n    return {\n      ...lastPickedInfo,\n      ...info\n    };\n  }\n  _resizeBuffer() {\n    var _this$pickingFBO, _this$depthFBO;\n    const {\n      gl\n    } = this;\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n      if (Framebuffer.isSupported(gl, {\n        colorBufferFloat: true\n      })) {\n        const depthFBO = new Framebuffer(gl);\n        depthFBO.attach({\n          [36064]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? 34836 : 6408,\n            type: 5126\n          })\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n    (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({\n      width: gl.canvas.width,\n      height: gl.canvas.height\n    });\n    (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({\n      width: gl.canvas.width,\n      height: gl.canvas.height\n    });\n  }\n  _getPickable(layers) {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n  _pickClosestObject(_ref2) {\n    let {\n      layers,\n      views,\n      viewports,\n      x,\n      y,\n      radius = 0,\n      depth = 1,\n      mode = 'query',\n      unproject3D,\n      onViewportActive,\n      effects\n    } = _ref2;\n    const pickableLayers = this._getPickable(layers);\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    if (!pickableLayers) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({\n          viewports,\n          x,\n          y,\n          pixelRatio\n        })\n      };\n    }\n    this._resizeBuffer();\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {\n      width,\n      height\n    } = this.pickingFBO;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n    const cullRect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n    let infos;\n    const result = [];\n    const affectedLayers = new Set();\n    for (let i = 0; i < depth; i++) {\n      let pickInfo;\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: \"picking:\".concat(mode)\n        });\n        pickInfo = getClosestObject({\n          ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const {\n          pickedColors: pickedColors2\n        } = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect: {\n            x: pickInfo.pickedX,\n            y: pickInfo.pickedY,\n            width: 1,\n            height: 1\n          },\n          cullRect,\n          effects,\n          pass: \"picking:\".concat(mode, \":z\")\n        }, true);\n        if (pickedColors2[3]) {\n          z = pickedColors2[0];\n        }\n      }\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n    return {\n      result,\n      emptyInfo: infos.get(null)\n    };\n  }\n  _pickVisibleObjects(_ref3) {\n    let {\n      layers,\n      views,\n      viewports,\n      x,\n      y,\n      width = 1,\n      height = 1,\n      mode = 'query',\n      maxObjects = null,\n      onViewportActive,\n      effects\n    } = _ref3;\n    const pickableLayers = this._getPickable(layers);\n    if (!pickableLayers) {\n      return [];\n    }\n    this._resizeBuffer();\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {\n        x,\n        y,\n        width,\n        height\n      },\n      effects,\n      pass: \"picking:\".concat(mode)\n    });\n    const pickInfos = getUniqueObjects(pickedResult);\n    const uniqueInfos = new Map();\n    const isMaxObjects = Number.isFinite(maxObjects);\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n      info = getLayerPickingInfo({\n        layer: pickInfo.pickedLayer,\n        info,\n        mode\n      });\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n    return Array.from(uniqueInfos.values());\n  }\n  _drawAndSample(_ref4) {\n    let {\n      layers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect,\n      effects,\n      pass\n    } = _ref4;\n    let pickZ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n    const opts = {\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ,\n      preRenderStats: {}\n    };\n    for (const effect of effects) {\n      if (effect.useInPicking) {\n        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);\n      }\n    }\n    const {\n      decodePickingColor\n    } = this.pickLayersPass.render(opts);\n    const {\n      x,\n      y,\n      width,\n      height\n    } = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n    return {\n      pickedColors,\n      decodePickingColor\n    };\n  }\n  _getPickingRect(_ref5) {\n    let {\n      deviceX,\n      deviceY,\n      deviceRadius,\n      deviceWidth,\n      deviceHeight\n    } = _ref5;\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n}","map":{"version":3,"names":["Framebuffer","Texture2D","isWebGL2","readPixelsToArray","cssToDeviceRatio","cssToDevicePixels","PickLayersPass","getClosestObject","getUniqueObjects","processPickInfo","getLayerPickingInfo","getEmptyPickingInfo","DeckPicker","constructor","gl","_defineProperty","pickLayersPass","lastPickedInfo","index","layerId","info","setProps","props","layerFilter","_pickable","finalize","pickingFBO","delete","depthFBO","color","pickObject","opts","_pickClosestObject","pickObjects","_pickVisibleObjects","getLastPickedObject","_ref","x","y","layers","viewports","arguments","length","undefined","lastPickedLayerId","layer","id","lastPickedViewportId","viewport","find","l","v","coordinate","unproject","_resizeBuffer","_this$pickingFBO","_this$depthFBO","isSupported","colorBufferFloat","attach","format","type","resize","width","canvas","height","_getPickable","pickableLayers","filter","shouldDrawLayer","isComposite","_ref2","views","radius","depth","mode","unproject3D","onViewportActive","effects","pixelRatio","result","emptyInfo","devicePixelRange","devicePixel","Math","floor","deviceRadius","round","deviceRect","_getPickingRect","deviceX","deviceY","deviceWidth","deviceHeight","cullRect","infos","affectedLayers","Set","i","pickInfo","pickedResult","_drawAndSample","pass","concat","pickedColor","pickedObjectIndex","z","pickedLayer","pickedColors","pickedColors2","pickedX","pickedY","add","disablePickingIndex","values","push","restorePickingColors","get","_ref3","maxObjects","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","uniqueInfos","Map","isMaxObjects","Number","isFinite","size","picked","has","object","set","Array","from","_ref4","pickZ","preRenderStats","effect","useInPicking","preRender","decodePickingColor","render","Float32Array","Uint8Array","sourceX","sourceY","sourceWidth","sourceHeight","target","_ref5","max","min"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/lib/deck-picker.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Framebuffer,\n  Texture2D,\n  isWebGL2,\n  readPixelsToArray,\n  cssToDeviceRatio,\n  cssToDevicePixels\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport PickLayersPass, {PickingColorDecoder} from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects, PickedPixel} from './picking/query-object';\nimport {\n  processPickInfo,\n  getLayerPickingInfo,\n  getEmptyPickingInfo,\n  PickingInfo\n} from './picking/pick-info';\n\nimport type {Framebuffer as LumaFramebuffer} from '@luma.gl/webgl';\nimport type {FilterContext, Rect} from '../passes/layers-pass';\nimport type Layer from './layer';\nimport type {Effect} from './effect';\nimport type View from '../views/view';\nimport type Viewport from '../viewports/viewport';\n\nexport type PickByPointOptions = {\n  x: number;\n  y: number;\n  radius?: number;\n  depth?: number;\n  mode?: string;\n  unproject3D?: boolean;\n};\n\nexport type PickByRectOptions = {\n  x: number;\n  y: number;\n  width?: number;\n  height?: number;\n  mode?: string;\n  maxObjects?: number | null;\n};\n\ntype PickOperationContext = {\n  layers: Layer[];\n  views: Record<string, View>;\n  viewports: Viewport[];\n  onViewportActive: (viewport: Viewport) => void;\n  effects: Effect[];\n};\n\n/** Manages picking in a Deck context */\nexport default class DeckPicker {\n  gl: WebGLRenderingContext;\n  pickingFBO?: LumaFramebuffer;\n  depthFBO?: LumaFramebuffer;\n  pickLayersPass: PickLayersPass;\n  layerFilter?: (context: FilterContext) => boolean;\n\n  /** Identifiers of the previously picked object, for callback tracking and auto highlight */\n  lastPickedInfo: {\n    index: number;\n    layerId: string | null;\n    info: PickingInfo | null;\n  };\n\n  _pickable: boolean = true;\n\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props: any): void {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  /** Pick the closest info at given coordinate */\n  pickObject(opts: PickByPointOptions & PickOperationContext) {\n    return this._pickClosestObject(opts);\n  }\n\n  /** Get all unique infos within a bounding box */\n  pickObjects(opts: PickByRectOptions & PickOperationContext) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId =\n      lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport =\n      (lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId)) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n\n    return {...lastPickedInfo, ...info};\n  }\n\n  // Private\n\n  /** Ensures that picking framebuffer exists and matches the canvas size */\n  _resizeBuffer() {\n    const {gl} = this;\n\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n\n      if (Framebuffer.isSupported(gl, {colorBufferFloat: true})) {\n        const depthFBO = new Framebuffer(gl);\n        depthFBO.attach({\n          [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n            type: GL.FLOAT\n          })\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO?.resize({width: gl.canvas.width, height: gl.canvas.height});\n    this.depthFBO?.resize({width: gl.canvas.width, height: gl.canvas.height});\n  }\n\n  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */\n  _getPickable(layers: Layer[]): Layer[] | null {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(\n      layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite\n    );\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  /** Pick the closest object at the given coordinate */\n  // eslint-disable-next-line max-statements,complexity\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }: PickByPointOptions & PickOperationContext): {\n    result: PickingInfo[];\n    emptyInfo: PickingInfo;\n  } {\n    const pickableLayers = this._getPickable(layers);\n    const pixelRatio = cssToDeviceRatio(this.gl);\n\n    if (!pickableLayers) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({viewports, x, y, pixelRatio})\n      };\n    }\n\n    this._resizeBuffer();\n\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO as LumaFramebuffer;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    const cullRect: Rect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n\n    let infos: Map<string | null, PickingInfo>;\n    const result: PickingInfo[] = [];\n    const affectedLayers = new Set<Layer>();\n\n    for (let i = 0; i < depth; i++) {\n      let pickInfo: PickedPixel;\n\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: `picking:${mode}`\n        });\n\n        pickInfo = getClosestObject({\n          ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const {pickedColors: pickedColors2} = this._drawAndSample(\n          {\n            layers: [pickInfo.pickedLayer],\n            views,\n            viewports,\n            onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX as number,\n              y: pickInfo.pickedY as number,\n              width: 1,\n              height: 1\n            },\n            cullRect,\n            effects,\n            pass: `picking:${mode}:z`\n          },\n          true\n        );\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        if (pickedColors2[3]) {\n          z = pickedColors2[0];\n        }\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos!.get(null) as PickingInfo};\n  }\n\n  /** Pick all objects within the given bounding box */\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }: PickByRectOptions & PickOperationContext): PickingInfo[] {\n    const pickableLayers = this._getPickable(layers);\n\n    if (!pickableLayers) {\n      return [];\n    }\n\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {x, y, width, height},\n      effects,\n      pass: `picking:${mode}`\n    });\n\n    const pickInfos = getUniqueObjects(pickedResult);\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    const isMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info: PickingInfo = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer as Layer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  /** Renders layers into the picking buffer with picking colors and read the pixels. */\n  _drawAndSample(params: {\n    deviceRect: Rect;\n    pass: string;\n    layers: Layer[];\n    views: Record<string, View>;\n    viewports: Viewport[];\n    onViewportActive: (viewport: Viewport) => void;\n    cullRect?: Rect;\n    effects: Effect[];\n  }): {\n    pickedColors: Uint8Array;\n    decodePickingColor: PickingColorDecoder;\n  };\n\n  /** Renders layers into the picking buffer with encoded z values and read the pixels. */\n  _drawAndSample(\n    params: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: true\n  ): {\n    pickedColors: Float32Array;\n    decodePickingColor: null;\n  };\n\n  _drawAndSample(\n    {\n      layers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect,\n      effects,\n      pass\n    }: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: boolean = false\n  ): {\n    pickedColors: Uint8Array | Float32Array;\n    decodePickingColor: PickingColorDecoder | null;\n  } {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n    const opts = {\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ,\n      preRenderStats: {}\n    };\n\n    for (const effect of effects) {\n      if (effect.useInPicking) {\n        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);\n      }\n    }\n\n    const {decodePickingColor} = this.pickLayersPass.render(opts);\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return {pickedColors, decodePickingColor};\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }: {\n    deviceX: number;\n    deviceY: number;\n    deviceRadius: number;\n    deviceWidth: number;\n    deviceHeight: number;\n  }): Rect | null {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"],"mappings":";AAoBA,SACEA,WADF,EAEEC,SAFF,EAGEC,QAHF,EAIEC,iBAJF,EAKEC,gBALF,EAMEC,iBANF,QAOO,eAPP;AASA,OAAOC,cAAP,MAAkD,4BAAlD;AACA,SAAQC,gBAAR,EAA0BC,gBAA1B,QAA8D,wBAA9D;AACA,SACEC,eADF,EAEEC,mBAFF,EAGEC,mBAHF,QAKO,qBALP;AAyCA,eAAe,MAAMC,UAAN,CAAiB;EAgB9BC,WAAWA,CAACC,EAAD,EAA4B;IAAAC,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA,oBAFlB,IAEkB;IACrC,KAAKD,EAAL,GAAUA,EAAV;IACA,KAAKE,cAAL,GAAsB,IAAIV,cAAJ,CAAmBQ,EAAnB,CAAtB;IACA,KAAKG,cAAL,GAAsB;MACpBC,KAAK,EAAE,CAAC,CADY;MAEpBC,OAAO,EAAE,IAFW;MAGpBC,IAAI,EAAE;IAHc,CAAtB;EAKD;EAEDC,QAAQA,CAACC,KAAD,EAAmB;IACzB,IAAI,iBAAiBA,KAArB,EAA4B;MAC1B,KAAKC,WAAL,GAAmBD,KAAK,CAACC,WAAzB;IACD;IAED,IAAI,eAAeD,KAAnB,EAA0B;MACxB,KAAKE,SAAL,GAAiBF,KAAK,CAACE,SAAvB;IACD;EACF;EAEDC,QAAQA,CAAA,EAAG;IACT,IAAI,KAAKC,UAAT,EAAqB;MACnB,KAAKA,UAAL,CAAgBC,MAAhB;IACD;IACD,IAAI,KAAKC,QAAT,EAAmB;MACjB,KAAKA,QAAL,CAAcC,KAAd,CAAoBF,MAApB;MACA,KAAKC,QAAL,CAAcD,MAAd;IACD;EACF;EAGDG,UAAUA,CAACC,IAAD,EAAkD;IAC1D,OAAO,KAAKC,kBAAL,CAAwBD,IAAxB,CAAP;EACD;EAGDE,WAAWA,CAACF,IAAD,EAAiD;IAC1D,OAAO,KAAKG,mBAAL,CAAyBH,IAAzB,CAAP;EACD;EAGDI,mBAAmBA,CAAAC,IAAA,EAAuE;IAAA,IAAtE;MAACC,CAAD;MAAIC,CAAJ;MAAOC,MAAP;MAAeC;IAAf,CAAD,GAAAJ,IAAA;IAAA,IAA4BnB,cAAc,GAAAwB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAKxB,cAAL,CAAoBG,IAAjE;IACjB,MAAMwB,iBAAiB,GAAG3B,cAAc,IAAIA,cAAc,CAAC4B,KAAjC,IAA0C5B,cAAc,CAAC4B,KAAf,CAAqBC,EAAzF;IACA,MAAMC,oBAAoB,GACxB9B,cAAc,IAAIA,cAAc,CAAC+B,QAAjC,IAA6C/B,cAAc,CAAC+B,QAAf,CAAwBF,EADvE;IAEA,MAAMD,KAAK,GAAGD,iBAAiB,GAAGL,MAAM,CAACU,IAAP,CAAYC,CAAC,IAAIA,CAAC,CAACJ,EAAF,KAASF,iBAA1B,CAAH,GAAkD,IAAjF;IACA,MAAMI,QAAQ,GACXD,oBAAoB,IAAIP,SAAS,CAACS,IAAV,CAAeE,CAAC,IAAIA,CAAC,CAACL,EAAF,KAASC,oBAA7B,CAAzB,IAAgFP,SAAS,CAAC,CAAD,CAD3F;IAEA,MAAMY,UAAU,GAAGJ,QAAQ,IAAIA,QAAQ,CAACK,SAAT,CAAmB,CAAChB,CAAC,GAAGW,QAAQ,CAACX,CAAd,EAAiBC,CAAC,GAAGU,QAAQ,CAACV,CAA9B,CAAnB,CAA/B;IAEA,MAAMlB,IAAI,GAAG;MACXiB,CADW;MAEXC,CAFW;MAGXU,QAHW;MAIXI,UAJW;MAKXP;IALW,CAAb;IAQA,OAAO;MAAC,GAAG5B,cAAJ;MAAoB,GAAGG;IAAvB,CAAP;EACD;EAKDkC,aAAaA,CAAA,EAAG;IAAA,IAAAC,gBAAA,EAAAC,cAAA;IACd,MAAM;MAAC1C;IAAD,IAAO,IAAb;IAGA,IAAI,CAAC,KAAKY,UAAV,EAAsB;MACpB,KAAKA,UAAL,GAAkB,IAAI1B,WAAJ,CAAgBc,EAAhB,CAAlB;MAEA,IAAId,WAAW,CAACyD,WAAZ,CAAwB3C,EAAxB,EAA4B;QAAC4C,gBAAgB,EAAE;MAAnB,CAA5B,CAAJ,EAA2D;QACzD,MAAM9B,QAAQ,GAAG,IAAI5B,WAAJ,CAAgBc,EAAhB,CAAjB;QACAc,QAAQ,CAAC+B,MAAT,CAAgB;UACd,SAAwB,IAAI1D,SAAJ,CAAca,EAAd,EAAkB;YACxC8C,MAAM,EAAE1D,QAAQ,CAACY,EAAD,CAAR,eADgC;YAExC+C,IAAI;UAFoC,CAAlB;QADV,CAAhB;QAMA,KAAKjC,QAAL,GAAgBA,QAAhB;MACD;IACF;IAED,CAAA2B,gBAAA,QAAK7B,UAAL,cAAA6B,gBAAA,uBAAAA,gBAAA,CAAiBO,MAAjB,CAAwB;MAACC,KAAK,EAAEjD,EAAE,CAACkD,MAAH,CAAUD,KAAlB;MAAyBE,MAAM,EAAEnD,EAAE,CAACkD,MAAH,CAAUC;IAA3C,CAAxB;IACA,CAAAT,cAAA,QAAK5B,QAAL,cAAA4B,cAAA,uBAAAA,cAAA,CAAeM,MAAf,CAAsB;MAACC,KAAK,EAAEjD,EAAE,CAACkD,MAAH,CAAUD,KAAlB;MAAyBE,MAAM,EAAEnD,EAAE,CAACkD,MAAH,CAAUC;IAA3C,CAAtB;EACD;EAGDC,YAAYA,CAAC3B,MAAD,EAAkC;IAC5C,IAAI,KAAKf,SAAL,KAAmB,KAAvB,EAA8B;MAC5B,OAAO,IAAP;IACD;IACD,MAAM2C,cAAc,GAAG5B,MAAM,CAAC6B,MAAP,CACrBvB,KAAK,IAAI,KAAK7B,cAAL,CAAoBqD,eAApB,CAAoCxB,KAApC,KAA8C,CAACA,KAAK,CAACyB,WADzC,CAAvB;IAGA,OAAOH,cAAc,CAACzB,MAAf,GAAwByB,cAAxB,GAAyC,IAAhD;EACD;EAIDnC,kBAAkBA,CAAAuC,KAAA,EAehB;IAAA,IAfiB;MACjBhC,MADiB;MAEjBiC,KAFiB;MAGjBhC,SAHiB;MAIjBH,CAJiB;MAKjBC,CALiB;MAMjBmC,MAAM,GAAG,CANQ;MAOjBC,KAAK,GAAG,CAPS;MAQjBC,IAAI,GAAG,OARU;MASjBC,WATiB;MAUjBC,gBAViB;MAWjBC;IAXiB,CAAD,GAAAP,KAAA;IAgBhB,MAAMJ,cAAc,GAAG,KAAKD,YAAL,CAAkB3B,MAAlB,CAAvB;IACA,MAAMwC,UAAU,GAAG3E,gBAAgB,CAAC,KAAKU,EAAN,CAAnC;IAEA,IAAI,CAACqD,cAAL,EAAqB;MACnB,OAAO;QACLa,MAAM,EAAE,EADH;QAELC,SAAS,EAAEtE,mBAAmB,CAAC;UAAC6B,SAAD;UAAYH,CAAZ;UAAeC,CAAf;UAAkByC;QAAlB,CAAD;MAFzB,CAAP;IAID;IAED,KAAKzB,aAAL;IAKA,MAAM4B,gBAAgB,GAAG7E,iBAAiB,CAAC,KAAKS,EAAN,EAAU,CAACuB,CAAD,EAAIC,CAAJ,CAAV,EAAkB,IAAlB,CAA1C;IACA,MAAM6C,WAAW,GAAG,CAClBD,gBAAgB,CAAC7C,CAAjB,GAAqB+C,IAAI,CAACC,KAAL,CAAWH,gBAAgB,CAACnB,KAAjB,GAAyB,CAApC,CADH,EAElBmB,gBAAgB,CAAC5C,CAAjB,GAAqB8C,IAAI,CAACC,KAAL,CAAWH,gBAAgB,CAACjB,MAAjB,GAA0B,CAArC,CAFH,CAApB;IAKA,MAAMqB,YAAY,GAAGF,IAAI,CAACG,KAAL,CAAWd,MAAM,GAAGM,UAApB,CAArB;IACA,MAAM;MAAChB,KAAD;MAAQE;IAAR,IAAkB,KAAKvC,UAA7B;IACA,MAAM8D,UAAU,GAAG,KAAKC,eAAL,CAAqB;MACtCC,OAAO,EAAEP,WAAW,CAAC,CAAD,CADkB;MAEtCQ,OAAO,EAAER,WAAW,CAAC,CAAD,CAFkB;MAGtCG,YAHsC;MAItCM,WAAW,EAAE7B,KAJyB;MAKtC8B,YAAY,EAAE5B;IALwB,CAArB,CAAnB;IAQA,MAAM6B,QAAc,GAAG;MACrBzD,CAAC,EAAEA,CAAC,GAAGoC,MADc;MAErBnC,CAAC,EAAEA,CAAC,GAAGmC,MAFc;MAGrBV,KAAK,EAAEU,MAAM,GAAG,CAAT,GAAa,CAHC;MAIrBR,MAAM,EAAEQ,MAAM,GAAG,CAAT,GAAa;IAJA,CAAvB;IAOA,IAAIsB,KAAJ;IACA,MAAMf,MAAqB,GAAG,EAA9B;IACA,MAAMgB,cAAc,GAAG,IAAIC,GAAJ,EAAvB;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,KAApB,EAA2BwB,CAAC,EAA5B,EAAgC;MAC9B,IAAIC,QAAJ;MAEA,IAAIX,UAAJ,EAAgB;QACd,MAAMY,YAAY,GAAG,KAAKC,cAAL,CAAoB;UACvC9D,MAAM,EAAE4B,cAD+B;UAEvCK,KAFuC;UAGvChC,SAHuC;UAIvCqC,gBAJuC;UAKvCW,UALuC;UAMvCM,QANuC;UAOvChB,OAPuC;UAQvCwB,IAAI,aAAAC,MAAA,CAAa5B,IAAb;QARmC,CAApB,CAArB;QAWAwB,QAAQ,GAAG5F,gBAAgB,CAAC;UAC1B,GAAG6F,YADuB;UAE1BV,OAAO,EAAEP,WAAW,CAAC,CAAD,CAFM;UAG1BQ,OAAO,EAAER,WAAW,CAAC,CAAD,CAHM;UAI1BG,YAJ0B;UAK1BE;QAL0B,CAAD,CAA3B;MAOD,CAnBD,MAmBO;QACLW,QAAQ,GAAG;UACTK,WAAW,EAAE,IADJ;UAETC,iBAAiB,EAAE,CAAC;QAFX,CAAX;MAID;MAED,IAAIC,CAAJ;MACA,IAAIP,QAAQ,CAACQ,WAAT,IAAwB/B,WAAxB,IAAuC,KAAKhD,QAAhD,EAA0D;QACxD,MAAM;UAACgF,YAAY,EAAEC;QAAf,IAAgC,KAAKR,cAAL,CACpC;UACE9D,MAAM,EAAE,CAAC4D,QAAQ,CAACQ,WAAV,CADV;UAEEnC,KAFF;UAGEhC,SAHF;UAIEqC,gBAJF;UAKEW,UAAU,EAAE;YACVnD,CAAC,EAAE8D,QAAQ,CAACW,OADF;YAEVxE,CAAC,EAAE6D,QAAQ,CAACY,OAFF;YAGVhD,KAAK,EAAE,CAHG;YAIVE,MAAM,EAAE;UAJE,CALd;UAWE6B,QAXF;UAYEhB,OAZF;UAaEwB,IAAI,aAAAC,MAAA,CAAa5B,IAAb;QAbN,CADoC,EAgBpC,IAhBoC,CAAtC;QAoBA,IAAIkC,aAAa,CAAC,CAAD,CAAjB,EAAsB;UACpBH,CAAC,GAAGG,aAAa,CAAC,CAAD,CAAjB;QACD;MACF;MAKD,IAAIV,QAAQ,CAACQ,WAAT,IAAwBT,CAAC,GAAG,CAAJ,GAAQxB,KAApC,EAA2C;QACzCsB,cAAc,CAACgB,GAAf,CAAmBb,QAAQ,CAACQ,WAA5B;QACAR,QAAQ,CAACQ,WAAT,CAAqBM,mBAArB,CAAyCd,QAAQ,CAACM,iBAAlD;MACD;MAGDV,KAAK,GAAGtF,eAAe,CAAC;QACtB0F,QADsB;QAEtBlF,cAAc,EAAE,KAAKA,cAFC;QAGtB0D,IAHsB;QAItBpC,MAAM,EAAE4B,cAJc;QAKtB3B,SALsB;QAMtBH,CANsB;QAOtBC,CAPsB;QAQtBoE,CARsB;QAStB3B;MATsB,CAAD,CAAvB;MAYA,KAAK,MAAM3D,IAAX,IAAmB2E,KAAK,CAACmB,MAAN,EAAnB,EAAmC;QACjC,IAAI9F,IAAI,CAACyB,KAAT,EAAgB;UACdmC,MAAM,CAACmC,IAAP,CAAY/F,IAAZ;QACD;MACF;MAGD,IAAI,CAAC+E,QAAQ,CAACK,WAAd,EAA2B;QACzB;MACD;IACF;IAGD,KAAK,MAAM3D,KAAX,IAAoBmD,cAApB,EAAoC;MAClCnD,KAAK,CAACuE,oBAAN;IACD;IAED,OAAO;MAACpC,MAAD;MAASC,SAAS,EAAEc,KAAK,CAAEsB,GAAP,CAAW,IAAX;IAApB,CAAP;EACD;EAGDnF,mBAAmBA,CAAAoF,KAAA,EAYyC;IAAA,IAZxC;MAClB/E,MADkB;MAElBiC,KAFkB;MAGlBhC,SAHkB;MAIlBH,CAJkB;MAKlBC,CALkB;MAMlByB,KAAK,GAAG,CANU;MAOlBE,MAAM,GAAG,CAPS;MAQlBU,IAAI,GAAG,OARW;MASlB4C,UAAU,GAAG,IATK;MAUlB1C,gBAVkB;MAWlBC;IAXkB,CAAD,GAAAwC,KAAA;IAajB,MAAMnD,cAAc,GAAG,KAAKD,YAAL,CAAkB3B,MAAlB,CAAvB;IAEA,IAAI,CAAC4B,cAAL,EAAqB;MACnB,OAAO,EAAP;IACD;IAED,KAAKb,aAAL;IAGA,MAAMyB,UAAU,GAAG3E,gBAAgB,CAAC,KAAKU,EAAN,CAAnC;IACA,MAAM0G,OAAO,GAAGnH,iBAAiB,CAAC,KAAKS,EAAN,EAAU,CAACuB,CAAD,EAAIC,CAAJ,CAAV,EAAkB,IAAlB,CAAjC;IAGA,MAAMmF,UAAU,GAAGD,OAAO,CAACnF,CAA3B;IACA,MAAMqF,SAAS,GAAGF,OAAO,CAAClF,CAAR,GAAYkF,OAAO,CAACvD,MAAtC;IAGA,MAAM0D,WAAW,GAAGtH,iBAAiB,CAAC,KAAKS,EAAN,EAAU,CAACuB,CAAC,GAAG0B,KAAL,EAAYzB,CAAC,GAAG2B,MAAhB,CAAV,EAAmC,IAAnC,CAArC;IACA,MAAM2D,WAAW,GAAGD,WAAW,CAACtF,CAAZ,GAAgBsF,WAAW,CAAC5D,KAAhD;IACA,MAAM8D,YAAY,GAAGF,WAAW,CAACrF,CAAjC;IAEA,MAAMkD,UAAU,GAAG;MACjBnD,CAAC,EAAEoF,UADc;MAEjBnF,CAAC,EAAEuF,YAFc;MAIjB9D,KAAK,EAAE6D,WAAW,GAAGH,UAJJ;MAKjBxD,MAAM,EAAEyD,SAAS,GAAGG;IALH,CAAnB;IAQA,MAAMzB,YAAY,GAAG,KAAKC,cAAL,CAAoB;MACvC9D,MAAM,EAAE4B,cAD+B;MAEvCK,KAFuC;MAGvChC,SAHuC;MAIvCqC,gBAJuC;MAKvCW,UALuC;MAMvCM,QAAQ,EAAE;QAACzD,CAAD;QAAIC,CAAJ;QAAOyB,KAAP;QAAcE;MAAd,CAN6B;MAOvCa,OAPuC;MAQvCwB,IAAI,aAAAC,MAAA,CAAa5B,IAAb;IARmC,CAApB,CAArB;IAWA,MAAMmD,SAAS,GAAGtH,gBAAgB,CAAC4F,YAAD,CAAlC;IAGA,MAAM2B,WAAW,GAAG,IAAIC,GAAJ,EAApB;IAEA,MAAMC,YAAY,GAAGC,MAAM,CAACC,QAAP,CAAgBZ,UAAhB,CAArB;IAEA,KAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4B,SAAS,CAACpF,MAA9B,EAAsCwD,CAAC,EAAvC,EAA2C;MACzC,IAAI+B,YAAY,IAAIV,UAAhB,IAA8BQ,WAAW,CAACK,IAAZ,IAAoBb,UAAtD,EAAkE;QAChE;MACD;MACD,MAAMpB,QAAQ,GAAG2B,SAAS,CAAC5B,CAAD,CAA1B;MACA,IAAI9E,IAAiB,GAAG;QACtBS,KAAK,EAAEsE,QAAQ,CAACK,WADM;QAEtB3D,KAAK,EAAE,IAFe;QAGtB3B,KAAK,EAAEiF,QAAQ,CAACM,iBAHM;QAItB4B,MAAM,EAAE,IAJc;QAKtBhG,CALsB;QAMtBC,CANsB;QAOtByC;MAPsB,CAAxB;MAUA3D,IAAI,GAAGV,mBAAmB,CAAC;QAACmC,KAAK,EAAEsD,QAAQ,CAACQ,WAAjB;QAAuCvF,IAAvC;QAA6CuD;MAA7C,CAAD,CAA1B;MACA,IAAI,CAACoD,WAAW,CAACO,GAAZ,CAAgBlH,IAAI,CAACmH,MAArB,CAAL,EAAmC;QACjCR,WAAW,CAACS,GAAZ,CAAgBpH,IAAI,CAACmH,MAArB,EAA6BnH,IAA7B;MACD;IACF;IAED,OAAOqH,KAAK,CAACC,IAAN,CAAWX,WAAW,CAACb,MAAZ,EAAX,CAAP;EACD;EAmCDb,cAAcA,CAAAsC,KAAA,EAwBZ;IAAA,IAvBA;MACEpG,MADF;MAEEiC,KAFF;MAGEhC,SAHF;MAIEqC,gBAJF;MAKEW,UALF;MAMEM,QANF;MAOEhB,OAPF;MAQEwB;IARF,CADY,GAAAqC,KAAA;IAAA,IAoBZC,KAAc,GAAAnG,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KApBL;IAyBZ,MAAMf,UAAU,GAAGkH,KAAK,GAAG,KAAKhH,QAAR,GAAmB,KAAKF,UAAhD;IACA,MAAMK,IAAI,GAAG;MACXQ,MADW;MAEXhB,WAAW,EAAE,KAAKA,WAFP;MAGXiD,KAHW;MAIXhC,SAJW;MAKXqC,gBALW;MAMXnD,UANW;MAOX8D,UAPW;MAQXM,QARW;MASXhB,OATW;MAUXwB,IAVW;MAWXsC,KAXW;MAYXC,cAAc,EAAE;IAZL,CAAb;IAeA,KAAK,MAAMC,MAAX,IAAqBhE,OAArB,EAA8B;MAC5B,IAAIgE,MAAM,CAACC,YAAX,EAAyB;QACvBhH,IAAI,CAAC8G,cAAL,CAAoBC,MAAM,CAAChG,EAA3B,IAAiCgG,MAAM,CAACE,SAAP,CAAiB,KAAKlI,EAAtB,EAA0BiB,IAA1B,CAAjC;MACD;IACF;IAED,MAAM;MAACkH;IAAD,IAAuB,KAAKjI,cAAL,CAAoBkI,MAApB,CAA2BnH,IAA3B,CAA7B;IAIA,MAAM;MAACM,CAAD;MAAIC,CAAJ;MAAOyB,KAAP;MAAcE;IAAd,IAAwBuB,UAA9B;IACA,MAAMoB,YAAY,GAAG,KAAKgC,KAAK,GAAGO,YAAH,GAAkBC,UAA5B,EAAwCrF,KAAK,GAAGE,MAAR,GAAiB,CAAzD,CAArB;IACA9D,iBAAiB,CAACuB,UAAD,EAAa;MAC5B2H,OAAO,EAAEhH,CADmB;MAE5BiH,OAAO,EAAEhH,CAFmB;MAG5BiH,WAAW,EAAExF,KAHe;MAI5ByF,YAAY,EAAEvF,MAJc;MAK5BwF,MAAM,EAAE7C;IALoB,CAAb,CAAjB;IAQA,OAAO;MAACA,YAAD;MAAeqC;IAAf,CAAP;EACD;EAIDxD,eAAeA,CAAAiE,KAAA,EAYC;IAAA,IAZA;MACdhE,OADc;MAEdC,OAFc;MAGdL,YAHc;MAIdM,WAJc;MAKdC;IALc,CAAD,GAAA6D,KAAA;IAcb,MAAMrH,CAAC,GAAG+C,IAAI,CAACuE,GAAL,CAAS,CAAT,EAAYjE,OAAO,GAAGJ,YAAtB,CAAV;IACA,MAAMhD,CAAC,GAAG8C,IAAI,CAACuE,GAAL,CAAS,CAAT,EAAYhE,OAAO,GAAGL,YAAtB,CAAV;IACA,MAAMvB,KAAK,GAAGqB,IAAI,CAACwE,GAAL,CAAShE,WAAT,EAAsBF,OAAO,GAAGJ,YAAV,GAAyB,CAA/C,IAAoDjD,CAAlE;IACA,MAAM4B,MAAM,GAAGmB,IAAI,CAACwE,GAAL,CAAS/D,YAAT,EAAuBF,OAAO,GAAGL,YAAV,GAAyB,CAAhD,IAAqDhD,CAApE;IAGA,IAAIyB,KAAK,IAAI,CAAT,IAAcE,MAAM,IAAI,CAA5B,EAA+B;MAC7B,OAAO,IAAP;IACD;IAED,OAAO;MAAC5B,CAAD;MAAIC,CAAJ;MAAOyB,KAAP;MAAcE;IAAd,CAAP;EACD;AAhe6B"},"metadata":{},"sourceType":"module","externalDependencies":[]}