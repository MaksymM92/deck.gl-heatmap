{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport BinSorter from './utils/bin-sorter';\nimport { pointToDensityGridDataCPU } from './cpu-grid-layer/grid-aggregator';\nexport default class GridAggregationLayer extends AggregationLayer {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", void 0);\n  }\n  initializeAggregationLayer(_ref) {\n    let {\n      dimensions\n    } = _ref;\n    const {\n      gl\n    } = this.context;\n    super.initializeAggregationLayer(dimensions);\n    this.setState({\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {\n        id: \"\".concat(this.id, \"-gpu-aggregator\")\n      }),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n  updateState(opts) {\n    super.updateState(opts);\n    this.updateAggregationState(opts);\n    const {\n      aggregationDataDirty,\n      aggregationWeightsDirty,\n      gpuAggregation\n    } = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n    this.setState({\n      aggregationDirty\n    });\n  }\n  finalizeState(context) {\n    var _this$state$gpuGridAg;\n    const {\n      count\n    } = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    (_this$state$gpuGridAg = this.state.gpuGridAggregator) === null || _this$state$gpuGridAg === void 0 ? void 0 : _this$state$gpuGridAg.delete();\n    super.finalizeState(context);\n  }\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n  updateAggregationState(opts) {\n    log.assert(false);\n  }\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {\n        weights\n      } = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: 5126,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n  updateResults(_ref2) {\n    let {\n      aggregationData,\n      maxMinData,\n      maxData,\n      minData\n    } = _ref2;\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      props\n    } = opts;\n    const {\n      viewport\n    } = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {\n        weights\n      } = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n  _updateWeightBins() {\n    const {\n      getValue\n    } = this.state;\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue\n    });\n    this.setState({\n      sortedBins\n    });\n  }\n  _uploadAggregationResults() {\n    const {\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      data\n    } = this.state.layerData;\n    const {\n      aggregatedBins,\n      minValue,\n      maxValue,\n      totalCount\n    } = this.state.sortedBins;\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {\n        lonIdx,\n        latIdx\n      } = data[bin.i];\n      const {\n        value,\n        counts\n      } = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({\n      aggregationData,\n      maxMinData,\n      maxData,\n      minData\n    });\n  }\n}\n_defineProperty(GridAggregationLayer, \"layerName\", 'GridAggregationLayer');","map":{"version":3,"names":["AggregationLayer","GPUGridAggregator","Buffer","log","BinSorter","pointToDensityGridDataCPU","GridAggregationLayer","constructor","arguments","_defineProperty","initializeAggregationLayer","_ref","dimensions","gl","context","setState","layerData","gpuGridAggregator","id","concat","cpuGridAggregator","updateState","opts","updateAggregationState","aggregationDataDirty","aggregationWeightsDirty","gpuAggregation","state","getNumInstances","aggregationDirty","_updateAggregation","_updateWeightBins","_uploadAggregationResults","finalizeState","_this$state$gpuGridAg","count","weights","aggregationBuffer","delete","updateShaders","shaders","assert","allocateResources","numRow","numCol","dataBytes","name","weight","byteLength","accessor","size","type","divisor","updateResults","_ref2","aggregationData","maxMinData","maxData","minData","gridOffset","posOffset","translation","scaling","boundingBox","projectPoints","props","viewport","attributes","getAttributes","vertexCount","result","run","cellSize","xOffset","yOffset","moduleSettings","getModuleSettings","getValue","sortedBins","data","aggregatedBins","minValue","maxValue","totalCount","ELEMENTCOUNT","aggregationSize","Float32Array","fill","bin","lonIdx","latIdx","i","value","counts","cellIndex"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/src/grid-aggregation-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer, {AggregationLayerProps} from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {LayerContext, log, UpdateParameters} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport type GridAggregationLayerProps<DataT> = AggregationLayerProps<DataT>;\n\nexport default abstract class GridAggregationLayer<\n  DataT,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT> {\n  static layerName = 'GridAggregationLayer';\n\n  state!: AggregationLayer<DataT>['state'] & {\n    aggregationDataDirty?: any;\n    aggregationWeightsDirty?: any;\n    gpuAggregation?: any;\n    getValue?: () => any;\n    sortedBins?: BinSorter;\n  };\n\n  initializeAggregationLayer({dimensions}) {\n    const {gl} = this.context;\n    super.initializeAggregationLayer(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState(context: LayerContext) {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    this.state.gpuGridAggregator?.delete();\n    super.finalizeState(context);\n  }\n\n  updateShaders(shaders: any): void {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults(): void {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins!;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}