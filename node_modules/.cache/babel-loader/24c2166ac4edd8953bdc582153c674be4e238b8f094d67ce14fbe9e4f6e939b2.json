{"ast":null,"code":"import { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nconst REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\nexport default class GPUGridAggregator {\n  static getAggregationData(_ref) {\n    let {\n      aggregationData,\n      maxData,\n      minData,\n      maxMinData,\n      pixelIndex\n    } = _ref;\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n  static getCellData(_ref2) {\n    let {\n      countsData,\n      size = 1\n    } = _ref2;\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {\n      cellCounts,\n      cellWeights\n    };\n  }\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n  delete() {\n    const {\n      gridAggregationModel,\n      allAggregationModel,\n      meanTransform\n    } = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n    gridAggregationModel === null || gridAggregationModel === void 0 ? void 0 : gridAggregationModel.delete();\n    allAggregationModel === null || allAggregationModel === void 0 ? void 0 : allAggregationModel.delete();\n    meanTransform === null || meanTransform === void 0 ? void 0 : meanTransform.delete();\n    deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n  }\n  run() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.setState({\n      results: {}\n    });\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n  updateShaders() {\n    let shaderOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.setState({\n      shaderOptions,\n      modelDirty: true\n    });\n  }\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {\n      ...DEFAULT_RUN_PARAMS,\n      ...opts\n    };\n    const {\n      weights\n    } = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    for (const id in weights) {\n      results[id] = {};\n      const {\n        needMin,\n        needMax,\n        combineMaxMin\n      } = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer,\n        sourceType: 5126\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer,\n          sourceType: 5126\n        });\n        results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer,\n            sourceType: 5126\n          });\n          results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer,\n            sourceType: 5126\n          });\n          results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [1, 1]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax\n      } = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {\n            ...parameters,\n            blendEquation: MAX_MIN_BLEND_EQUATION\n          },\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {\n            clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n          },\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {\n              ...parameters,\n              blendEquation: MIN_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {\n              clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n            },\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {\n              ...parameters,\n              blendEquation: MAX_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, 0]\n            },\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n  _renderToMaxMinTexture(opts) {\n    const {\n      id,\n      parameters,\n      gridSize,\n      minOrMaxFb,\n      combineMaxMin,\n      clearParams = {}\n    } = opts;\n    const {\n      framebuffers\n    } = this.state;\n    const {\n      gl,\n      allAggregationModel\n    } = this;\n    withParameters(gl, {\n      ...clearParams,\n      framebuffer: minOrMaxFb,\n      viewport: [0, 0, gridSize[0], gridSize[1]]\n    }, () => {\n      gl.clear(16384);\n      allAggregationModel.draw({\n        parameters,\n        uniforms: {\n          uSampler: framebuffers[id].texture,\n          gridSize,\n          combineMaxMin\n        }\n      });\n    });\n  }\n  _renderToWeightsTexture(opts) {\n    const {\n      id,\n      parameters,\n      moduleSettings,\n      uniforms,\n      gridSize,\n      weights\n    } = opts;\n    const {\n      framebuffers,\n      equations,\n      weightAttributes\n    } = this.state;\n    const {\n      gl,\n      gridAggregationModel\n    } = this;\n    const {\n      operation\n    } = weights[id];\n    const clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n    withParameters(gl, {\n      framebuffer: framebuffers[id],\n      viewport: [0, 0, gridSize[0], gridSize[1]],\n      clearColor\n    }, () => {\n      gl.clear(16384);\n      const attributes = {\n        weights: weightAttributes[id]\n      };\n      gridAggregationModel.draw({\n        parameters: {\n          ...parameters,\n          blendEquation: equations[id]\n        },\n        moduleSettings,\n        uniforms,\n        attributes\n      });\n    });\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {\n        meanTextures,\n        textures\n      } = this.state;\n      const transformOptions = {\n        _sourceTextures: {\n          aggregationValues: meanTextures[id]\n        },\n        _targetTexture: textures[id],\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n      framebuffers[id].attach({\n        [36064]: textures[id]\n      });\n    }\n  }\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({\n      results\n    });\n    return results;\n  }\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    const {\n      numCol,\n      numRow\n    } = opts;\n    const framebufferSize = {\n      width: numCol,\n      height: numRow\n    };\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax,\n        combineMaxMin,\n        operation\n      } = weights[id];\n      textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n        id: \"\".concat(id, \"-texture\"),\n        width: numCol,\n        height: numRow\n      });\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-mean-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({\n          [36064]: texture\n        });\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: \"\".concat(id, \"-fb\"),\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n              id: \"\".concat(id, \"-maxMinFb\"),\n              texture\n            });\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-minFb\"),\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxFb\"),\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  _getMinMaxTexture(name) {\n    const {\n      resources\n    } = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {\n        id: \"resourceName\"\n      });\n    }\n    return resources[name];\n  }\n  _setupModels() {\n    let {\n      numCol = 0,\n      numRow = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _this$gridAggregation;\n    const {\n      gl\n    } = this;\n    const {\n      shaderOptions\n    } = this.state;\n    (_this$gridAggregation = this.gridAggregationModel) === null || _this$gridAggregation === void 0 ? void 0 : _this$gridAggregation.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n  _setupWeightAttributes(opts) {\n    const {\n      weightAttributes\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n  _trackGPUResultBuffers(results, weights) {\n    const {\n      resources\n    } = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            const name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  _updateModels(opts) {\n    const {\n      vertexCount,\n      attributes,\n      numCol,\n      numRow\n    } = opts;\n    const {\n      modelDirty\n    } = this.state;\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({\n        modelDirty: false\n      });\n    }\n    this._setupWeightAttributes(opts);\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {\n      ...DEFAULT_WEIGHT_PARAMS,\n      ...weights[id]\n    };\n  }\n  return result;\n}\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0,\n    ...shaders\n  });\n}\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}","map":{"version":3,"names":["Model","Transform","FEATURES","hasFeatures","isWebGL2","readPixelsToBuffer","withParameters","fp64arithmetic","log","project32","_mergeShaders","mergeShaders","DEFAULT_RUN_PARAMS","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","DEFAULT_WEIGHT_PARAMS","PIXEL_SIZE","AGGREGATION_OPERATION","AGGREGATE_TO_GRID_VS","AGGREGATE_TO_GRID_FS","AGGREGATE_ALL_VS","AGGREGATE_ALL_FS","TRANSFORM_MEAN_VS","getFloatTexture","getFramebuffer","BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","GPUGridAggregator","getAggregationData","_ref","aggregationData","pixelIndex","index","results","cellCount","cellWeight","maxCellWieght","minCellWeight","totalCount","getCellData","_ref2","countsData","size","numCells","length","cellWeights","Float32Array","cellCounts","Uint32Array","i","sizeIndex","isSupported","gl","constructor","opts","arguments","undefined","id","state","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","_hasGPUSupport","_setupModels","delete","gridAggregationModel","allAggregationModel","meanTransform","deleteResources","run","setState","aggregationParams","_normalizeAggregationParams","_runAggregation","getData","weightId","data","aggregationBuffer","arrayName","bufferName","updateShaders","shaderOptions","modelDirty","weights","normalizeWeightParams","updateObject","Object","assign","_getAggregateData","needMin","needMax","combineMaxMin","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","concat","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","_renderAggregateData","cellSize","projectPoints","attributes","moduleSettings","numCol","numRow","translation","scaling","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","framebuffer","viewport","clear","draw","uSampler","texture","operation","MIN","MEAN","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","width","height","update","getMeanTransform","attach","_updateModels","_setupFramebuffers","framebufferSize","resize","SUM","_getMinMaxTexture","name","_this$gridAggregation","getAggregationModel","instanceCount","getAllAggregationModel","_setupWeightAttributes","vertexCount","setVertexCount","setAttributes","setInstanceCount","result","Array","isArray","forEach","obj","shaders","vs","fs","modules","drawMode","isInstanced","position","_targetTextureVarying"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"sourcesContent":["import { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nconst REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\nexport default class GPUGridAggregator {\n  static getAggregationData({\n    aggregationData,\n    maxData,\n    minData,\n    maxMinData,\n    pixelIndex\n  }) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n\n    return results;\n  }\n\n  static getCellData({\n    countsData,\n    size = 1\n  }) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n\n    for (let i = 0; i < numCells; i++) {\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n\n    return {\n      cellCounts,\n      cellWeights\n    };\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  delete() {\n    const {\n      gridAggregationModel,\n      allAggregationModel,\n      meanTransform\n    } = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n    gridAggregationModel === null || gridAggregationModel === void 0 ? void 0 : gridAggregationModel.delete();\n    allAggregationModel === null || allAggregationModel === void 0 ? void 0 : allAggregationModel.delete();\n    meanTransform === null || meanTransform === void 0 ? void 0 : meanTransform.delete();\n    deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n  }\n\n  run(opts = {}) {\n    this.setState({\n      results: {}\n    });\n\n    const aggregationParams = this._normalizeAggregationParams(opts);\n\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n\n    return this._runAggregation(aggregationParams);\n  }\n\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n\n    if (!results[weightId].aggregationData) {\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n\n    data.aggregationData = results[weightId].aggregationData;\n\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({\n      shaderOptions,\n      modelDirty: true\n    });\n  }\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = { ...DEFAULT_RUN_PARAMS,\n      ...opts\n    };\n    const {\n      weights\n    } = aggregationParams;\n\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n\n    return aggregationParams;\n  }\n\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {\n      weights\n    } = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {\n        needMin,\n        needMax,\n        combineMaxMin\n      } = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer,\n        sourceType: 5126\n      });\n\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer,\n          sourceType: 5126\n        });\n        results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer,\n            sourceType: 5126\n          });\n          results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n        }\n\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer,\n            sourceType: 5126\n          });\n          results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n        }\n      }\n    }\n\n    this._trackGPUResultBuffers(results, weights);\n\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [1, 1]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax\n      } = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: { ...parameters,\n            blendEquation: MAX_MIN_BLEND_EQUATION\n          },\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {\n            clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n          },\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: { ...parameters,\n              blendEquation: MIN_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {\n              clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n            },\n            combineMaxMin\n          });\n        }\n\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: { ...parameters,\n              blendEquation: MAX_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, 0]\n            },\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  _renderToMaxMinTexture(opts) {\n    const {\n      id,\n      parameters,\n      gridSize,\n      minOrMaxFb,\n      combineMaxMin,\n      clearParams = {}\n    } = opts;\n    const {\n      framebuffers\n    } = this.state;\n    const {\n      gl,\n      allAggregationModel\n    } = this;\n    withParameters(gl, { ...clearParams,\n      framebuffer: minOrMaxFb,\n      viewport: [0, 0, gridSize[0], gridSize[1]]\n    }, () => {\n      gl.clear(16384);\n      allAggregationModel.draw({\n        parameters,\n        uniforms: {\n          uSampler: framebuffers[id].texture,\n          gridSize,\n          combineMaxMin\n        }\n      });\n    });\n  }\n\n  _renderToWeightsTexture(opts) {\n    const {\n      id,\n      parameters,\n      moduleSettings,\n      uniforms,\n      gridSize,\n      weights\n    } = opts;\n    const {\n      framebuffers,\n      equations,\n      weightAttributes\n    } = this.state;\n    const {\n      gl,\n      gridAggregationModel\n    } = this;\n    const {\n      operation\n    } = weights[id];\n    const clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n    withParameters(gl, {\n      framebuffer: framebuffers[id],\n      viewport: [0, 0, gridSize[0], gridSize[1]],\n      clearColor\n    }, () => {\n      gl.clear(16384);\n      const attributes = {\n        weights: weightAttributes[id]\n      };\n      gridAggregationModel.draw({\n        parameters: { ...parameters,\n          blendEquation: equations[id]\n        },\n        moduleSettings,\n        uniforms,\n        attributes\n      });\n    });\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {\n        meanTextures,\n        textures\n      } = this.state;\n      const transformOptions = {\n        _sourceTextures: {\n          aggregationValues: meanTextures[id]\n        },\n        _targetTexture: textures[id],\n        elementCount: textures[id].width * textures[id].height\n      };\n\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n      framebuffers[id].attach({\n        [36064]: textures[id]\n      });\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n\n    this._setupFramebuffers(opts);\n\n    this._renderAggregateData(opts);\n\n    const results = this._getAggregateData(opts);\n\n    this.setState({\n      results\n    });\n    return results;\n  }\n\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    const {\n      numCol,\n      numRow\n    } = opts;\n    const framebufferSize = {\n      width: numCol,\n      height: numRow\n    };\n\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax,\n        combineMaxMin,\n        operation\n      } = weights[id];\n      textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n        id: \"\".concat(id, \"-texture\"),\n        width: numCol,\n        height: numRow\n      });\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-mean-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n\n      if (framebuffers[id]) {\n        framebuffers[id].attach({\n          [36064]: texture\n        });\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: \"\".concat(id, \"-fb\"),\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n              id: \"\".concat(id, \"-maxMinFb\"),\n              texture\n            });\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-minFb\"),\n                texture\n              });\n            }\n          }\n\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxFb\"),\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  _getMinMaxTexture(name) {\n    const {\n      resources\n    } = this.state;\n\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {\n        id: \"resourceName\"\n      });\n    }\n\n    return resources[name];\n  }\n\n  _setupModels({\n    numCol = 0,\n    numRow = 0\n  } = {}) {\n    var _this$gridAggregation;\n\n    const {\n      gl\n    } = this;\n    const {\n      shaderOptions\n    } = this.state;\n    (_this$gridAggregation = this.gridAggregationModel) === null || _this$gridAggregation === void 0 ? void 0 : _this$gridAggregation.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  _setupWeightAttributes(opts) {\n    const {\n      weightAttributes\n    } = this.state;\n    const {\n      weights\n    } = opts;\n\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  _trackGPUResultBuffers(results, weights) {\n    const {\n      resources\n    } = this.state;\n\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            const name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n\n            if (resources[name]) {\n              resources[name].delete();\n            }\n\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n\n  _updateModels(opts) {\n    const {\n      vertexCount,\n      attributes,\n      numCol,\n      numRow\n    } = opts;\n    const {\n      modelDirty\n    } = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n\n      this.setState({\n        modelDirty: false\n      });\n    }\n\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n\n}\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n\n  for (const id in weights) {\n    result[id] = { ...DEFAULT_WEIGHT_PARAMS,\n      ...weights[id]\n    };\n  }\n\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n//# sourceMappingURL=gpu-grid-aggregator.js.map"],"mappings":"AAAA,SAASA,KAAK,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,kBAAkB,EAAEC,cAAc,QAAQ,eAAe;AACrH,SAASC,cAAc,QAAQ,sBAAsB;AACrD,SAASC,GAAG,EAAEC,SAAS,EAAEC,aAAa,IAAIC,YAAY,QAAQ,eAAe;AAC7E,SAASC,kBAAkB,EAAEC,gBAAgB,EAAEC,kBAAkB,EAAEC,kBAAkB,EAAEC,sBAAsB,EAAEC,YAAY,EAAEC,qBAAqB,EAAEC,UAAU,QAAQ,iCAAiC;AACvM,SAASC,qBAAqB,QAAQ,gCAAgC;AACtE,OAAOC,oBAAoB,MAAM,6BAA6B;AAC9D,OAAOC,oBAAoB,MAAM,6BAA6B;AAC9D,OAAOC,gBAAgB,MAAM,yBAAyB;AACtD,OAAOC,gBAAgB,MAAM,yBAAyB;AACtD,OAAOC,iBAAiB,MAAM,0BAA0B;AACxD,SAASC,eAAe,EAAEC,cAAc,QAAQ,wBAAwB;AACxE,MAAMC,YAAY,GAAG,CAAC,mBAAmB,EAAE,cAAc,EAAE,WAAW,EAAE,WAAW,CAAC;AACpF,MAAMC,gBAAgB,GAAG;EACvBC,OAAO,EAAE,WAAW;EACpBC,OAAO,EAAE,WAAW;EACpBC,UAAU,EAAE;AACd,CAAC;AACD,MAAMC,iBAAiB,GAAG,CAAC/B,QAAQ,CAACgC,MAAM,EAAEhC,QAAQ,CAACiC,wBAAwB,EAAEjC,QAAQ,CAACkC,qBAAqB,EAAElC,QAAQ,CAACmC,WAAW,EAAEnC,QAAQ,CAACoC,aAAa,CAAC;AAC5J,eAAe,MAAMC,iBAAiB,CAAC;EACrC,OAAOC,kBAAkBA,CAAAC,IAAA,EAMtB;IAAA,IANuB;MACxBC,eAAe;MACfZ,OAAO;MACPC,OAAO;MACPC,UAAU;MACVW;IACF,CAAC,GAAAF,IAAA;IACC,MAAMG,KAAK,GAAGD,UAAU,GAAGxB,UAAU;IACrC,MAAM0B,OAAO,GAAG,CAAC,CAAC;IAElB,IAAIH,eAAe,EAAE;MACnBG,OAAO,CAACC,SAAS,GAAGJ,eAAe,CAACE,KAAK,GAAG,CAAC,CAAC;MAC9CC,OAAO,CAACE,UAAU,GAAGL,eAAe,CAACE,KAAK,CAAC;IAC7C;IAEA,IAAIZ,UAAU,EAAE;MACda,OAAO,CAACG,aAAa,GAAGhB,UAAU,CAAC,CAAC,CAAC;MACrCa,OAAO,CAACI,aAAa,GAAGjB,UAAU,CAAC,CAAC,CAAC;IACvC,CAAC,MAAM;MACL,IAAIF,OAAO,EAAE;QACXe,OAAO,CAACG,aAAa,GAAGlB,OAAO,CAAC,CAAC,CAAC;QAClCe,OAAO,CAACK,UAAU,GAAGpB,OAAO,CAAC,CAAC,CAAC;MACjC;MAEA,IAAIC,OAAO,EAAE;QACXc,OAAO,CAACI,aAAa,GAAGlB,OAAO,CAAC,CAAC,CAAC;QAClCc,OAAO,CAACK,UAAU,GAAGpB,OAAO,CAAC,CAAC,CAAC;MACjC;IACF;IAEA,OAAOe,OAAO;EAChB;EAEA,OAAOM,WAAWA,CAAAC,KAAA,EAGf;IAAA,IAHgB;MACjBC,UAAU;MACVC,IAAI,GAAG;IACT,CAAC,GAAAF,KAAA;IACC,MAAMG,QAAQ,GAAGF,UAAU,CAACG,MAAM,GAAG,CAAC;IACtC,MAAMC,WAAW,GAAG,IAAIC,YAAY,CAACH,QAAQ,GAAGD,IAAI,CAAC;IACrD,MAAMK,UAAU,GAAG,IAAIC,WAAW,CAACL,QAAQ,CAAC;IAE5C,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,QAAQ,EAAEM,CAAC,EAAE,EAAE;MACjC,KAAK,IAAIC,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGR,IAAI,EAAEQ,SAAS,EAAE,EAAE;QACrDL,WAAW,CAACI,CAAC,GAAGP,IAAI,GAAGQ,SAAS,CAAC,GAAGT,UAAU,CAACQ,CAAC,GAAG,CAAC,GAAGC,SAAS,CAAC;MACnE;MAEAH,UAAU,CAACE,CAAC,CAAC,GAAGR,UAAU,CAACQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACvC;IAEA,OAAO;MACLF,UAAU;MACVF;IACF,CAAC;EACH;EAEA,OAAOM,WAAWA,CAACC,EAAE,EAAE;IACrB,OAAO7D,WAAW,CAAC6D,EAAE,EAAE/B,iBAAiB,CAAC;EAC3C;EAEAgC,WAAWA,CAACD,EAAE,EAAa;IAAA,IAAXE,IAAI,GAAAC,SAAA,CAAAX,MAAA,QAAAW,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IACvB,IAAI,CAACE,EAAE,GAAGH,IAAI,CAACG,EAAE,IAAI,qBAAqB;IAC1C,IAAI,CAACL,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACM,KAAK,GAAG;MACXC,gBAAgB,EAAE,CAAC,CAAC;MACpBC,QAAQ,EAAE,CAAC,CAAC;MACZC,YAAY,EAAE,CAAC,CAAC;MAChBC,OAAO,EAAE,CAAC,CAAC;MACXC,YAAY,EAAE,CAAC,CAAC;MAChBC,kBAAkB,EAAE,CAAC,CAAC;MACtBC,eAAe,EAAE,CAAC,CAAC;MACnBC,eAAe,EAAE,CAAC,CAAC;MACnBC,SAAS,EAAE,CAAC,CAAC;MACbC,SAAS,EAAE,CAAC,CAAC;MACbnC,OAAO,EAAE,CAAC;IACZ,CAAC;IACD,IAAI,CAACoC,cAAc,GAAG7E,QAAQ,CAAC4D,EAAE,CAAC,IAAI7D,WAAW,CAAC,IAAI,CAAC6D,EAAE,EAAE9D,QAAQ,CAACkC,qBAAqB,EAAElC,QAAQ,CAACiC,wBAAwB,EAAEjC,QAAQ,CAACoC,aAAa,CAAC;IAErJ,IAAI,IAAI,CAAC2C,cAAc,EAAE;MACvB,IAAI,CAACC,YAAY,EAAE;IACrB;EACF;EAEAC,MAAMA,CAAA,EAAG;IACP,MAAM;MACJC,oBAAoB;MACpBC,mBAAmB;MACnBC;IACF,CAAC,GAAG,IAAI;IACR,MAAM;MACJd,QAAQ;MACRG,YAAY;MACZC,kBAAkB;MAClBC,eAAe;MACfC,eAAe;MACfL,YAAY;MACZO;IACF,CAAC,GAAG,IAAI,CAACV,KAAK;IACdc,oBAAoB,KAAK,IAAI,IAAIA,oBAAoB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,oBAAoB,CAACD,MAAM,EAAE;IACzGE,mBAAmB,KAAK,IAAI,IAAIA,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,CAACF,MAAM,EAAE;IACtGG,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACH,MAAM,EAAE;IACpFI,eAAe,CAAC,CAACZ,YAAY,EAAEH,QAAQ,EAAEI,kBAAkB,EAAEC,eAAe,EAAEC,eAAe,EAAEL,YAAY,EAAEO,SAAS,CAAC,CAAC;EAC1H;EAEAQ,GAAGA,CAAA,EAAY;IAAA,IAAXtB,IAAI,GAAAC,SAAA,CAAAX,MAAA,QAAAW,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IACX,IAAI,CAACsB,QAAQ,CAAC;MACZ5C,OAAO,EAAE,CAAC;IACZ,CAAC,CAAC;IAEF,MAAM6C,iBAAiB,GAAG,IAAI,CAACC,2BAA2B,CAACzB,IAAI,CAAC;IAEhE,IAAI,CAAC,IAAI,CAACe,cAAc,EAAE;MACxBzE,GAAG,CAACA,GAAG,CAAC,CAAC,EAAE,kCAAkC,CAAC,EAAE;IAClD;IAEA,OAAO,IAAI,CAACoF,eAAe,CAACF,iBAAiB,CAAC;EAChD;EAEAG,OAAOA,CAACC,QAAQ,EAAE;IAChB,MAAMC,IAAI,GAAG,CAAC,CAAC;IACf,MAAMlD,OAAO,GAAG,IAAI,CAACyB,KAAK,CAACzB,OAAO;IAElC,IAAI,CAACA,OAAO,CAACiD,QAAQ,CAAC,CAACpD,eAAe,EAAE;MACtCG,OAAO,CAACiD,QAAQ,CAAC,CAACpD,eAAe,GAAGG,OAAO,CAACiD,QAAQ,CAAC,CAACE,iBAAiB,CAACH,OAAO,EAAE;IACnF;IAEAE,IAAI,CAACrD,eAAe,GAAGG,OAAO,CAACiD,QAAQ,CAAC,CAACpD,eAAe;IAExD,KAAK,MAAMuD,SAAS,IAAIpE,gBAAgB,EAAE;MACxC,MAAMqE,UAAU,GAAGrE,gBAAgB,CAACoE,SAAS,CAAC;MAE9C,IAAIpD,OAAO,CAACiD,QAAQ,CAAC,CAACG,SAAS,CAAC,IAAIpD,OAAO,CAACiD,QAAQ,CAAC,CAACI,UAAU,CAAC,EAAE;QACjErD,OAAO,CAACiD,QAAQ,CAAC,CAACG,SAAS,CAAC,GAAGpD,OAAO,CAACiD,QAAQ,CAAC,CAACG,SAAS,CAAC,IAAIpD,OAAO,CAACiD,QAAQ,CAAC,CAACI,UAAU,CAAC,CAACL,OAAO,EAAE;QACtGE,IAAI,CAACE,SAAS,CAAC,GAAGpD,OAAO,CAACiD,QAAQ,CAAC,CAACG,SAAS,CAAC;MAChD;IACF;IAEA,OAAOF,IAAI;EACb;EAEAI,aAAaA,CAAA,EAAqB;IAAA,IAApBC,aAAa,GAAAjC,SAAA,CAAAX,MAAA,QAAAW,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IAC9B,IAAI,CAACsB,QAAQ,CAAC;MACZW,aAAa;MACbC,UAAU,EAAE;IACd,CAAC,CAAC;EACJ;EAEAV,2BAA2BA,CAACzB,IAAI,EAAE;IAChC,MAAMwB,iBAAiB,GAAG;MAAE,GAAG9E,kBAAkB;MAC/C,GAAGsD;IACL,CAAC;IACD,MAAM;MACJoC;IACF,CAAC,GAAGZ,iBAAiB;IAErB,IAAIY,OAAO,EAAE;MACXZ,iBAAiB,CAACY,OAAO,GAAGC,qBAAqB,CAACD,OAAO,CAAC;IAC5D;IAEA,OAAOZ,iBAAiB;EAC1B;EAEAD,QAAQA,CAACe,YAAY,EAAE;IACrBC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACpC,KAAK,EAAEkC,YAAY,CAAC;EACzC;EAEAG,iBAAiBA,CAACzC,IAAI,EAAE;IACtB,MAAMrB,OAAO,GAAG,CAAC,CAAC;IAClB,MAAM;MACJ2B,QAAQ;MACRG,YAAY;MACZC,kBAAkB;MAClBC,eAAe;MACfC,eAAe;MACfE;IACF,CAAC,GAAG,IAAI,CAACV,KAAK;IACd,MAAM;MACJgC;IACF,CAAC,GAAGpC,IAAI;IAER,KAAK,MAAMG,EAAE,IAAIiC,OAAO,EAAE;MACxBzD,OAAO,CAACwB,EAAE,CAAC,GAAG,CAAC,CAAC;MAChB,MAAM;QACJuC,OAAO;QACPC,OAAO;QACPC;MACF,CAAC,GAAGR,OAAO,CAACjC,EAAE,CAAC;MACfxB,OAAO,CAACwB,EAAE,CAAC,CAAC0C,kBAAkB,GAAGvC,QAAQ,CAACH,EAAE,CAAC;MAC7CxB,OAAO,CAACwB,EAAE,CAAC,CAAC2B,iBAAiB,GAAG3F,kBAAkB,CAACsE,YAAY,CAACN,EAAE,CAAC,EAAE;QACnE2C,MAAM,EAAEV,OAAO,CAACjC,EAAE,CAAC,CAAC2B,iBAAiB;QACrCiB,UAAU,EAAE;MACd,CAAC,CAAC;MAEF,IAAIL,OAAO,IAAIC,OAAO,IAAIC,aAAa,EAAE;QACvCjE,OAAO,CAACwB,EAAE,CAAC,CAAC6C,YAAY,GAAG7G,kBAAkB,CAACuE,kBAAkB,CAACP,EAAE,CAAC,EAAE;UACpE2C,MAAM,EAAEV,OAAO,CAACjC,EAAE,CAAC,CAAC6C,YAAY;UAChCD,UAAU,EAAE;QACd,CAAC,CAAC;QACFpE,OAAO,CAACwB,EAAE,CAAC,CAAC8C,aAAa,GAAGnC,SAAS,CAAC,EAAE,CAACoC,MAAM,CAAC/C,EAAE,EAAE,gBAAgB,CAAC,CAAC;MACxE,CAAC,MAAM;QACL,IAAIuC,OAAO,EAAE;UACX/D,OAAO,CAACwB,EAAE,CAAC,CAACgD,SAAS,GAAGhH,kBAAkB,CAACwE,eAAe,CAACR,EAAE,CAAC,EAAE;YAC9D2C,MAAM,EAAEV,OAAO,CAACjC,EAAE,CAAC,CAACgD,SAAS;YAC7BJ,UAAU,EAAE;UACd,CAAC,CAAC;UACFpE,OAAO,CAACwB,EAAE,CAAC,CAACiD,UAAU,GAAGtC,SAAS,CAAC,EAAE,CAACoC,MAAM,CAAC/C,EAAE,EAAE,aAAa,CAAC,CAAC;QAClE;QAEA,IAAIwC,OAAO,EAAE;UACXhE,OAAO,CAACwB,EAAE,CAAC,CAACkD,SAAS,GAAGlH,kBAAkB,CAACyE,eAAe,CAACT,EAAE,CAAC,EAAE;YAC9D2C,MAAM,EAAEV,OAAO,CAACjC,EAAE,CAAC,CAACkD,SAAS;YAC7BN,UAAU,EAAE;UACd,CAAC,CAAC;UACFpE,OAAO,CAACwB,EAAE,CAAC,CAACmD,UAAU,GAAGxC,SAAS,CAAC,EAAE,CAACoC,MAAM,CAAC/C,EAAE,EAAE,aAAa,CAAC,CAAC;QAClE;MACF;IACF;IAEA,IAAI,CAACoD,sBAAsB,CAAC5E,OAAO,EAAEyD,OAAO,CAAC;IAE7C,OAAOzD,OAAO;EAChB;EAEA6E,oBAAoBA,CAACxD,IAAI,EAAE;IACzB,MAAM;MACJyD,QAAQ;MACRC,aAAa;MACbC,UAAU;MACVC,cAAc;MACdC,MAAM;MACNC,MAAM;MACN1B,OAAO;MACP2B,WAAW;MACXC;IACF,CAAC,GAAGhE,IAAI;IACR,MAAM;MACJU,kBAAkB;MAClBC,eAAe;MACfC;IACF,CAAC,GAAG,IAAI,CAACR,KAAK;IACd,MAAM6D,QAAQ,GAAG,CAACJ,MAAM,EAAEC,MAAM,CAAC;IACjC,MAAMI,UAAU,GAAG;MACjBC,KAAK,EAAE,IAAI;MACXC,SAAS,EAAE,KAAK;MAChBC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC;IAClB,CAAC;IACD,MAAMC,QAAQ,GAAG;MACfb,QAAQ;MACRQ,QAAQ;MACRP,aAAa;MACbK,WAAW;MACXC;IACF,CAAC;IAED,KAAK,MAAM7D,EAAE,IAAIiC,OAAO,EAAE;MACxB,MAAM;QACJM,OAAO;QACPC;MACF,CAAC,GAAGP,OAAO,CAACjC,EAAE,CAAC;MACf,MAAMyC,aAAa,GAAGF,OAAO,IAAIC,OAAO,IAAIP,OAAO,CAACjC,EAAE,CAAC,CAACyC,aAAa;MAErE,IAAI,CAAC2B,uBAAuB,CAAC;QAC3BpE,EAAE;QACF+D,UAAU;QACVN,cAAc;QACdU,QAAQ;QACRL,QAAQ;QACRN,UAAU;QACVvB;MACF,CAAC,CAAC;MAEF,IAAIQ,aAAa,EAAE;QACjB,IAAI,CAAC4B,sBAAsB,CAAC;UAC1BrE,EAAE;UACF+D,UAAU,EAAE;YAAE,GAAGA,UAAU;YACzBO,aAAa,EAAE3H;UACjB,CAAC;UACDmH,QAAQ;UACRS,UAAU,EAAEhE,kBAAkB,CAACP,EAAE,CAAC;UAClCwE,WAAW,EAAE;YACXC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEjI,gBAAgB;UACxC,CAAC;UACDiG;QACF,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAIF,OAAO,EAAE;UACX,IAAI,CAAC8B,sBAAsB,CAAC;YAC1BrE,EAAE;YACF+D,UAAU,EAAE;cAAE,GAAGA,UAAU;cACzBO,aAAa,EAAE7H;YACjB,CAAC;YACDqH,QAAQ;YACRS,UAAU,EAAE/D,eAAe,CAACR,EAAE,CAAC;YAC/BwE,WAAW,EAAE;cACXC,UAAU,EAAE,CAACjI,gBAAgB,EAAEA,gBAAgB,EAAEA,gBAAgB,EAAE,CAAC;YACtE,CAAC;YACDiG;UACF,CAAC,CAAC;QACJ;QAEA,IAAID,OAAO,EAAE;UACX,IAAI,CAAC6B,sBAAsB,CAAC;YAC1BrE,EAAE;YACF+D,UAAU,EAAE;cAAE,GAAGA,UAAU;cACzBO,aAAa,EAAE5H;YACjB,CAAC;YACDoH,QAAQ;YACRS,UAAU,EAAE9D,eAAe,CAACT,EAAE,CAAC;YAC/BwE,WAAW,EAAE;cACXC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;YACzB,CAAC;YACDhC;UACF,CAAC,CAAC;QACJ;MACF;IACF;EACF;EAEA4B,sBAAsBA,CAACxE,IAAI,EAAE;IAC3B,MAAM;MACJG,EAAE;MACF+D,UAAU;MACVD,QAAQ;MACRS,UAAU;MACV9B,aAAa;MACb+B,WAAW,GAAG,CAAC;IACjB,CAAC,GAAG3E,IAAI;IACR,MAAM;MACJS;IACF,CAAC,GAAG,IAAI,CAACL,KAAK;IACd,MAAM;MACJN,EAAE;MACFqB;IACF,CAAC,GAAG,IAAI;IACR/E,cAAc,CAAC0D,EAAE,EAAE;MAAE,GAAG6E,WAAW;MACjCE,WAAW,EAAEH,UAAU;MACvBI,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAEb,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC;IAC3C,CAAC,EAAE,MAAM;MACPnE,EAAE,CAACiF,KAAK,CAAC,KAAK,CAAC;MACf5D,mBAAmB,CAAC6D,IAAI,CAAC;QACvBd,UAAU;QACVI,QAAQ,EAAE;UACRW,QAAQ,EAAExE,YAAY,CAACN,EAAE,CAAC,CAAC+E,OAAO;UAClCjB,QAAQ;UACRrB;QACF;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA2B,uBAAuBA,CAACvE,IAAI,EAAE;IAC5B,MAAM;MACJG,EAAE;MACF+D,UAAU;MACVN,cAAc;MACdU,QAAQ;MACRL,QAAQ;MACR7B;IACF,CAAC,GAAGpC,IAAI;IACR,MAAM;MACJS,YAAY;MACZI,SAAS;MACTR;IACF,CAAC,GAAG,IAAI,CAACD,KAAK;IACd,MAAM;MACJN,EAAE;MACFoB;IACF,CAAC,GAAG,IAAI;IACR,MAAM;MACJiE;IACF,CAAC,GAAG/C,OAAO,CAACjC,EAAE,CAAC;IACf,MAAMyE,UAAU,GAAGO,SAAS,KAAKjI,qBAAqB,CAACkI,GAAG,GAAG,CAACzI,gBAAgB,EAAEA,gBAAgB,EAAEA,gBAAgB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACrIP,cAAc,CAAC0D,EAAE,EAAE;MACjB+E,WAAW,EAAEpE,YAAY,CAACN,EAAE,CAAC;MAC7B2E,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAEb,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;MAC1CW;IACF,CAAC,EAAE,MAAM;MACP9E,EAAE,CAACiF,KAAK,CAAC,KAAK,CAAC;MACf,MAAMpB,UAAU,GAAG;QACjBvB,OAAO,EAAE/B,gBAAgB,CAACF,EAAE;MAC9B,CAAC;MACDe,oBAAoB,CAAC8D,IAAI,CAAC;QACxBd,UAAU,EAAE;UAAE,GAAGA,UAAU;UACzBO,aAAa,EAAE5D,SAAS,CAACV,EAAE;QAC7B,CAAC;QACDyD,cAAc;QACdU,QAAQ;QACRX;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,IAAIwB,SAAS,KAAKjI,qBAAqB,CAACmI,IAAI,EAAE;MAC5C,MAAM;QACJ9E,YAAY;QACZD;MACF,CAAC,GAAG,IAAI,CAACF,KAAK;MACd,MAAMkF,gBAAgB,GAAG;QACvBC,eAAe,EAAE;UACfC,iBAAiB,EAAEjF,YAAY,CAACJ,EAAE;QACpC,CAAC;QACDsF,cAAc,EAAEnF,QAAQ,CAACH,EAAE,CAAC;QAC5BuF,YAAY,EAAEpF,QAAQ,CAACH,EAAE,CAAC,CAACwF,KAAK,GAAGrF,QAAQ,CAACH,EAAE,CAAC,CAACyF;MAClD,CAAC;MAED,IAAI,IAAI,CAACxE,aAAa,EAAE;QACtB,IAAI,CAACA,aAAa,CAACyE,MAAM,CAACP,gBAAgB,CAAC;MAC7C,CAAC,MAAM;QACL,IAAI,CAAClE,aAAa,GAAG0E,gBAAgB,CAAChG,EAAE,EAAEwF,gBAAgB,CAAC;MAC7D;MAEA,IAAI,CAAClE,aAAa,CAACE,GAAG,CAAC;QACrB4C,UAAU,EAAE;UACVC,KAAK,EAAE,KAAK;UACZC,SAAS,EAAE;QACb;MACF,CAAC,CAAC;MACF3D,YAAY,CAACN,EAAE,CAAC,CAAC4F,MAAM,CAAC;QACtB,CAAC,KAAK,GAAGzF,QAAQ,CAACH,EAAE;MACtB,CAAC,CAAC;IACJ;EACF;EAEAuB,eAAeA,CAAC1B,IAAI,EAAE;IACpB,IAAI,CAACgG,aAAa,CAAChG,IAAI,CAAC;IAExB,IAAI,CAACiG,kBAAkB,CAACjG,IAAI,CAAC;IAE7B,IAAI,CAACwD,oBAAoB,CAACxD,IAAI,CAAC;IAE/B,MAAMrB,OAAO,GAAG,IAAI,CAAC8D,iBAAiB,CAACzC,IAAI,CAAC;IAE5C,IAAI,CAACuB,QAAQ,CAAC;MACZ5C;IACF,CAAC,CAAC;IACF,OAAOA,OAAO;EAChB;EAEAsH,kBAAkBA,CAACjG,IAAI,EAAE;IACvB,MAAM;MACJM,QAAQ;MACRG,YAAY;MACZC,kBAAkB;MAClBC,eAAe;MACfC,eAAe;MACfL,YAAY;MACZM;IACF,CAAC,GAAG,IAAI,CAACT,KAAK;IACd,MAAM;MACJgC;IACF,CAAC,GAAGpC,IAAI;IACR,MAAM;MACJ6D,MAAM;MACNC;IACF,CAAC,GAAG9D,IAAI;IACR,MAAMkG,eAAe,GAAG;MACtBP,KAAK,EAAE9B,MAAM;MACb+B,MAAM,EAAE9B;IACV,CAAC;IAED,KAAK,MAAM3D,EAAE,IAAIiC,OAAO,EAAE;MACxB,MAAM;QACJM,OAAO;QACPC,OAAO;QACPC,aAAa;QACbuC;MACF,CAAC,GAAG/C,OAAO,CAACjC,EAAE,CAAC;MACfG,QAAQ,CAACH,EAAE,CAAC,GAAGiC,OAAO,CAACjC,EAAE,CAAC,CAAC0C,kBAAkB,IAAIvC,QAAQ,CAACH,EAAE,CAAC,IAAI3C,eAAe,CAAC,IAAI,CAACsC,EAAE,EAAE;QACxFK,EAAE,EAAE,EAAE,CAAC+C,MAAM,CAAC/C,EAAE,EAAE,UAAU,CAAC;QAC7BwF,KAAK,EAAE9B,MAAM;QACb+B,MAAM,EAAE9B;MACV,CAAC,CAAC;MACFxD,QAAQ,CAACH,EAAE,CAAC,CAACgG,MAAM,CAACD,eAAe,CAAC;MACpC,IAAIhB,OAAO,GAAG5E,QAAQ,CAACH,EAAE,CAAC;MAE1B,IAAIgF,SAAS,KAAKjI,qBAAqB,CAACmI,IAAI,EAAE;QAC5C9E,YAAY,CAACJ,EAAE,CAAC,GAAGI,YAAY,CAACJ,EAAE,CAAC,IAAI3C,eAAe,CAAC,IAAI,CAACsC,EAAE,EAAE;UAC9DK,EAAE,EAAE,EAAE,CAAC+C,MAAM,CAAC/C,EAAE,EAAE,eAAe,CAAC;UAClCwF,KAAK,EAAE9B,MAAM;UACb+B,MAAM,EAAE9B;QACV,CAAC,CAAC;QACFvD,YAAY,CAACJ,EAAE,CAAC,CAACgG,MAAM,CAACD,eAAe,CAAC;QACxChB,OAAO,GAAG3E,YAAY,CAACJ,EAAE,CAAC;MAC5B;MAEA,IAAIM,YAAY,CAACN,EAAE,CAAC,EAAE;QACpBM,YAAY,CAACN,EAAE,CAAC,CAAC4F,MAAM,CAAC;UACtB,CAAC,KAAK,GAAGb;QACX,CAAC,CAAC;MACJ,CAAC,MAAM;QACLzE,YAAY,CAACN,EAAE,CAAC,GAAG1C,cAAc,CAAC,IAAI,CAACqC,EAAE,EAAE;UACzCK,EAAE,EAAE,EAAE,CAAC+C,MAAM,CAAC/C,EAAE,EAAE,KAAK,CAAC;UACxBwF,KAAK,EAAE9B,MAAM;UACb+B,MAAM,EAAE9B,MAAM;UACdoB;QACF,CAAC,CAAC;MACJ;MAEAzE,YAAY,CAACN,EAAE,CAAC,CAACgG,MAAM,CAACD,eAAe,CAAC;MACxCrF,SAAS,CAACV,EAAE,CAAC,GAAGpD,YAAY,CAACoI,SAAS,CAAC,IAAIpI,YAAY,CAACqJ,GAAG;MAE3D,IAAI1D,OAAO,IAAIC,OAAO,EAAE;QACtB,IAAID,OAAO,IAAIC,OAAO,IAAIC,aAAa,EAAE;UACvC,IAAI,CAAClC,kBAAkB,CAACP,EAAE,CAAC,EAAE;YAC3B+E,OAAO,GAAG9C,OAAO,CAACjC,EAAE,CAAC,CAAC8C,aAAa,IAAI,IAAI,CAACoD,iBAAiB,CAAC,EAAE,CAACnD,MAAM,CAAC/C,EAAE,EAAE,gBAAgB,CAAC,CAAC;YAC9FO,kBAAkB,CAACP,EAAE,CAAC,GAAG1C,cAAc,CAAC,IAAI,CAACqC,EAAE,EAAE;cAC/CK,EAAE,EAAE,EAAE,CAAC+C,MAAM,CAAC/C,EAAE,EAAE,WAAW,CAAC;cAC9B+E;YACF,CAAC,CAAC;UACJ;QACF,CAAC,MAAM;UACL,IAAIxC,OAAO,EAAE;YACX,IAAI,CAAC/B,eAAe,CAACR,EAAE,CAAC,EAAE;cACxB+E,OAAO,GAAG9C,OAAO,CAACjC,EAAE,CAAC,CAACiD,UAAU,IAAI,IAAI,CAACiD,iBAAiB,CAAC,EAAE,CAACnD,MAAM,CAAC/C,EAAE,EAAE,aAAa,CAAC,CAAC;cACxFQ,eAAe,CAACR,EAAE,CAAC,GAAG1C,cAAc,CAAC,IAAI,CAACqC,EAAE,EAAE;gBAC5CK,EAAE,EAAE,EAAE,CAAC+C,MAAM,CAAC/C,EAAE,EAAE,QAAQ,CAAC;gBAC3B+E;cACF,CAAC,CAAC;YACJ;UACF;UAEA,IAAIvC,OAAO,EAAE;YACX,IAAI,CAAC/B,eAAe,CAACT,EAAE,CAAC,EAAE;cACxB+E,OAAO,GAAG9C,OAAO,CAACjC,EAAE,CAAC,CAACmD,UAAU,IAAI,IAAI,CAAC+C,iBAAiB,CAAC,EAAE,CAACnD,MAAM,CAAC/C,EAAE,EAAE,aAAa,CAAC,CAAC;cACxFS,eAAe,CAACT,EAAE,CAAC,GAAG1C,cAAc,CAAC,IAAI,CAACqC,EAAE,EAAE;gBAC5CK,EAAE,EAAE,EAAE,CAAC+C,MAAM,CAAC/C,EAAE,EAAE,QAAQ,CAAC;gBAC3B+E;cACF,CAAC,CAAC;YACJ;UACF;QACF;MACF;IACF;EACF;EAEAmB,iBAAiBA,CAACC,IAAI,EAAE;IACtB,MAAM;MACJxF;IACF,CAAC,GAAG,IAAI,CAACV,KAAK;IAEd,IAAI,CAACU,SAAS,CAACwF,IAAI,CAAC,EAAE;MACpBxF,SAAS,CAACwF,IAAI,CAAC,GAAG9I,eAAe,CAAC,IAAI,CAACsC,EAAE,EAAE;QACzCK,EAAE,EAAE;MACN,CAAC,CAAC;IACJ;IAEA,OAAOW,SAAS,CAACwF,IAAI,CAAC;EACxB;EAEAtF,YAAYA,CAAA,EAGJ;IAAA,IAHK;MACX6C,MAAM,GAAG,CAAC;MACVC,MAAM,GAAG;IACX,CAAC,GAAA7D,SAAA,CAAAX,MAAA,QAAAW,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IACJ,IAAIsG,qBAAqB;IAEzB,MAAM;MACJzG;IACF,CAAC,GAAG,IAAI;IACR,MAAM;MACJoC;IACF,CAAC,GAAG,IAAI,CAAC9B,KAAK;IACd,CAACmG,qBAAqB,GAAG,IAAI,CAACrF,oBAAoB,MAAM,IAAI,IAAIqF,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAACtF,MAAM,EAAE;IAC1I,IAAI,CAACC,oBAAoB,GAAGsF,mBAAmB,CAAC1G,EAAE,EAAEoC,aAAa,CAAC;IAElE,IAAI,CAAC,IAAI,CAACf,mBAAmB,EAAE;MAC7B,MAAMsF,aAAa,GAAG5C,MAAM,GAAGC,MAAM;MACrC,IAAI,CAAC3C,mBAAmB,GAAGuF,sBAAsB,CAAC5G,EAAE,EAAE2G,aAAa,CAAC;IACtE;EACF;EAEAE,sBAAsBA,CAAC3G,IAAI,EAAE;IAC3B,MAAM;MACJK;IACF,CAAC,GAAG,IAAI,CAACD,KAAK;IACd,MAAM;MACJgC;IACF,CAAC,GAAGpC,IAAI;IAER,KAAK,MAAMG,EAAE,IAAIiC,OAAO,EAAE;MACxB/B,gBAAgB,CAACF,EAAE,CAAC,GAAGH,IAAI,CAAC2D,UAAU,CAACxD,EAAE,CAAC;IAC5C;EACF;EAEAoD,sBAAsBA,CAAC5E,OAAO,EAAEyD,OAAO,EAAE;IACvC,MAAM;MACJtB;IACF,CAAC,GAAG,IAAI,CAACV,KAAK;IAEd,KAAK,MAAMD,EAAE,IAAIxB,OAAO,EAAE;MACxB,IAAIA,OAAO,CAACwB,EAAE,CAAC,EAAE;QACf,KAAK,MAAM6B,UAAU,IAAItE,YAAY,EAAE;UACrC,IAAIiB,OAAO,CAACwB,EAAE,CAAC,CAAC6B,UAAU,CAAC,IAAII,OAAO,CAACjC,EAAE,CAAC,CAAC6B,UAAU,CAAC,KAAKrD,OAAO,CAACwB,EAAE,CAAC,CAAC6B,UAAU,CAAC,EAAE;YAClF,MAAMsE,IAAI,GAAG,aAAa,CAACpD,MAAM,CAAC/C,EAAE,EAAE,GAAG,CAAC,CAAC+C,MAAM,CAAClB,UAAU,CAAC;YAE7D,IAAIlB,SAAS,CAACwF,IAAI,CAAC,EAAE;cACnBxF,SAAS,CAACwF,IAAI,CAAC,CAACrF,MAAM,EAAE;YAC1B;YAEAH,SAAS,CAACwF,IAAI,CAAC,GAAG3H,OAAO,CAACwB,EAAE,CAAC,CAAC6B,UAAU,CAAC;UAC3C;QACF;MACF;IACF;EACF;EAEAgE,aAAaA,CAAChG,IAAI,EAAE;IAClB,MAAM;MACJ4G,WAAW;MACXjD,UAAU;MACVE,MAAM;MACNC;IACF,CAAC,GAAG9D,IAAI;IACR,MAAM;MACJmC;IACF,CAAC,GAAG,IAAI,CAAC/B,KAAK;IAEd,IAAI+B,UAAU,EAAE;MACd,IAAI,CAACnB,YAAY,CAAChB,IAAI,CAAC;MAEvB,IAAI,CAACuB,QAAQ,CAAC;QACZY,UAAU,EAAE;MACd,CAAC,CAAC;IACJ;IAEA,IAAI,CAACwE,sBAAsB,CAAC3G,IAAI,CAAC;IAEjC,IAAI,CAACkB,oBAAoB,CAAC2F,cAAc,CAACD,WAAW,CAAC;IACrD,IAAI,CAAC1F,oBAAoB,CAAC4F,aAAa,CAACnD,UAAU,CAAC;IACnD,IAAI,CAACxC,mBAAmB,CAAC4F,gBAAgB,CAAClD,MAAM,GAAGC,MAAM,CAAC;EAC5D;AAEF;AAEA,SAASzB,qBAAqBA,CAACD,OAAO,EAAE;EACtC,MAAM4E,MAAM,GAAG,CAAC,CAAC;EAEjB,KAAK,MAAM7G,EAAE,IAAIiC,OAAO,EAAE;IACxB4E,MAAM,CAAC7G,EAAE,CAAC,GAAG;MAAE,GAAGnD,qBAAqB;MACrC,GAAGoF,OAAO,CAACjC,EAAE;IACf,CAAC;EACH;EAEA,OAAO6G,MAAM;AACf;AAEA,SAAS3F,eAAeA,CAACP,SAAS,EAAE;EAClCA,SAAS,GAAGmG,KAAK,CAACC,OAAO,CAACpG,SAAS,CAAC,GAAGA,SAAS,GAAG,CAACA,SAAS,CAAC;EAC9DA,SAAS,CAACqG,OAAO,CAACC,GAAG,IAAI;IACvB,KAAK,MAAMd,IAAI,IAAIc,GAAG,EAAE;MACtBA,GAAG,CAACd,IAAI,CAAC,CAACrF,MAAM,EAAE;IACpB;EACF,CAAC,CAAC;AACJ;AAEA,SAASuF,mBAAmBA,CAAC1G,EAAE,EAAEoC,aAAa,EAAE;EAC9C,MAAMmF,OAAO,GAAG5K,YAAY,CAAC;IAC3B6K,EAAE,EAAEnK,oBAAoB;IACxBoK,EAAE,EAAEnK,oBAAoB;IACxBoK,OAAO,EAAE,CAACnL,cAAc,EAAEE,SAAS;EACrC,CAAC,EAAE2F,aAAa,CAAC;EACjB,OAAO,IAAIpG,KAAK,CAACgE,EAAE,EAAE;IACnBK,EAAE,EAAE,wBAAwB;IAC5ByG,WAAW,EAAE,CAAC;IACda,QAAQ,EAAE,CAAC;IACX,GAAGJ;EACL,CAAC,CAAC;AACJ;AAEA,SAASX,sBAAsBA,CAAC5G,EAAE,EAAE2G,aAAa,EAAE;EACjD,OAAO,IAAI3K,KAAK,CAACgE,EAAE,EAAE;IACnBK,EAAE,EAAE,uBAAuB;IAC3BmH,EAAE,EAAEjK,gBAAgB;IACpBkK,EAAE,EAAEjK,gBAAgB;IACpBkK,OAAO,EAAE,CAACnL,cAAc,CAAC;IACzBuK,WAAW,EAAE,CAAC;IACda,QAAQ,EAAE,CAAC;IACXC,WAAW,EAAE,IAAI;IACjBjB,aAAa;IACb9C,UAAU,EAAE;MACVgE,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC;IACjB;EACF,CAAC,CAAC;AACJ;AAEA,SAAS7B,gBAAgBA,CAAChG,EAAE,EAAEE,IAAI,EAAE;EAClC,OAAO,IAAIjE,SAAS,CAAC+D,EAAE,EAAE;IACvBwH,EAAE,EAAE/J,iBAAiB;IACrBqK,qBAAqB,EAAE,YAAY;IACnC,GAAG5H;EACL,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}