{"ast":null,"code":"import Resource from './resource';\nimport Accessor from './accessor';\nimport { getGLTypeFromTypedArray, getTypedArrayFromGLType } from '../webgl-utils/typed-array-utils';\nimport { assertWebGL2Context, log } from '@luma.gl/gltools';\nimport { assert } from '../utils/assert';\nimport { checkProps } from '../utils/check-props';\nconst DEBUG_DATA_LENGTH = 10;\nconst DEPRECATED_PROPS = {\n  offset: 'accessor.offset',\n  stride: 'accessor.stride',\n  type: 'accessor.type',\n  size: 'accessor.size',\n  divisor: 'accessor.divisor',\n  normalized: 'accessor.normalized',\n  integer: 'accessor.integer',\n  instanced: 'accessor.divisor',\n  isInstanced: 'accessor.divisor'\n};\nconst PROP_CHECKS_INITIALIZE = {\n  removedProps: {},\n  replacedProps: {\n    bytes: 'byteLength'\n  },\n  deprecatedProps: DEPRECATED_PROPS\n};\nconst PROP_CHECKS_SET_PROPS = {\n  removedProps: DEPRECATED_PROPS\n};\nexport default class Buffer extends Resource {\n  get [Symbol.toStringTag]() {\n    return 'Buffer';\n  }\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, props);\n    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);\n    this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);\n    this.initialize(props);\n    Object.seal(this);\n  }\n  getElementCount() {\n    let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;\n    return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));\n  }\n  getVertexCount() {\n    let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;\n    return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));\n  }\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (ArrayBuffer.isView(props)) {\n      props = {\n        data: props\n      };\n    }\n    if (Number.isFinite(props)) {\n      props = {\n        byteLength: props\n      };\n    }\n    props = checkProps('Buffer', props, PROP_CHECKS_INITIALIZE);\n    this.usage = props.usage || 35044;\n    this.debugData = null;\n    this.setAccessor(Object.assign({}, props, props.accessor));\n    if (props.data) {\n      this._setData(props.data, props.offset, props.byteLength);\n    } else {\n      this._setByteLength(props.byteLength || 0);\n    }\n    return this;\n  }\n  setProps(props) {\n    props = checkProps('Buffer', props, PROP_CHECKS_SET_PROPS);\n    if ('accessor' in props) {\n      this.setAccessor(props.accessor);\n    }\n    return this;\n  }\n  setAccessor(accessor) {\n    accessor = Object.assign({}, accessor);\n    delete accessor.buffer;\n    this.accessor = new Accessor(accessor);\n    return this;\n  }\n  reallocate(byteLength) {\n    if (byteLength > this.byteLength) {\n      this._setByteLength(byteLength);\n      return true;\n    }\n    this.bytesUsed = byteLength;\n    return false;\n  }\n  setData(props) {\n    return this.initialize(props);\n  }\n  subData(props) {\n    if (ArrayBuffer.isView(props)) {\n      props = {\n        data: props\n      };\n    }\n    const {\n      data,\n      offset = 0,\n      srcOffset = 0\n    } = props;\n    const byteLength = props.byteLength || props.length;\n    assert(data);\n    const target = this.gl.webgl2 ? 36663 : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    if (srcOffset !== 0 || byteLength !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n    this.gl.bindBuffer(target, null);\n    this.debugData = null;\n    this._inferType(data);\n    return this;\n  }\n  copyData(_ref) {\n    let {\n      sourceBuffer,\n      readOffset = 0,\n      writeOffset = 0,\n      size\n    } = _ref;\n    const {\n      gl\n    } = this;\n    assertWebGL2Context(gl);\n    gl.bindBuffer(36662, sourceBuffer.handle);\n    gl.bindBuffer(36663, this.handle);\n    gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);\n    gl.bindBuffer(36662, null);\n    gl.bindBuffer(36663, null);\n    this.debugData = null;\n    return this;\n  }\n  getData() {\n    let {\n      dstData = null,\n      srcByteOffset = 0,\n      dstOffset = 0,\n      length = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    assertWebGL2Context(this.gl);\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {\n      clamped: false\n    });\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n    const dstElementOffset = dstOffset;\n    let dstAvailableElementCount;\n    let dstElementCount;\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount);\n    dstData = dstData || new ArrayType(dstElementCount);\n    this.gl.bindBuffer(36662, this.handle);\n    this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(36662, null);\n    return dstData;\n  }\n  bind() {\n    let {\n      target = this.target,\n      index = this.accessor && this.accessor.index,\n      offset = 0,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (target === 35345 || target === 35982) {\n      if (size !== undefined) {\n        this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      } else {\n        assert(offset === 0);\n        this.gl.bindBufferBase(target, index, this.handle);\n      }\n    } else {\n      this.gl.bindBuffer(target, this.handle);\n    }\n    return this;\n  }\n  unbind() {\n    let {\n      target = this.target,\n      index = this.accessor && this.accessor.index\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const isIndexedBuffer = target === 35345 || target === 35982;\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n    return this;\n  }\n  getDebugData() {\n    if (!this.debugData) {\n      this.debugData = this.getData({\n        length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)\n      });\n      return {\n        data: this.debugData,\n        changed: true\n      };\n    }\n    return {\n      data: this.debugData,\n      changed: false\n    };\n  }\n  invalidateDebugData() {\n    this.debugData = null;\n  }\n  _setData(data) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + offset;\n    assert(ArrayBuffer.isView(data));\n    this._trackDeallocatedMemory();\n    const target = this._getTarget();\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, byteLength, this.usage);\n    this.gl.bufferSubData(target, offset, data);\n    this.gl.bindBuffer(target, null);\n    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);\n    this.bytesUsed = byteLength;\n    this._trackAllocatedMemory(byteLength);\n    const type = getGLTypeFromTypedArray(data);\n    assert(type);\n    this.setAccessor(new Accessor(this.accessor, {\n      type\n    }));\n    return this;\n  }\n  _setByteLength(byteLength) {\n    let usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;\n    assert(byteLength >= 0);\n    this._trackDeallocatedMemory();\n    let data = byteLength;\n    if (byteLength === 0) {\n      data = new Float32Array(0);\n    }\n    const target = this._getTarget();\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data, usage);\n    this.gl.bindBuffer(target, null);\n    this.usage = usage;\n    this.debugData = null;\n    this.bytesUsed = byteLength;\n    this._trackAllocatedMemory(byteLength);\n    return this;\n  }\n  _getTarget() {\n    return this.gl.webgl2 ? 36663 : this.target;\n  }\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {\n      clamped: false\n    });\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return this.getElementCount() - sourceElementOffset;\n  }\n  _inferType(data) {\n    if (!this.accessor.type) {\n      this.setAccessor(new Accessor(this.accessor, {\n        type: getGLTypeFromTypedArray(data)\n      }));\n    }\n  }\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n    this._trackDeallocatedMemory();\n  }\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n  get type() {\n    log.deprecated('Buffer.type', 'Buffer.accessor.type')();\n    return this.accessor.type;\n  }\n  get bytes() {\n    log.deprecated('Buffer.bytes', 'Buffer.byteLength')();\n    return this.byteLength;\n  }\n  setByteLength(byteLength) {\n    log.deprecated('setByteLength', 'reallocate')();\n    return this.reallocate(byteLength);\n  }\n  updateAccessor(opts) {\n    log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();\n    this.accessor = new Accessor(this.accessor, opts);\n    return this;\n  }\n}","map":{"version":3,"names":["Resource","Accessor","getGLTypeFromTypedArray","getTypedArrayFromGLType","assertWebGL2Context","log","assert","checkProps","DEBUG_DATA_LENGTH","DEPRECATED_PROPS","offset","stride","type","size","divisor","normalized","integer","instanced","isInstanced","PROP_CHECKS_INITIALIZE","removedProps","replacedProps","bytes","deprecatedProps","PROP_CHECKS_SET_PROPS","Buffer","Symbol","toStringTag","constructor","gl","props","arguments","length","undefined","stubRemovedMethods","target","webgl2","initialize","Object","seal","getElementCount","accessor","Math","round","byteLength","getBytesPerElement","getVertexCount","getBytesPerVertex","ArrayBuffer","isView","data","Number","isFinite","usage","debugData","setAccessor","assign","_setData","_setByteLength","setProps","buffer","reallocate","bytesUsed","setData","subData","srcOffset","bindBuffer","handle","bufferSubData","_inferType","copyData","_ref","sourceBuffer","readOffset","writeOffset","copyBufferSubData","getData","dstData","srcByteOffset","dstOffset","ArrayType","clamped","sourceAvailableElementCount","_getAvailableElementCount","dstElementOffset","dstAvailableElementCount","dstElementCount","min","copyElementCount","getBufferSubData","bind","index","bindBufferRange","bindBufferBase","unbind","isIndexedBuffer","getDebugData","changed","invalidateDebugData","_trackDeallocatedMemory","_getTarget","bufferData","slice","_trackAllocatedMemory","Float32Array","sourceElementOffset","BYTES_PER_ELEMENT","_createHandle","createBuffer","_deleteHandle","deleteBuffer","_getParameter","pname","value","getBufferParameter","deprecated","setByteLength","updateAccessor","opts"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@luma.gl/webgl/src/classes/buffer.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Accessor from './accessor';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from '../webgl-utils/typed-array-utils';\nimport {assertWebGL2Context, log} from '@luma.gl/gltools';\nimport {assert} from '../utils/assert';\nimport {checkProps} from '../utils/check-props';\n\nconst DEBUG_DATA_LENGTH = 10;\n\n// Shared prop checks for constructor and setProps\nconst DEPRECATED_PROPS = {\n  offset: 'accessor.offset',\n  stride: 'accessor.stride',\n  type: 'accessor.type',\n  size: 'accessor.size',\n  divisor: 'accessor.divisor',\n  normalized: 'accessor.normalized',\n  integer: 'accessor.integer',\n  instanced: 'accessor.divisor',\n  isInstanced: 'accessor.divisor'\n};\n\n// Prop checks for constructor\nconst PROP_CHECKS_INITIALIZE = {\n  removedProps: {},\n  replacedProps: {\n    bytes: 'byteLength'\n  },\n  // new Buffer() with individual accessor props is still used in apps, emit warnings\n  deprecatedProps: DEPRECATED_PROPS\n};\n\n// Prop checks for setProps\nconst PROP_CHECKS_SET_PROPS = {\n  // Buffer.setProps() with individual accessor props is rare => emit errors\n  removedProps: DEPRECATED_PROPS\n};\n\nexport default class Buffer extends Resource {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Buffer';\n  }\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);\n    // this.stubRemovedMethods('Buffer', 'v7.0', ['updateAccessor']);\n\n    // In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    // otherwise buffer type will lock to generic (non-element) buffer\n    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n    this.target = props.target || (this.gl.webgl2 ? GL.COPY_READ_BUFFER : GL.ARRAY_BUFFER);\n\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  // returns number of elements in the buffer (assuming that the full buffer is used)\n  getElementCount(accessor = this.accessor) {\n    return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));\n  }\n\n  // returns number of vertices in the buffer (assuming that the full buffer is used)\n  getVertexCount(accessor = this.accessor) {\n    return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));\n  }\n\n  // Creates and initializes the buffer object's data store.\n  // Signature: `new Buffer(gl, {data: new Float32Array(...)})`\n  // Signature: `new Buffer(gl, new Float32Array(...))`\n  // Signature: `new Buffer(gl, 100)`\n  initialize(props = {}) {\n    // Signature `new Buffer(gl, new Float32Array(...)`\n    if (ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    // Signature: `new Buffer(gl, 100)`\n    if (Number.isFinite(props)) {\n      props = {byteLength: props};\n    }\n\n    props = checkProps('Buffer', props, PROP_CHECKS_INITIALIZE);\n\n    // Initialize member fields\n    this.usage = props.usage || GL.STATIC_DRAW;\n    this.debugData = null;\n\n    // Deprecated: Merge main props and accessor\n    this.setAccessor(Object.assign({}, props, props.accessor));\n\n    // Set data: (re)initializes the buffer\n    if (props.data) {\n      this._setData(props.data, props.offset, props.byteLength);\n    } else {\n      this._setByteLength(props.byteLength || 0);\n    }\n\n    return this;\n  }\n\n  setProps(props) {\n    props = checkProps('Buffer', props, PROP_CHECKS_SET_PROPS);\n\n    if ('accessor' in props) {\n      this.setAccessor(props.accessor);\n    }\n\n    return this;\n  }\n\n  // Optionally stores an accessor with the buffer, makes it easier to use it as an attribute later\n  // {type, size = 1, offset = 0, stride = 0, normalized = false, integer = false, divisor = 0}\n  setAccessor(accessor) {\n    // NOTE: From luma.gl v7.0, Accessors have an optional `buffer `field\n    // (mainly to support \"interleaving\")\n    // To avoid confusion, ensure `buffer.accessor` does not have a `buffer.accessor.buffer` field:\n    accessor = Object.assign({}, accessor);\n    delete accessor.buffer;\n\n    // This new statement ensures that an \"accessor object\" is re-packaged as an Accessor instance\n    this.accessor = new Accessor(accessor);\n    return this;\n  }\n\n  // Allocate a bigger GPU buffer (if the current buffer is not big enough).\n  // If a reallocation is triggered it clears the buffer\n  // Returns:\n  //  `true`: buffer was reallocated, data was cleared\n  //  `false`: buffer was big enough, data is intact\n  reallocate(byteLength) {\n    if (byteLength > this.byteLength) {\n      this._setByteLength(byteLength);\n      return true;\n    }\n    this.bytesUsed = byteLength;\n    return false;\n  }\n\n  // Update with new data. Reinitializes the buffer\n  setData(props) {\n    return this.initialize(props);\n  }\n\n  // Updates a subset of a buffer object's data store.\n  // Data (Typed Array or ArrayBuffer), length is inferred unless provided\n  // Offset into buffer\n  // WebGL2 only: Offset into srcData\n  // WebGL2 only: Number of bytes to be copied\n  subData(props) {\n    // Signature: buffer.subData(new Float32Array([...]))\n    if (ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    const {data, offset = 0, srcOffset = 0} = props;\n    const byteLength = props.byteLength || props.length;\n\n    assert(data);\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || byteLength !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n    this.gl.bindBuffer(target, null);\n\n    // TODO - update local `data` if offsets are right\n    this.debugData = null;\n\n    this._inferType(data);\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n  copyData({sourceBuffer, readOffset = 0, writeOffset = 0, size}) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n\n    // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n    gl.bindBuffer(GL.COPY_READ_BUFFER, sourceBuffer.handle);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, this.handle);\n    gl.copyBufferSubData(GL.COPY_READ_BUFFER, GL.COPY_WRITE_BUFFER, readOffset, writeOffset, size);\n    gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n    this.debugData = null;\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n  getData({dstData = null, srcByteOffset = 0, dstOffset = 0, length = 0} = {}) {\n    assertWebGL2Context(this.gl);\n\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n\n    const dstElementOffset = dstOffset;\n\n    let dstAvailableElementCount;\n    let dstElementCount;\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      // Allocate ArrayBufferView with enough size to copy all eligible data.\n      dstAvailableElementCount = Math.min(\n        sourceAvailableElementCount,\n        length || sourceAvailableElementCount\n      );\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n\n    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount);\n    dstData = dstData || new ArrayType(dstElementCount);\n\n    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, this.handle);\n    this.gl.getBufferSubData(GL.COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n    return dstData;\n  }\n\n  /**\n   * Binds a buffer to a given binding point (target).\n   *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n   *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n   *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n   *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n   */\n  bind({\n    target = this.target, // target for the bind operation\n    index = this.accessor && this.accessor.index, // index = index of target (indexed bind point)\n    offset = 0,\n    size\n  } = {}) {\n    // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n    // be used as direct binding points, they will not affect transform feedback or\n    // uniform buffer state. Instead indexed bindings need to be made.\n    if (target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER) {\n      if (size !== undefined) {\n        this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      } else {\n        assert(offset === 0); // Make sure offset wasn't supplied\n        this.gl.bindBufferBase(target, index, this.handle);\n      }\n    } else {\n      this.gl.bindBuffer(target, this.handle);\n    }\n\n    return this;\n  }\n\n  unbind({target = this.target, index = this.accessor && this.accessor.index} = {}) {\n    const isIndexedBuffer = target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER;\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n    return this;\n  }\n\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n\n  // Returns a short initial data array\n  getDebugData() {\n    if (!this.debugData) {\n      this.debugData = this.getData({length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)});\n      return {data: this.debugData, changed: true};\n    }\n    return {data: this.debugData, changed: false};\n  }\n\n  invalidateDebugData() {\n    this.debugData = null;\n  }\n\n  // PRIVATE METHODS\n\n  // Allocate a new buffer and initialize to contents of typed array\n  _setData(data, offset = 0, byteLength = data.byteLength + offset) {\n    assert(ArrayBuffer.isView(data));\n\n    this._trackDeallocatedMemory();\n\n    const target = this._getTarget();\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, byteLength, this.usage);\n    this.gl.bufferSubData(target, offset, data);\n    this.gl.bindBuffer(target, null);\n\n    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);\n    this.bytesUsed = byteLength;\n\n    this._trackAllocatedMemory(byteLength);\n\n    // infer GL type from supplied typed array\n    const type = getGLTypeFromTypedArray(data);\n    assert(type);\n    this.setAccessor(new Accessor(this.accessor, {type}));\n    return this;\n  }\n\n  // Allocate a GPU buffer of specified size.\n  _setByteLength(byteLength, usage = this.usage) {\n    assert(byteLength >= 0);\n\n    this._trackDeallocatedMemory();\n\n    // Workaround needed for Safari (#291):\n    // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.\n    let data = byteLength;\n    if (byteLength === 0) {\n      data = new Float32Array(0);\n    }\n\n    const target = this._getTarget();\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data, usage);\n    this.gl.bindBuffer(target, null);\n\n    this.usage = usage;\n    this.debugData = null;\n    this.bytesUsed = byteLength;\n\n    this._trackAllocatedMemory(byteLength);\n\n    return this;\n  }\n\n  // Binding a buffer for the first time locks the type\n  // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n  _getTarget() {\n    return this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n  }\n\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return this.getElementCount() - sourceElementOffset;\n  }\n\n  // Automatically infers type from typed array passed to setData\n  // Note: No longer that useful, since type is now autodeduced from the compiled shaders\n  _inferType(data) {\n    if (!this.accessor.type) {\n      this.setAccessor(new Accessor(this.accessor, {type: getGLTypeFromTypedArray(data)}));\n    }\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n    this._trackDeallocatedMemory();\n  }\n\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n\n  // DEPRECATIONS - v7.0\n  get type() {\n    log.deprecated('Buffer.type', 'Buffer.accessor.type')();\n    return this.accessor.type;\n  }\n\n  get bytes() {\n    log.deprecated('Buffer.bytes', 'Buffer.byteLength')();\n    return this.byteLength;\n  }\n\n  // DEPRECATIONS - v6.0\n  // Deprecated in v6.x, but not warnings not properly implemented\n  setByteLength(byteLength) {\n    log.deprecated('setByteLength', 'reallocate')();\n    return this.reallocate(byteLength);\n  }\n\n  // Deprecated in v6.x, but not warnings not properly implemented\n  updateAccessor(opts) {\n    log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();\n    this.accessor = new Accessor(this.accessor, opts);\n    return this;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}