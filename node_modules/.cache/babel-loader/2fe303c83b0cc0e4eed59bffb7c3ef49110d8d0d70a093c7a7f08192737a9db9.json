{"ast":null,"code":"import * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {\n      fp64,\n      IndexType = Uint32Array\n    } = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    });\n  }\n  get(attributeName) {\n    const {\n      attributes\n    } = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n    return attributes[attributeName];\n  }\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n      return normalizedPolygon;\n    }\n    return polygon;\n  }\n  getGeometrySize(polygon) {\n    if (isCut(polygon)) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    return null;\n  }\n  updateGeometryAttributes(polygon, context) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n  _updateIndices(polygon, _ref) {\n    let {\n      geometryIndex,\n      vertexStart: offset,\n      indexStart\n    } = _ref;\n    const {\n      attributes,\n      indexStarts,\n      typedArrayManager\n    } = this;\n    let target = attributes.indices;\n    if (!target || !polygon) {\n      return;\n    }\n    let i = indexStart;\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n  _updatePositions(polygon, _ref2) {\n    let {\n      vertexStart,\n      geometrySize\n    } = _ref2;\n    const {\n      attributes: {\n        positions\n      },\n      positionSize\n    } = this;\n    if (!positions || !polygon) {\n      return;\n    }\n    const polygonPositions = Polygon.getPositions(polygon);\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n  _updateVertexValid(polygon, _ref3) {\n    let {\n      vertexStart,\n      geometrySize\n    } = _ref3;\n    const {\n      positionSize\n    } = this;\n    const vertexValid = this.attributes.vertexValid;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\nfunction isCut(polygon) {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}","map":{"version":3,"names":["Polygon","Tesselator","cutPolygonByGrid","cutPolygonByMercatorBounds","PolygonTesselator","constructor","opts","fp64","IndexType","Uint32Array","attributes","positions","size","type","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","get","attributeName","subarray","vertexCount","updateGeometry","externalIndices","buffers","value","length","data","getGeometry","Error","normalizeGeometry","polygon","normalize","normalizedPolygon","positionSize","resolution","getPositions","getHoleIndices","gridResolution","edgeTypes","wrapLongitude","maxLatitude","getGeometrySize","isCut","subPolygon","getGeometryFromBuffer","buffer","updateGeometryAttributes","context","geometrySize","vertexStart","indexStart","indexStarts","geometryIndex","_updateIndices","_updatePositions","_updateVertexValid","_ref","offset","typedArrayManager","target","i","getSurfaceIndices","preproject","full3d","allocate","copy","j","_ref2","polygonPositions","x","y","z","_ref3","holeIndices","set","fill","Array","isArray","Number","isFinite"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js"],"sourcesContent":["import * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {\n      fp64,\n      IndexType = Uint32Array\n    } = opts;\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    const {\n      attributes\n    } = this;\n\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n    const externalIndices = this.buffers.indices;\n\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n\n      return normalizedPolygon;\n    }\n\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (isCut(polygon)) {\n      let size = 0;\n\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n\n      return size;\n    }\n\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  _updateIndices(polygon, {\n    geometryIndex,\n    vertexStart: offset,\n    indexStart\n  }) {\n    const {\n      attributes,\n      indexStarts,\n      typedArrayManager\n    } = this;\n    let target = attributes.indices;\n\n    if (!target || !polygon) {\n      return;\n    }\n\n    let i = indexStart;\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  _updatePositions(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      attributes: {\n        positions\n      },\n      positionSize\n    } = this;\n\n    if (!positions || !polygon) {\n      return;\n    }\n\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      positionSize\n    } = this;\n    const vertexValid = this.attributes.vertexValid;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n\n}\n\nfunction isCut(polygon) {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n//# sourceMappingURL=polygon-tesselator.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}