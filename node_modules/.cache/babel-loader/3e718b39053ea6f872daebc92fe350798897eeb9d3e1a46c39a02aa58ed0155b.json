{"ast":null,"code":"import { padArray } from '../../utils/array-utils';\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {\n      type: 'interpolation',\n      duration: userSettings\n    };\n  }\n  const type = userSettings.type || 'interpolation';\n  return {\n    ...DEFAULT_TRANSITION_SETTINGS[type],\n    ...layerSettings,\n    ...userSettings,\n    type\n  };\n}\nexport function getSourceBufferAttribute(gl, attribute) {\n  const buffer = attribute.getBuffer();\n  if (buffer) {\n    return [buffer, {\n      divisor: 0,\n      size: attribute.size,\n      normalized: attribute.settings.normalized\n    }];\n  }\n  return attribute.value;\n}\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(\"No defined attribute type for size \\\"\".concat(size, \"\\\"\"));\n  }\n}\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\nexport function getAttributeBufferLength(attribute, numInstances) {\n  const {\n    doublePrecision,\n    settings,\n    value,\n    size\n  } = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;\n}\nexport function padBuffer(_ref) {\n  let {\n    buffer,\n    numInstances,\n    attribute,\n    fromLength,\n    fromStartIndices,\n    getData = x => x\n  } = _ref;\n  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.isConstant;\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({\n    srcByteOffset: byteOffset\n  });\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n  const source = buffer.getData({\n    length: fromLength\n  });\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({\n    data,\n    offset: byteOffset\n  });\n}","map":{"version":3,"names":["padArray","DEFAULT_TRANSITION_SETTINGS","interpolation","duration","easing","t","spring","stiffness","damping","normalizeTransitionSettings","userSettings","layerSettings","Number","isFinite","type","getSourceBufferAttribute","gl","attribute","buffer","getBuffer","divisor","size","normalized","settings","value","getAttributeTypeFromSize","Error","concat","cycleBuffers","buffers","push","shift","getAttributeBufferLength","numInstances","doublePrecision","multiplier","Float64Array","noAlloc","length","padBuffer","_ref","fromLength","fromStartIndices","getData","x","precisionMultiplier","byteOffset","toStartIndices","startIndices","hasStartIndices","toLength","isConstant","toData","srcByteOffset","getter","chunk","normalizeConstant","getMissingData","i","subarray","source","data","Float32Array","target","sourceStartIndices","targetStartIndices","byteLength","reallocate","subData","offset"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/lib/attribute/attribute-transition-utils.ts"],"sourcesContent":["import {padArray} from '../../utils/array-utils';\nimport {NumericArray} from '../../types/types';\nimport Attribute from './attribute';\nimport type {BufferAccessor} from './data-column';\nimport type {Buffer} from '@luma.gl/webgl';\n\nexport interface TransitionSettings {\n  type: string;\n  /** Callback to get the value that the entering vertices are transitioning from. */\n  enter?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n  /** Callback when the transition is started */\n  onStart?: () => void;\n  /** Callback when the transition is done */\n  onEnd?: () => void;\n  /** Callback when the transition is interrupted */\n  onInterrupt?: () => void;\n}\n\nexport type InterpolationTransitionSettings = TransitionSettings & {\n  type?: 'interpolation';\n  /** Duration of the transition animation, in milliseconds */\n  duration: number;\n  /** Easing function that maps a value from [0, 1] to [0, 1], see [http://easings.net/](http://easings.net/) */\n  easing?: (t: number) => number;\n};\n\nexport type SpringTransitionSettings = TransitionSettings & {\n  type: 'spring';\n  /** \"Tension\" factor for the spring */\n  stiffness: number;\n  /** \"Friction\" factor that counteracts the spring's acceleration */\n  damping: number;\n};\n\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\n\nexport function normalizeTransitionSettings(\n  userSettings: number | InterpolationTransitionSettings | SpringTransitionSettings,\n  layerSettings?: boolean | Partial<TransitionSettings>\n): TransitionSettings | null {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {type: 'interpolation', duration: userSettings as number};\n  }\n  const type = (userSettings as TransitionSettings).type || 'interpolation';\n  return {\n    ...DEFAULT_TRANSITION_SETTINGS[type],\n    ...(layerSettings as TransitionSettings),\n    ...(userSettings as TransitionSettings),\n    type\n  };\n}\n\n// NOTE: NOT COPYING OVER OFFSET OR STRIDE HERE BECAUSE:\n// (1) WE DON'T SUPPORT INTERLEAVED BUFFERS FOR TRANSITIONS\n// (2) BUFFERS WITH OFFSETS ALWAYS CONTAIN VALUES OF THE SAME SIZE\n// (3) THE OPERATIONS IN THE SHADER ARE PER-COMPONENT (addition and scaling)\nexport function getSourceBufferAttribute(\n  gl: WebGLRenderingContext,\n  attribute: Attribute\n): [Buffer, BufferAccessor] | NumericArray {\n  // The Attribute we pass to Transform as a sourceBuffer must have {divisor: 0}\n  // so we create a copy of the attribute (with divisor=0) to use when running\n  // transform feedback\n  const buffer = attribute.getBuffer();\n  if (buffer) {\n    return [\n      buffer,\n      {\n        divisor: 0,\n        size: attribute.size,\n        normalized: attribute.settings.normalized\n      } as BufferAccessor\n    ];\n  }\n  // constant\n  // don't pass normalized here because the `value` from a normalized attribute is\n  // already normalized\n  return attribute.value as NumericArray;\n}\n\nexport function getAttributeTypeFromSize(size: number): string {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n\nexport function cycleBuffers(buffers: Buffer[]): void {\n  buffers.push(buffers.shift() as Buffer);\n}\n\nexport function getAttributeBufferLength(attribute: Attribute, numInstances: number): number {\n  const {doublePrecision, settings, value, size} = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? (value as NumericArray).length : numInstances * size) * multiplier;\n}\n\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\nexport function padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromStartIndices,\n  getData = x => x\n}: {\n  buffer: Buffer;\n  numInstances: number;\n  attribute: Attribute;\n  fromLength: number;\n  fromStartIndices?: NumericArray | null;\n  getData?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n}): void {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier =\n    attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.isConstant;\n\n  // check if buffer needs to be padded\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = isConstant\n    ? attribute.value\n    : (attribute.getBuffer() as Buffer).getData({srcByteOffset: byteOffset});\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant\n    ? (i, chunk) => getData(toData, chunk)\n    : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n\n  const source = buffer.getData({length: fromLength});\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  // TODO: support offset in buffer.setData?\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({data, offset: byteOffset});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}