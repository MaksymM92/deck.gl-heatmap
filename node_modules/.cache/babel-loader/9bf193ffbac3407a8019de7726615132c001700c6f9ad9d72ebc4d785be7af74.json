{"ast":null,"code":"import { isWebGL } from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport { Program, VertexArray, clear, TransformFeedback, Buffer, log, isObjectEmpty, uid, assert } from '@luma.gl/webgl';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\nexport default class Model {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      id = uid('model')\n    } = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.animated = false;\n    this.initialize(props);\n  }\n  initialize(props) {\n    this.props = {};\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n    this.userData = {};\n    this.needsRedraw = true;\n    this._attributes = {};\n    this.attributes = {};\n    this.uniforms = {};\n    this.pickable = true;\n    this._checkProgram();\n    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n    this.vertexCount = props.vertexCount || 0;\n    this.geometryBuffers = {};\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n    this._setModelProps(props);\n    this.geometry = {};\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n  setProps(props) {\n    this._setModelProps(props);\n  }\n  delete() {\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n    this.vertexArray.delete();\n    this._deleteGeometryBuffers();\n  }\n  getDrawMode() {\n    return this.drawMode;\n  }\n  getVertexCount() {\n    return this.vertexCount;\n  }\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n  getAttributes() {\n    return this.attributes;\n  }\n  getProgram() {\n    return this.program;\n  }\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n  getUniforms() {\n    return this.uniforms;\n  }\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n    this._deleteGeometryBuffers();\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n  setAttributes() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n  setUniforms() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.assign(this.uniforms, uniforms);\n    return this;\n  }\n  getModuleUniforms(opts) {\n    this._checkProgram();\n    const getUniforms = this.programManager.getUniforms(this.program);\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n    return {};\n  }\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n  draw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._checkProgram();\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n    let logPriority;\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n    const {\n      isInstanced,\n      instanceCount\n    } = this;\n    const {\n      onBeforeRender = NOOP,\n      onAfterRender = NOOP\n    } = this.props;\n    onBeforeRender();\n    this.program.setUniforms(this.uniforms);\n    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n      logPriority,\n      uniforms: null,\n      framebuffer,\n      parameters,\n      drawMode: this.getDrawMode(),\n      vertexCount: this.getVertexCount(),\n      vertexArray,\n      transformFeedback,\n      isIndexed,\n      indexType,\n      isInstanced,\n      instanceCount,\n      offset: isIndexed ? indexOffset : 0\n    }));\n    onAfterRender();\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n    return didDraw;\n  }\n  transform() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      discard = true,\n      feedbackBuffers,\n      unbindModels = []\n    } = opts;\n    let {\n      parameters\n    } = opts;\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n    if (discard) {\n      parameters = Object.assign({}, parameters, {\n        [35977]: discard\n      });\n    }\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {\n        parameters\n      }));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n    return this;\n  }\n  render() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n  _checkProgram() {\n    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n    if (!needsUpdate) {\n      return;\n    }\n    let {\n      program\n    } = this.programProps;\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n    assert(program instanceof Program, 'Model needs a program');\n    this._programDirty = false;\n    if (program === this.program) {\n      return;\n    }\n    this.program = program;\n    if (this.vertexArray) {\n      this.vertexArray.setProps({\n        program: this.program,\n        attributes: this.vertexArray.attributes\n      });\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {\n        program: this.program\n      });\n    }\n    this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n  }\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n    }\n  }\n  _setFeedbackBuffers() {\n    let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n    const {\n      gl\n    } = this.program;\n    this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n      program: this.program\n    });\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n    this.lastLogTime = Date.now();\n    log.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n      collapsed: log.level <= 2\n    })();\n    return logLevel;\n  }\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    if (logLevel === undefined) {\n      return;\n    }\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: \"\".concat(this.id, \" attributes\"),\n      attributes: this._attributes\n    });\n    const {\n      table: uniformTable,\n      unusedTable,\n      unusedCount\n    } = getDebugTableForUniforms({\n      header: \"\".concat(this.id, \" uniforms\"),\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n    const {\n      table: missingTable,\n      count: missingCount\n    } = getDebugTableForUniforms({\n      header: \"\".concat(this.id, \" uniforms\"),\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n    }\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n    log.table(logLevel, attributeTable)();\n    log.table(logLevel, uniformTable)();\n    log.table(logLevel + 1, configTable)();\n    if (framebuffer) {\n      framebuffer.log({\n        logLevel: LOG_DRAW_PRIORITY,\n        message: \"Rendered to \".concat(framebuffer.id)\n      });\n    }\n    log.groupEnd(LOG_DRAW_PRIORITY)();\n  }\n}","map":{"version":3,"names":["isWebGL","ProgramManager","Program","VertexArray","clear","TransformFeedback","Buffer","log","isObjectEmpty","uid","assert","getDebugTableForUniforms","getDebugTableForVertexArray","getDebugTableForProgramConfiguration","getBuffersFromGeometry","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","ERR_MODEL_PARAMS","NOOP","DRAW_PARAMS","Model","constructor","gl","props","arguments","length","undefined","id","lastLogTime","animated","initialize","programManager","getDefaultProgramManager","_programManagerState","_managedProgram","program","vs","fs","modules","defines","inject","varyings","bufferMode","transpileToGLSL100","programProps","vertexArray","_programDirty","userData","needsRedraw","_attributes","attributes","uniforms","pickable","_checkProgram","setUniforms","Object","assign","getModuleUniforms","moduleSettings","drawMode","vertexCount","geometryBuffers","isInstanced","instanced","instanceCount","_setModelProps","geometry","Number","isFinite","setProps","delete","key","release","_deleteGeometryBuffers","getDrawMode","getVertexCount","getInstanceCount","getAttributes","getProgram","setProgram","getUniforms","setDrawMode","setVertexCount","setInstanceCount","setGeometry","setAttributes","normalizedAttributes","name","attribute","getValue","opts","updateModuleSettings","draw","framebuffer","transformFeedback","parameters","logPriority","priority","_logDrawCallStart","drawParams","getDrawParams","isIndexed","indexType","indexOffset","vertexArrayInstanced","warn","onBeforeRender","onAfterRender","didDraw","offset","_logDrawCallEnd","transform","discard","feedbackBuffers","unbindModels","_setFeedbackBuffers","forEach","model","unbindBuffers","bindBuffers","render","_feedbackBuffers","needsUpdate","stateHash","get","buffer","_setAnimationProps","animationProps","setBuffers","logLevel","logDrawTimeout","Date","now","group","concat","collapsed","level","attributeTable","header","table","uniformTable","unusedTable","unusedCount","missingTable","count","missingCount","undefinedOnly","keys","configTable","configuration","message","groupEnd"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@luma.gl/engine/src/lib/model.js"],"sourcesContent":["/* eslint-disable complexity */\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL} from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport {\n  Program,\n  VertexArray,\n  clear,\n  TransformFeedback,\n  Buffer,\n  log,\n  isObjectEmpty,\n  uid,\n  assert\n} from '@luma.gl/webgl';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\n\nexport default class Model {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isInstanced, instanceCount} = this;\n\n    const {onBeforeRender = NOOP, onAfterRender = NOOP} = this.props;\n\n    onBeforeRender();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign(DRAW_PARAMS, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      // @ts-ignore TODO\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      // const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      // Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    // HACK: logLevel === undefined means logDrawCallStart didn't run\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      // @ts-ignore\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(logLevel, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(logLevel, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(logLevel, attributeTable)();\n\n    log.table(logLevel, uniformTable)();\n\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({logLevel: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY)();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}