{"ast":null,"code":"const INF = 1e20;\nexport default class TinySDF {\n  constructor() {\n    let {\n      fontSize = 24,\n      buffer = 3,\n      radius = 8,\n      cutoff = 0.25,\n      fontFamily = 'sans-serif',\n      fontWeight = 'normal',\n      fontStyle = 'normal'\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.buffer = buffer;\n    this.cutoff = cutoff;\n    this.radius = radius;\n\n    // make the canvas size big enough to both have the specified buffer around the glyph\n    // for \"halo\", and account for some glyphs possibly being larger than their font size\n    const size = this.size = fontSize + buffer * 4;\n    const canvas = this._createCanvas(size);\n    const ctx = this.ctx = canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n    ctx.textBaseline = 'alphabetic';\n    ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n    ctx.fillStyle = 'black';\n\n    // temporary arrays for the distance transform\n    this.gridOuter = new Float64Array(size * size);\n    this.gridInner = new Float64Array(size * size);\n    this.f = new Float64Array(size);\n    this.z = new Float64Array(size + 1);\n    this.v = new Uint16Array(size);\n  }\n  _createCanvas(size) {\n    const canvas = document.createElement('canvas');\n    canvas.width = canvas.height = size;\n    return canvas;\n  }\n  draw(char) {\n    const {\n      width: glyphAdvance,\n      actualBoundingBoxAscent,\n      actualBoundingBoxDescent,\n      actualBoundingBoxLeft,\n      actualBoundingBoxRight\n    } = this.ctx.measureText(char);\n\n    // The integer/pixel part of the top alignment is encoded in metrics.glyphTop\n    // The remainder is implicitly encoded in the rasterization\n    const glyphTop = Math.ceil(actualBoundingBoxAscent);\n    const glyphLeft = 0;\n\n    // If the glyph overflows the canvas size, it will be clipped at the bottom/right\n    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));\n    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));\n    const width = glyphWidth + 2 * this.buffer;\n    const height = glyphHeight + 2 * this.buffer;\n    const len = Math.max(width * height, 0);\n    const data = new Uint8ClampedArray(len);\n    const glyph = {\n      data,\n      width,\n      height,\n      glyphWidth,\n      glyphHeight,\n      glyphTop,\n      glyphLeft,\n      glyphAdvance\n    };\n    if (glyphWidth === 0 || glyphHeight === 0) return glyph;\n    const {\n      ctx,\n      buffer,\n      gridInner,\n      gridOuter\n    } = this;\n    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);\n    ctx.fillText(char, buffer, buffer + glyphTop);\n    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);\n\n    // Initialize grids outside the glyph range to alpha 0\n    gridOuter.fill(INF, 0, len);\n    gridInner.fill(0, 0, len);\n    for (let y = 0; y < glyphHeight; y++) {\n      for (let x = 0; x < glyphWidth; x++) {\n        const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n        if (a === 0) continue; // empty pixels\n\n        const j = (y + buffer) * width + x + buffer;\n        if (a === 1) {\n          // fully drawn pixels\n          gridOuter[j] = 0;\n          gridInner[j] = INF;\n        } else {\n          // aliased pixels\n          const d = 0.5 - a;\n          gridOuter[j] = d > 0 ? d * d : 0;\n          gridInner[j] = d < 0 ? d * d : 0;\n        }\n      }\n    }\n    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);\n    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);\n    for (let i = 0; i < len; i++) {\n      const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n      data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));\n    }\n    return glyph;\n  }\n}\n\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, x0, y0, width, height, gridSize, f, v, z) {\n  for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);\n  for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v, z);\n}\n\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = INF;\n  f[0] = grid[offset];\n  for (let q = 1, k = 0, s = 0; q < length; q++) {\n    f[q] = grid[offset + q * stride];\n    const q2 = q * q;\n    do {\n      const r = v[k];\n      s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;\n    } while (s <= z[k] && --k > -1);\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = INF;\n  }\n  for (let q = 0, k = 0; q < length; q++) {\n    while (z[k + 1] < q) k++;\n    const r = v[k];\n    const qr = q - r;\n    grid[offset + q * stride] = f[r] + qr * qr;\n  }\n}","map":{"version":3,"names":["INF","TinySDF","constructor","fontSize","buffer","radius","cutoff","fontFamily","fontWeight","fontStyle","arguments","length","undefined","size","canvas","_createCanvas","ctx","getContext","willReadFrequently","font","textBaseline","textAlign","fillStyle","gridOuter","Float64Array","gridInner","f","z","v","Uint16Array","document","createElement","width","height","draw","char","glyphAdvance","actualBoundingBoxAscent","actualBoundingBoxDescent","actualBoundingBoxLeft","actualBoundingBoxRight","measureText","glyphTop","Math","ceil","glyphLeft","glyphWidth","max","min","glyphHeight","len","data","Uint8ClampedArray","glyph","clearRect","fillText","imgData","getImageData","fill","y","x","a","j","d","edt","i","sqrt","round","x0","y0","gridSize","edt1d","grid","offset","stride","q","k","s","q2","r","qr"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@mapbox/tiny-sdf/index.js"],"sourcesContent":["const INF = 1e20;\n\nexport default class TinySDF {\n    constructor({\n        fontSize = 24,\n        buffer = 3,\n        radius = 8,\n        cutoff = 0.25,\n        fontFamily = 'sans-serif',\n        fontWeight = 'normal',\n        fontStyle = 'normal'\n    } = {}) {\n        this.buffer = buffer;\n        this.cutoff = cutoff;\n        this.radius = radius;\n\n        // make the canvas size big enough to both have the specified buffer around the glyph\n        // for \"halo\", and account for some glyphs possibly being larger than their font size\n        const size = this.size = fontSize + buffer * 4;\n\n        const canvas = this._createCanvas(size);\n        const ctx = this.ctx = canvas.getContext('2d', {willReadFrequently: true});\n        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n\n        ctx.textBaseline = 'alphabetic';\n        ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n        ctx.fillStyle = 'black';\n\n        // temporary arrays for the distance transform\n        this.gridOuter = new Float64Array(size * size);\n        this.gridInner = new Float64Array(size * size);\n        this.f = new Float64Array(size);\n        this.z = new Float64Array(size + 1);\n        this.v = new Uint16Array(size);\n    }\n\n    _createCanvas(size) {\n        const canvas = document.createElement('canvas');\n        canvas.width = canvas.height = size;\n        return canvas;\n    }\n\n    draw(char) {\n        const {\n            width: glyphAdvance,\n            actualBoundingBoxAscent,\n            actualBoundingBoxDescent,\n            actualBoundingBoxLeft,\n            actualBoundingBoxRight\n        } = this.ctx.measureText(char);\n\n        // The integer/pixel part of the top alignment is encoded in metrics.glyphTop\n        // The remainder is implicitly encoded in the rasterization\n        const glyphTop = Math.ceil(actualBoundingBoxAscent);\n        const glyphLeft = 0;\n\n        // If the glyph overflows the canvas size, it will be clipped at the bottom/right\n        const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));\n        const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));\n\n        const width = glyphWidth + 2 * this.buffer;\n        const height = glyphHeight + 2 * this.buffer;\n\n        const len = Math.max(width * height, 0);\n        const data = new Uint8ClampedArray(len);\n        const glyph = {data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance};\n        if (glyphWidth === 0 || glyphHeight === 0) return glyph;\n\n        const {ctx, buffer, gridInner, gridOuter} = this;\n        ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);\n        ctx.fillText(char, buffer, buffer + glyphTop);\n        const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);\n\n        // Initialize grids outside the glyph range to alpha 0\n        gridOuter.fill(INF, 0, len);\n        gridInner.fill(0, 0, len);\n\n        for (let y = 0; y < glyphHeight; y++) {\n            for (let x = 0; x < glyphWidth; x++) {\n                const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n                if (a === 0) continue; // empty pixels\n\n                const j = (y + buffer) * width + x + buffer;\n\n                if (a === 1) { // fully drawn pixels\n                    gridOuter[j] = 0;\n                    gridInner[j] = INF;\n\n                } else { // aliased pixels\n                    const d = 0.5 - a;\n                    gridOuter[j] = d > 0 ? d * d : 0;\n                    gridInner[j] = d < 0 ? d * d : 0;\n                }\n            }\n        }\n\n        edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);\n        edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);\n\n        for (let i = 0; i < len; i++) {\n            const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n            data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));\n        }\n\n        return glyph;\n    }\n}\n\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, x0, y0, width, height, gridSize, f, v, z) {\n    for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);\n    for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v, z);\n}\n\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n    v[0] = 0;\n    z[0] = -INF;\n    z[1] = INF;\n    f[0] = grid[offset];\n\n    for (let q = 1, k = 0, s = 0; q < length; q++) {\n        f[q] = grid[offset + q * stride];\n        const q2 = q * q;\n        do {\n            const r = v[k];\n            s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;\n        } while (s <= z[k] && --k > -1);\n\n        k++;\n        v[k] = q;\n        z[k] = s;\n        z[k + 1] = INF;\n    }\n\n    for (let q = 0, k = 0; q < length; q++) {\n        while (z[k + 1] < q) k++;\n        const r = v[k];\n        const qr = q - r;\n        grid[offset + q * stride] = f[r] + qr * qr;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}