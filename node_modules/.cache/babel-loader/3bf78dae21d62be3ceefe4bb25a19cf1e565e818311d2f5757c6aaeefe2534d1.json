{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, createIterable, log } from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, { DEFAULT_FONT_SETTINGS, setFontAtlasCacheLimit } from './font-atlas-manager';\nimport { transformParagraph, getTextFromBuffer } from './utils';\nimport TextBackgroundLayer from './text-background-layer/text-background-layer';\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_LINE_HEIGHT = 1.0;\nconst defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  background: false,\n  getBackgroundColor: {\n    type: 'accessor',\n    value: [255, 255, 255, 255]\n  },\n  getBorderColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getBorderWidth: {\n    type: 'accessor',\n    value: 0\n  },\n  backgroundPadding: {\n    type: 'array',\n    value: [0, 0, 0, 0]\n  },\n  characterSet: {\n    type: 'object',\n    value: DEFAULT_FONT_SETTINGS.characterSet\n  },\n  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,\n  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  outlineWidth: {\n    type: 'number',\n    value: 0,\n    min: 0\n  },\n  outlineColor: {\n    type: 'color',\n    value: DEFAULT_COLOR\n  },\n  fontSettings: {\n    type: 'object',\n    value: {},\n    compare: 1\n  },\n  wordBreak: 'break-word',\n  maxWidth: {\n    type: 'number',\n    value: -1\n  },\n  getText: {\n    type: 'accessor',\n    value: x => x.text\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 32\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getTextAnchor: {\n    type: 'accessor',\n    value: 'middle'\n  },\n  getAlignmentBaseline: {\n    type: 'accessor',\n    value: 'center'\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  backgroundColor: {\n    deprecatedFor: ['background', 'getBackgroundColor']\n  }\n};\nexport default class TextLayer extends CompositeLayer {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", void 0);\n    _defineProperty(this, \"getBoundingRect\", (object, objectInfo) => {\n      let {\n        size: [width, height]\n      } = this.transformParagraph(object, objectInfo);\n      const {\n        fontSize\n      } = this.state.fontAtlasManager.props;\n      width /= fontSize;\n      height /= fontSize;\n      const {\n        getTextAnchor,\n        getAlignmentBaseline\n      } = this.props;\n      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];\n    });\n    _defineProperty(this, \"getIconOffsets\", (object, objectInfo) => {\n      const {\n        getTextAnchor,\n        getAlignmentBaseline\n      } = this.props;\n      const {\n        x,\n        y,\n        rowWidth,\n        size: [width, height]\n      } = this.transformParagraph(object, objectInfo);\n      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      const numCharacters = x.length;\n      const offsets = new Array(numCharacters * 2);\n      let index = 0;\n      for (let i = 0; i < numCharacters; i++) {\n        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;\n        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];\n        offsets[index++] = (anchorY - 1) * height / 2 + y[i];\n      }\n      return offsets;\n    });\n  }\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager()\n    };\n    if (this.props.maxWidth > 0) {\n      log.warn('v8.9 breaking change: TextLayer maxWidth is now relative to text size')();\n    }\n  }\n  updateState(params) {\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);\n    if (textChanged) {\n      this._updateText();\n    }\n    const fontChanged = this._updateFontAtlas();\n    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n  getPickingInfo(_ref) {\n    let {\n      info\n    } = _ref;\n    info.object = info.index >= 0 ? this.props.data[info.index] : null;\n    return info;\n  }\n  _updateFontAtlas() {\n    const {\n      fontSettings,\n      fontFamily,\n      fontWeight\n    } = this.props;\n    const {\n      fontAtlasManager,\n      characterSet\n    } = this.state;\n    const fontProps = {\n      ...fontSettings,\n      characterSet,\n      fontFamily,\n      fontWeight\n    };\n    if (!fontAtlasManager.mapping) {\n      fontAtlasManager.setProps(fontProps);\n      return true;\n    }\n    for (const key in fontProps) {\n      if (fontProps[key] !== fontAtlasManager.props[key]) {\n        fontAtlasManager.setProps(fontProps);\n        return true;\n      }\n    }\n    return false;\n  }\n  _updateText() {\n    var _attributes;\n    const {\n      data,\n      characterSet\n    } = this.props;\n    const textBuffer = (_attributes = data.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;\n    let {\n      getText\n    } = this.props;\n    let startIndices = data.startIndices;\n    let numInstances;\n    const autoCharacterSet = characterSet === 'auto' && new Set();\n    if (textBuffer && startIndices) {\n      const {\n        texts,\n        characterCount\n      } = getTextFromBuffer({\n        ...(ArrayBuffer.isView(textBuffer) ? {\n          value: textBuffer\n        } : textBuffer),\n        length: data.length,\n        startIndices,\n        characterSet: autoCharacterSet\n      });\n      numInstances = characterCount;\n      getText = (_, _ref2) => {\n        let {\n          index\n        } = _ref2;\n        return texts[index];\n      };\n    } else {\n      const {\n        iterable,\n        objectInfo\n      } = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n      for (const object of iterable) {\n        objectInfo.index++;\n        const text = Array.from(getText(object, objectInfo) || '');\n        if (autoCharacterSet) {\n          text.forEach(autoCharacterSet.add, autoCharacterSet);\n        }\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n    this.setState({\n      getText,\n      startIndices,\n      numInstances,\n      characterSet: autoCharacterSet || characterSet\n    });\n  }\n  transformParagraph(object, objectInfo) {\n    const {\n      fontAtlasManager\n    } = this.state;\n    const iconMapping = fontAtlasManager.mapping;\n    const getText = this.state.getText;\n    const {\n      wordBreak,\n      lineHeight,\n      maxWidth\n    } = this.props;\n    const paragraph = getText(object, objectInfo) || '';\n    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);\n  }\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {\n        scale,\n        texture,\n        mapping\n      },\n      styleVersion\n    } = this.state;\n    const {\n      data,\n      _dataDiff,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      getBackgroundColor,\n      getBorderColor,\n      getBorderWidth,\n      backgroundPadding,\n      background,\n      billboard,\n      fontSettings,\n      outlineWidth,\n      outlineColor,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n    const CharactersLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n    const BackgroundLayerClass = this.getSubLayerClass('background', TextBackgroundLayer);\n    return [background && new BackgroundLayerClass({\n      getFillColor: getBackgroundColor,\n      getLineColor: getBorderColor,\n      getLineWidth: getBorderWidth,\n      padding: backgroundPadding,\n      getPosition,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions: transitions && {\n        getPosition: transitions.getPosition,\n        getAngle: transitions.getAngle,\n        getSize: transitions.getSize,\n        getFillColor: transitions.getBackgroundColor,\n        getLineColor: transitions.getBorderColor,\n        getLineWidth: transitions.getBorderWidth,\n        getPixelOffset: transitions.getPixelOffset\n      }\n    }, this.getSubLayerProps({\n      id: 'background',\n      updateTriggers: {\n        getPosition: updateTriggers.getPosition,\n        getAngle: updateTriggers.getAngle,\n        getSize: updateTriggers.getSize,\n        getFillColor: updateTriggers.getBackgroundColor,\n        getLineColor: updateTriggers.getBorderColor,\n        getLineWidth: updateTriggers.getBorderWidth,\n        getPixelOffset: updateTriggers.getPixelOffset,\n        getBoundingRect: {\n          getText: updateTriggers.getText,\n          getTextAnchor: updateTriggers.getTextAnchor,\n          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n          styleVersion\n        }\n      }\n    }), {\n      data: data.attributes && data.attributes.background ? {\n        length: data.length,\n        attributes: data.attributes.background\n      } : data,\n      _dataDiff,\n      autoHighlight: false,\n      getBoundingRect: this.getBoundingRect\n    }), new CharactersLayerClass({\n      sdf: fontSettings.sdf,\n      smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,\n      outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),\n      outlineColor,\n      iconAtlas: texture,\n      iconMapping: mapping,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sizeScale: sizeScale * scale,\n      sizeUnits,\n      sizeMinPixels: sizeMinPixels * scale,\n      sizeMaxPixels: sizeMaxPixels * scale,\n      transitions: transitions && {\n        getPosition: transitions.getPosition,\n        getAngle: transitions.getAngle,\n        getColor: transitions.getColor,\n        getSize: transitions.getSize,\n        getPixelOffset: transitions.getPixelOffset\n      }\n    }, this.getSubLayerProps({\n      id: 'characters',\n      updateTriggers: {\n        getIcon: updateTriggers.getText,\n        getPosition: updateTriggers.getPosition,\n        getAngle: updateTriggers.getAngle,\n        getColor: updateTriggers.getColor,\n        getSize: updateTriggers.getSize,\n        getPixelOffset: updateTriggers.getPixelOffset,\n        getIconOffsets: {\n          getText: updateTriggers.getText,\n          getTextAnchor: updateTriggers.getTextAnchor,\n          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n          styleVersion\n        }\n      }\n    }), {\n      data,\n      _dataDiff,\n      startIndices,\n      numInstances,\n      getIconOffsets: this.getIconOffsets,\n      getIcon: getText\n    })];\n  }\n  static set fontAtlasCacheLimit(limit) {\n    setFontAtlasCacheLimit(limit);\n  }\n}\n_defineProperty(TextLayer, \"defaultProps\", defaultProps);\n_defineProperty(TextLayer, \"layerName\", 'TextLayer');","map":{"version":3,"names":["CompositeLayer","createIterable","log","MultiIconLayer","FontAtlasManager","DEFAULT_FONT_SETTINGS","setFontAtlasCacheLimit","transformParagraph","getTextFromBuffer","TextBackgroundLayer","TEXT_ANCHOR","start","middle","end","ALIGNMENT_BASELINE","top","center","bottom","DEFAULT_COLOR","DEFAULT_LINE_HEIGHT","defaultProps","billboard","sizeScale","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","background","getBackgroundColor","type","value","getBorderColor","getBorderWidth","backgroundPadding","characterSet","fontFamily","fontWeight","lineHeight","outlineWidth","min","outlineColor","fontSettings","compare","wordBreak","maxWidth","getText","x","text","getPosition","position","getColor","getSize","getAngle","getTextAnchor","getAlignmentBaseline","getPixelOffset","backgroundColor","deprecatedFor","TextLayer","constructor","arguments","_defineProperty","object","objectInfo","size","width","height","fontSize","state","fontAtlasManager","props","anchorX","anchorY","y","rowWidth","numCharacters","length","offsets","Array","index","i","rowOffset","initializeState","styleVersion","warn","updateState","params","oldProps","changeFlags","textChanged","dataChanged","updateTriggersChanged","all","_updateText","fontChanged","_updateFontAtlas","styleChanged","setState","getPickingInfo","_ref","info","data","fontProps","mapping","setProps","key","_attributes","textBuffer","attributes","startIndices","numInstances","autoCharacterSet","Set","texts","characterCount","ArrayBuffer","isView","_","_ref2","iterable","from","forEach","add","push","iconMapping","paragraph","renderLayers","scale","texture","_dataDiff","transitions","updateTriggers","CharactersLayerClass","getSubLayerClass","BackgroundLayerClass","getFillColor","getLineColor","getLineWidth","padding","getSubLayerProps","id","getBoundingRect","autoHighlight","sdf","smoothing","isFinite","radius","iconAtlas","getIcon","getIconOffsets","fontAtlasCacheLimit","limit"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/layers/src/text-layer/text-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, createIterable, log} from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, {\n  DEFAULT_FONT_SETTINGS,\n  setFontAtlasCacheLimit\n} from './font-atlas-manager';\nimport {transformParagraph, getTextFromBuffer} from './utils';\n\nimport TextBackgroundLayer from './text-background-layer/text-background-layer';\n\nimport type {FontSettings} from './font-atlas-manager';\nimport type {\n  LayerProps,\n  LayerDataSource,\n  Accessor,\n  AccessorFunction,\n  AccessorContext,\n  Unit,\n  Position,\n  Color,\n  UpdateParameters,\n  GetPickingInfoParams,\n  PickingInfo,\n  DefaultProps\n} from '@deck.gl/core';\n\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n} as const;\n\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n} as const;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst DEFAULT_LINE_HEIGHT = 1.0;\n\ntype _TextLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /** If `true`, the text always faces camera. Otherwise the text faces up (z).\n   * @default true\n   */\n  billboard?: boolean;\n  /**\n   * Text size multiplier.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The units of the size, one of `'meters'`, `'common'`, and `'pixels'`.\n   * @default 'pixels'\n   */\n  sizeUnits?: Unit;\n  /**\n   * The minimum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too small when zoomed out.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too big when zoomed in.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n\n  /** Whether to render background for the text blocks.\n   * @default false\n   */\n  background?: boolean;\n  /** Background color accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getBackgroundColor?: Accessor<DataT, Color>;\n  /** Border color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getBorderColor?: Accessor<DataT, Color>;\n  /** Border width accessor.\n   * @default 0\n   */\n  getBorderWidth?: Accessor<DataT, number>;\n  /**\n   * The padding of the background..\n   * If an array of 2 is supplied, it is interpreted as `[padding_x, padding_y]` in pixels.\n   * If an array of 4 is supplied, it is interpreted as `[padding_left, padding_top, padding_right, padding_bottom]` in pixels.\n   * @default [0, 0, 0, 0]\n   */\n  backgroundPadding?: [number, number] | [number, number, number, number];\n  /**\n   * Specifies a list of characters to include in the font. If set to 'auto', will be automatically generated from the data set.\n   * @default (ASCII characters 32-128)\n   */\n  characterSet?: FontSettings['characterSet'] | 'auto';\n  /** CSS font family\n   * @default 'Monaco, monospace'\n   */\n  fontFamily?: FontSettings['fontFamily'];\n  /** CSS font weight\n   * @default 'normal'\n   */\n  fontWeight?: FontSettings['fontWeight'];\n  /** A unitless number that will be multiplied with the current text size to set the line height.\n   * @default 'normal'\n   */\n  lineHeight?: number;\n  /**\n   * Width of outline around the text, relative to the text size. Only effective if `fontSettings.sdf` is `true`.\n   * @default 0\n   */\n  outlineWidth?: number;\n  /**\n   * Color of outline around the text, in `[r, g, b, [a]]`. Each channel is a number between 0-255 and `a` is 255 if not supplied.\n   * @default [0, 0, 0, 255]\n   */\n  outlineColor?: Color;\n  /**\n   * Advance options for fine tuning the appearance and performance of the generated shared `fontAtlas`.\n   */\n  fontSettings?: FontSettings;\n  /**\n   * Available options are `break-all` and `break-word`. A valid `maxWidth` has to be provided to use `wordBreak`.\n   * @default 'break-word'\n   */\n  wordBreak?: 'break-word' | 'break-all';\n  /**\n   * A unitless number that will be multiplied with the current text size to set the width limit of a string.\n   * If specified, when the text is longer than the width limit, it will be wrapped into multiple lines using\n   * the strategy of `wordBreak`.\n   * @default -1\n   */\n  maxWidth?: number;\n  /**\n   * Label text accessor\n   */\n  getText?: AccessorFunction<DataT, string>;\n  /**\n   * Anchor position accessor\n   */\n  getPosition?: Accessor<DataT, Position>;\n  /**\n   * Label color accessor\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Label size accessor\n   * @default 32\n   */\n  getSize?: Accessor<DataT, number>;\n  /**\n   * Label rotation accessor, in degrees\n   * @default 0\n   */\n  getAngle?: Accessor<DataT, number>;\n  /**\n   * Horizontal alignment accessor\n   * @default 'middle'\n   */\n  getTextAnchor?: Accessor<DataT, 'start' | 'middle' | 'end'>;\n  /**\n   * Vertical alignment accessor\n   * @default 'center'\n   */\n  getAlignmentBaseline?: Accessor<DataT, 'top' | 'center' | 'bottom'>;\n  /**\n   * Label offset from the anchor position, [x, y] in pixels\n   * @default [0, 0]\n   */\n  getPixelOffset?: Accessor<DataT, [number, number]>;\n  /**\n   * @deprecated Use `background` and `getBackgroundColor` instead\n   */\n  backgroundColor?: Color;\n};\n\nexport type TextLayerProps<DataT = any> = _TextLayerProps<DataT> & LayerProps;\n\nconst defaultProps: DefaultProps<TextLayerProps> = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n\n  background: false,\n  getBackgroundColor: {type: 'accessor', value: [255, 255, 255, 255]},\n  getBorderColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getBorderWidth: {type: 'accessor', value: 0},\n  backgroundPadding: {type: 'array', value: [0, 0, 0, 0]},\n\n  characterSet: {type: 'object', value: DEFAULT_FONT_SETTINGS.characterSet},\n  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,\n  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  outlineWidth: {type: 'number', value: 0, min: 0},\n  outlineColor: {type: 'color', value: DEFAULT_COLOR},\n  fontSettings: {type: 'object', value: {}, compare: 1},\n\n  // auto wrapping options\n  wordBreak: 'break-word',\n  maxWidth: {type: 'number', value: -1},\n\n  getText: {type: 'accessor', value: x => x.text},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 32},\n  getAngle: {type: 'accessor', value: 0},\n  getTextAnchor: {type: 'accessor', value: 'middle'},\n  getAlignmentBaseline: {type: 'accessor', value: 'center'},\n  getPixelOffset: {type: 'accessor', value: [0, 0]},\n\n  // deprecated\n  backgroundColor: {deprecatedFor: ['background', 'getBackgroundColor']}\n};\n\n/** Render text labels at given coordinates. */\nexport default class TextLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_TextLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'TextLayer';\n\n  state!: {\n    styleVersion: number;\n    fontAtlasManager: FontAtlasManager;\n    characterSet?: Set<string>;\n    startIndices?: number[];\n    numInstances?: number;\n    getText?: AccessorFunction<DataT, string>;\n  };\n\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager()\n    };\n\n    // Breaking change in v8.9\n    if (this.props.maxWidth > 0) {\n      log.warn('v8.9 breaking change: TextLayer maxWidth is now relative to text size')();\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  updateState(params: UpdateParameters<this>) {\n    const {props, oldProps, changeFlags} = params;\n    const textChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText));\n\n    if (textChanged) {\n      this._updateText();\n    }\n\n    const fontChanged = this._updateFontAtlas();\n\n    const styleChanged =\n      fontChanged ||\n      props.lineHeight !== oldProps.lineHeight ||\n      props.wordBreak !== oldProps.wordBreak ||\n      props.maxWidth !== oldProps.maxWidth;\n\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    // because `TextLayer` assign the same pickingInfoIndex for one text label,\n    // here info.index refers the index of text label in props.data\n    info.object = info.index >= 0 ? this.props.data[info.index] : null;\n    return info;\n  }\n\n  /** Returns true if font has changed */\n  private _updateFontAtlas(): boolean {\n    const {fontSettings, fontFamily, fontWeight} = this.props;\n    const {fontAtlasManager, characterSet} = this.state;\n\n    const fontProps = {\n      ...fontSettings,\n      characterSet,\n      fontFamily,\n      fontWeight\n    };\n\n    if (!fontAtlasManager.mapping) {\n      // This is the first update\n      fontAtlasManager.setProps(fontProps);\n      return true;\n    }\n\n    for (const key in fontProps) {\n      if (fontProps[key] !== fontAtlasManager.props[key]) {\n        fontAtlasManager.setProps(fontProps);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Text strings are variable width objects\n  // Count characters and start offsets\n  private _updateText() {\n    const {data, characterSet} = this.props;\n    const textBuffer = (data as any).attributes?.getText;\n    let {getText} = this.props;\n    let startIndices: number[] = (data as any).startIndices;\n    let numInstances: number;\n\n    const autoCharacterSet = characterSet === 'auto' && new Set();\n\n    if (textBuffer && startIndices) {\n      const {texts, characterCount} = getTextFromBuffer({\n        ...(ArrayBuffer.isView(textBuffer) ? {value: textBuffer} : textBuffer),\n        // @ts-ignore if data.attribute is defined then length is expected\n        length: data.length,\n        startIndices,\n        characterSet: autoCharacterSet\n      });\n      numInstances = characterCount;\n      getText = (_, {index}) => texts[index];\n    } else {\n      const {iterable, objectInfo} = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        // Break into an array of characters\n        // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n        const text = Array.from(getText(object, objectInfo) || '');\n        if (autoCharacterSet) {\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          text.forEach(autoCharacterSet.add, autoCharacterSet);\n        }\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({\n      getText,\n      startIndices,\n      numInstances,\n      characterSet: autoCharacterSet || characterSet\n    });\n  }\n\n  /** There are two size systems in this layer:\n\n    + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.\n      The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2 \n      in layer props is roughly equivalent to font-size: 24px in CSS.\n    + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,\n      which depends on how large each character is drawn into the font atlas. This is controlled by\n      fontSettings.fontSize (default 64) and most users do not set it manually.\n      These numbers are intended to be used in the vertex shader and never to be exposed to the end user.\n    \n    All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */\n\n  /** Calculate the size and position of each character in a text string.\n   * Values are in texture size */\n  private transformParagraph(\n    object: DataT,\n    objectInfo: AccessorContext<DataT>\n  ): ReturnType<typeof transformParagraph> {\n    const {fontAtlasManager} = this.state;\n    const iconMapping = fontAtlasManager.mapping!;\n    const getText = this.state.getText!;\n    const {wordBreak, lineHeight, maxWidth} = this.props;\n\n    const paragraph = getText(object, objectInfo) || '';\n    return transformParagraph(\n      paragraph,\n      lineHeight,\n      wordBreak,\n      maxWidth * fontAtlasManager.props.fontSize,\n      iconMapping\n    );\n  }\n\n  /** Returns the x, y, width, height of each text string, relative to pixel size.\n   * Used to render the background.\n   */\n  private getBoundingRect: AccessorFunction<DataT, [number, number, number, number]> = (\n    object,\n    objectInfo\n  ) => {\n    let {\n      size: [width, height]\n    } = this.transformParagraph(object, objectInfo);\n    const {fontSize} = this.state.fontAtlasManager.props;\n    width /= fontSize;\n    height /= fontSize;\n\n    const {getTextAnchor, getAlignmentBaseline} = this.props;\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    return [((anchorX - 1) * width) / 2, ((anchorY - 1) * height) / 2, width, height];\n  };\n\n  /** Returns the x, y offsets of each character in a text string, in texture size.\n   * Used to layout characters in the vertex shader.\n   */\n  private getIconOffsets: AccessorFunction<DataT, number[]> = (object, objectInfo) => {\n    const {getTextAnchor, getAlignmentBaseline} = this.props;\n\n    const {\n      x,\n      y,\n      rowWidth,\n      size: [width, height]\n    } = this.transformParagraph(object, objectInfo);\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    const numCharacters = x.length;\n    const offsets = new Array(numCharacters * 2);\n    let index = 0;\n\n    for (let i = 0; i < numCharacters; i++) {\n      // For a multi-line object, offset in x-direction needs consider\n      // the row offset in the paragraph and the object offset in the row\n      const rowOffset = ((1 - anchorX) * (width - rowWidth[i])) / 2;\n      offsets[index++] = ((anchorX - 1) * width) / 2 + rowOffset + x[i];\n      offsets[index++] = ((anchorY - 1) * height) / 2 + y[i];\n    }\n    return offsets;\n  };\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {scale, texture, mapping},\n      styleVersion\n    } = this.state;\n\n    const {\n      data,\n      _dataDiff,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      getBackgroundColor,\n      getBorderColor,\n      getBorderWidth,\n      backgroundPadding,\n      background,\n      billboard,\n      fontSettings,\n      outlineWidth,\n      outlineColor,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    const CharactersLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n    const BackgroundLayerClass = this.getSubLayerClass('background', TextBackgroundLayer);\n\n    return [\n      background &&\n        new BackgroundLayerClass(\n          {\n            // background props\n            getFillColor: getBackgroundColor,\n            getLineColor: getBorderColor,\n            getLineWidth: getBorderWidth,\n            padding: backgroundPadding,\n\n            // props shared with characters layer\n            getPosition,\n            getSize,\n            getAngle,\n            getPixelOffset,\n            billboard,\n            sizeScale,\n            sizeUnits,\n            sizeMinPixels,\n            sizeMaxPixels,\n\n            transitions: transitions && {\n              getPosition: transitions.getPosition,\n              getAngle: transitions.getAngle,\n              getSize: transitions.getSize,\n              getFillColor: transitions.getBackgroundColor,\n              getLineColor: transitions.getBorderColor,\n              getLineWidth: transitions.getBorderWidth,\n              getPixelOffset: transitions.getPixelOffset\n            }\n          },\n          this.getSubLayerProps({\n            id: 'background',\n            updateTriggers: {\n              getPosition: updateTriggers.getPosition,\n              getAngle: updateTriggers.getAngle,\n              getSize: updateTriggers.getSize,\n              getFillColor: updateTriggers.getBackgroundColor,\n              getLineColor: updateTriggers.getBorderColor,\n              getLineWidth: updateTriggers.getBorderWidth,\n              getPixelOffset: updateTriggers.getPixelOffset,\n              getBoundingRect: {\n                getText: updateTriggers.getText,\n                getTextAnchor: updateTriggers.getTextAnchor,\n                getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n                styleVersion\n              }\n            }\n          }),\n          {\n            data:\n              // @ts-ignore (2339) attribute is not defined on all data types\n              data.attributes && data.attributes.background\n                ? // @ts-ignore (2339) attribute is not defined on all data types\n                  {length: data.length, attributes: data.attributes.background}\n                : data,\n            _dataDiff,\n            // Maintain the same background behavior as <=8.3. Remove in v9?\n            autoHighlight: false,\n            getBoundingRect: this.getBoundingRect\n          }\n        ),\n      new CharactersLayerClass(\n        {\n          sdf: fontSettings.sdf,\n          smoothing: Number.isFinite(fontSettings.smoothing)\n            ? fontSettings.smoothing\n            : DEFAULT_FONT_SETTINGS.smoothing,\n          outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),\n          outlineColor,\n          iconAtlas: texture,\n          iconMapping: mapping,\n\n          getPosition,\n          getColor,\n          getSize,\n          getAngle,\n          getPixelOffset,\n\n          billboard,\n          sizeScale: sizeScale * scale,\n          sizeUnits,\n          sizeMinPixels: sizeMinPixels * scale,\n          sizeMaxPixels: sizeMaxPixels * scale,\n\n          transitions: transitions && {\n            getPosition: transitions.getPosition,\n            getAngle: transitions.getAngle,\n            getColor: transitions.getColor,\n            getSize: transitions.getSize,\n            getPixelOffset: transitions.getPixelOffset\n          }\n        },\n        this.getSubLayerProps({\n          id: 'characters',\n          updateTriggers: {\n            getIcon: updateTriggers.getText,\n            getPosition: updateTriggers.getPosition,\n            getAngle: updateTriggers.getAngle,\n            getColor: updateTriggers.getColor,\n            getSize: updateTriggers.getSize,\n            getPixelOffset: updateTriggers.getPixelOffset,\n            getIconOffsets: {\n              getText: updateTriggers.getText,\n              getTextAnchor: updateTriggers.getTextAnchor,\n              getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n              styleVersion\n            }\n          }\n        }),\n        {\n          data,\n          _dataDiff,\n          startIndices,\n          numInstances,\n          getIconOffsets: this.getIconOffsets,\n          getIcon: getText\n        }\n      )\n    ];\n  }\n\n  static set fontAtlasCacheLimit(limit: number) {\n    setFontAtlasCacheLimit(limit);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}