{"ast":null,"code":"function testVariable(qualifier) {\n  return new RegExp(\"\\\\b\".concat(qualifier, \"[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)\"), 'g');\n}\nconst ES300_REPLACEMENTS = [[/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'], [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('], [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']];\nconst ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('attribute'), 'in $1'], [testVariable('varying'), 'out $1']];\nconst ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('varying'), 'in $1']];\nconst ES100_REPLACEMENTS = [[/^#version[ \\t]+300[ \\t]+es/, '#version 100'], [/\\btexture(2D|2DProj|Cube)Lod\\(/g, 'texture$1LodEXT('], [/\\btexture\\(/g, 'texture2D('], [/\\btextureLod\\(/g, 'texture2DLodEXT(']];\nconst ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'attribute $1'], [testVariable('out'), 'varying $1']];\nconst ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'varying $1']];\nconst ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';\nconst ES300_FRAGMENT_OUTPUT_REGEX = /\\bout[ \\t]+vec4[ \\t]+(\\w+)[ \\t]*;\\n?/;\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/;\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(\"unknown GLSL version \".concat(targetGLSLVersion));\n  }\n}\nfunction convertShader(source, replacements) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\nfunction convertFragmentShaderTo300(source) {\n  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source.replace(new RegExp(\"\\\\b\".concat(ES100_FRAGMENT_OUTPUT_NAME, \"\\\\b\"), 'g'), outputName);\n  } else {\n    const outputName = 'fragmentColor';\n    source = source.replace(REGEX_START_OF_MAIN, match => \"out vec4 \".concat(outputName, \";\\n\").concat(match)).replace(new RegExp(\"\\\\b\".concat(ES100_FRAGMENT_OUTPUT_NAME, \"\\\\b\"), 'g'), outputName);\n  }\n  return source;\n}\nfunction convertFragmentShaderTo100(source) {\n  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);\n  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, '').replace(new RegExp(\"\\\\b\".concat(outputName, \"\\\\b\"), 'g'), ES100_FRAGMENT_OUTPUT_NAME);\n  }\n  return source;\n}","map":{"version":3,"names":["testVariable","qualifier","RegExp","concat","ES300_REPLACEMENTS","ES300_VERTEX_REPLACEMENTS","ES300_FRAGMENT_REPLACEMENTS","ES100_REPLACEMENTS","ES100_VERTEX_REPLACEMENTS","ES100_FRAGMENT_REPLACEMENTS","ES100_FRAGMENT_OUTPUT_NAME","ES300_FRAGMENT_OUTPUT_REGEX","REGEX_START_OF_MAIN","transpileShader","source","targetGLSLVersion","isVertex","convertShader","convertFragmentShaderTo300","convertFragmentShaderTo100","Error","replacements","pattern","replacement","replace","outputMatch","match","outputName"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@luma.gl/shadertools/src/lib/transpile-shader.js"],"sourcesContent":["// TRANSPILATION TABLES\n\nfunction testVariable(qualifier) {\n  /*\n    should match:\n      in float weight;\n      out vec4 positions[2];\n    should not match:\n      void f(out float a, in float b) {}\n   */\n  return new RegExp(`\\\\b${qualifier}[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)`, 'g');\n}\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS = [\n  // Fix poorly formatted version directive\n  [/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n  // The individual `texture...()` functions were replaced with `texture()` overloads\n  [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('],\n  [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']\n];\n\nconst ES300_VERTEX_REPLACEMENTS = [\n  ...ES300_REPLACEMENTS,\n  // `attribute` keyword replaced with `in`\n  [testVariable('attribute'), 'in $1'],\n  // `varying` keyword replaced with `out`\n  [testVariable('varying'), 'out $1']\n];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS = [\n  ...ES300_REPLACEMENTS,\n  // `varying` keyword replaced with `in`\n  [testVariable('varying'), 'in $1']\n];\n\nconst ES100_REPLACEMENTS = [\n  [/^#version[ \\t]+300[ \\t]+es/, '#version 100'],\n\n  // In GLSL 1.00 ES these functions are provided by an extension\n  [/\\btexture(2D|2DProj|Cube)Lod\\(/g, 'texture$1LodEXT('],\n\n  // Overloads in GLSL 3.00 map to individual functions. Note that we cannot\n  // differentiate 2D,2DProj,Cube without type analysis so we choose the most common variant.\n  [/\\btexture\\(/g, 'texture2D('],\n  [/\\btextureLod\\(/g, 'texture2DLodEXT(']\n];\n\nconst ES100_VERTEX_REPLACEMENTS = [\n  ...ES100_REPLACEMENTS,\n  [testVariable('in'), 'attribute $1'],\n  [testVariable('out'), 'varying $1']\n];\n\nconst ES100_FRAGMENT_REPLACEMENTS = [\n  ...ES100_REPLACEMENTS,\n  // Replace `in` with `varying`\n  [testVariable('in'), 'varying $1']\n];\n\nconst ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';\nconst ES300_FRAGMENT_OUTPUT_REGEX = /\\bout[ \\t]+vec4[ \\t]+(\\w+)[ \\t]*;\\n?/;\n\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\n\n// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex\n        ? convertShader(source, ES300_VERTEX_REPLACEMENTS)\n        : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex\n        ? convertShader(source, ES100_VERTEX_REPLACEMENTS)\n        : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertShader(source, replacements) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\n\nfunction convertFragmentShaderTo300(source) {\n  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n\n  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source.replace(new RegExp(`\\\\b${ES100_FRAGMENT_OUTPUT_NAME}\\\\b`, 'g'), outputName);\n  } else {\n    const outputName = 'fragmentColor';\n    source = source\n      .replace(REGEX_START_OF_MAIN, match => `out vec4 ${outputName};\\n${match}`)\n      .replace(new RegExp(`\\\\b${ES100_FRAGMENT_OUTPUT_NAME}\\\\b`, 'g'), outputName);\n  }\n\n  return source;\n}\n\nfunction convertFragmentShaderTo100(source) {\n  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);\n\n  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source\n      .replace(ES300_FRAGMENT_OUTPUT_REGEX, '')\n      .replace(new RegExp(`\\\\b${outputName}\\\\b`, 'g'), ES100_FRAGMENT_OUTPUT_NAME);\n  }\n\n  return source;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}