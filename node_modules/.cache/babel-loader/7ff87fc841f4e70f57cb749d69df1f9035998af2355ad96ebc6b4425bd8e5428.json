{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nconst defaultProps = {\n  ...ScreenGridCellLayer.defaultProps,\n  getPosition: {\n    type: 'accessor',\n    value: d => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", void 0);\n  }\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {\n          id: \"\".concat(this.id, \"-max-texture\")\n        })\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true,\n      weights,\n      subLayerData: {\n        attributes: {}\n      },\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n  updateState(opts) {\n    super.updateState(opts);\n  }\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {\n      maxTexture,\n      numRow,\n      numCol,\n      weights\n    } = this.state;\n    const {\n      updateTriggers\n    } = this.props;\n    const {\n      aggregationBuffer\n    } = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer',\n      updateTriggers\n    }), {\n      data: {\n        attributes: {\n          instanceCounts: aggregationBuffer\n        }\n      },\n      maxTexture,\n      numInstances: numRow * numCol\n    });\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    const {\n      aggregationBuffer,\n      maxBuffer,\n      maxTexture\n    } = this.state;\n    aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    maxBuffer === null || maxBuffer === void 0 ? void 0 : maxBuffer.delete();\n    maxTexture === null || maxTexture === void 0 ? void 0 : maxTexture.delete();\n  }\n  getPickingInfo(_ref2) {\n    let {\n      info\n    } = _ref2;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      const {\n        gpuGridAggregator,\n        gpuAggregation,\n        weights\n      } = this.state;\n      const aggregationResults = gpuAggregation ? gpuGridAggregator.getData('count') : weights.count;\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n    return info;\n  }\n  updateResults(_ref3) {\n    let {\n      aggregationData,\n      maxData\n    } = _ref3;\n    const {\n      count\n    } = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({\n      data: aggregationData\n    });\n    count.maxData = maxData;\n    count.maxTexture.setImageData({\n      data: maxData\n    });\n  }\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {\n      viewportChanged\n    } = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      dimensions\n    } = this.state;\n    const {\n      data,\n      weights\n    } = dimensions;\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n      compareAll: gpuAggregation,\n      dimension: data\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n    const {\n      viewport\n    } = this.context;\n    if (viewportChanged || cellSizeChanged) {\n      const {\n        width,\n        height\n      } = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        scaling: [width / 2, -height / 2, 1],\n        gridOffset: {\n          xOffset: cellSize,\n          yOffset: cellSize\n        },\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n_defineProperty(ScreenGridLayer, \"layerName\", 'ScreenGridLayer');\n_defineProperty(ScreenGridLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["_defineProperty","log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","ScreenGridCellLayer","GridAggregationLayer","getFloatTexture","defaultProps","getPosition","type","value","d","position","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ScreenGridLayer","constructor","arguments","initializeState","gl","context","isSupported","setState","supported","error","concat","id","initializeAggregationLayer","dimensions","getCellSize","cellSizePixels","count","size","operation","SUM","needMax","maxTexture","projectPoints","subLayerData","attributes","positionAttributeName","posOffset","translation","attributeManager","getAttributeManager","add","accessor","fp64","use64bitPositions","shouldUpdateState","_ref","changeFlags","state","somethingChanged","updateState","opts","renderLayers","numRow","numCol","updateTriggers","aggregationBuffer","CellLayerClass","getSubLayerClass","getSubLayerProps","instanceCounts","numInstances","finalizeState","maxBuffer","delete","getPickingInfo","_ref2","info","index","gpuGridAggregator","aggregationResults","getData","object","getAggregationData","pixelIndex","updateResults","_ref3","aggregationData","maxData","setData","setImageData","updateAggregationState","cellSize","cellSizeChanged","oldProps","viewportChanged","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","aggregationDataDirty","isAggregationDirty","compareAll","dimension","aggregationWeightsDirty","viewport","width","height","Math","ceil","allocateResources","scaling","gridOffset","xOffset","yOffset","_updateAccessors","_resetResults","getValue"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-layer.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nconst defaultProps = { ...ScreenGridCellLayer.defaultProps,\n  getPosition: {\n    type: 'accessor',\n    value: d => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {\n          id: \"\".concat(this.id, \"-max-texture\")\n        })\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true,\n      weights,\n      subLayerData: {\n        attributes: {}\n      },\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n\n    const {\n      maxTexture,\n      numRow,\n      numCol,\n      weights\n    } = this.state;\n    const {\n      updateTriggers\n    } = this.props;\n    const {\n      aggregationBuffer\n    } = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer',\n      updateTriggers\n    }), {\n      data: {\n        attributes: {\n          instanceCounts: aggregationBuffer\n        }\n      },\n      maxTexture,\n      numInstances: numRow * numCol\n    });\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n    const {\n      aggregationBuffer,\n      maxBuffer,\n      maxTexture\n    } = this.state;\n    aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    maxBuffer === null || maxBuffer === void 0 ? void 0 : maxBuffer.delete();\n    maxTexture === null || maxTexture === void 0 ? void 0 : maxTexture.delete();\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    const {\n      index\n    } = info;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator,\n        gpuAggregation,\n        weights\n      } = this.state;\n      const aggregationResults = gpuAggregation ? gpuGridAggregator.getData('count') : weights.count;\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  updateResults({\n    aggregationData,\n    maxData\n  }) {\n    const {\n      count\n    } = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({\n      data: aggregationData\n    });\n    count.maxData = maxData;\n    count.maxTexture.setImageData({\n      data: maxData\n    });\n  }\n\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {\n      viewportChanged\n    } = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      dimensions\n    } = this.state;\n    const {\n      data,\n      weights\n    } = dimensions;\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n      compareAll: gpuAggregation,\n      dimension: data\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n    const {\n      viewport\n    } = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {\n        width,\n        height\n      } = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        scaling: [width / 2, -height / 2, 1],\n        gridOffset: {\n          xOffset: cellSize,\n          yOffset: cellSize\n        },\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n}\n\n_defineProperty(ScreenGridLayer, \"layerName\", 'ScreenGridLayer');\n\n_defineProperty(ScreenGridLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=screen-grid-layer.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}