{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nconst defaultProps = {\n  ...ScreenGridCellLayer.defaultProps,\n  getPosition: {\n    type: 'accessor',\n    value: d => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", void 0);\n  }\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {\n          id: \"\".concat(this.id, \"-max-texture\")\n        })\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true,\n      weights,\n      subLayerData: {\n        attributes: {}\n      },\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n  updateState(opts) {\n    super.updateState(opts);\n  }\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {\n      maxTexture,\n      numRow,\n      numCol,\n      weights\n    } = this.state;\n    const {\n      updateTriggers\n    } = this.props;\n    const {\n      aggregationBuffer\n    } = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer',\n      updateTriggers\n    }), {\n      data: {\n        attributes: {\n          instanceCounts: aggregationBuffer\n        }\n      },\n      maxTexture,\n      numInstances: numRow * numCol\n    });\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    const {\n      aggregationBuffer,\n      maxBuffer,\n      maxTexture\n    } = this.state;\n    aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    maxBuffer === null || maxBuffer === void 0 ? void 0 : maxBuffer.delete();\n    maxTexture === null || maxTexture === void 0 ? void 0 : maxTexture.delete();\n  }\n  getPickingInfo(_ref2) {\n    let {\n      info\n    } = _ref2;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      const {\n        gpuGridAggregator,\n        gpuAggregation,\n        weights\n      } = this.state;\n      const aggregationResults = gpuAggregation ? gpuGridAggregator.getData('count') : weights.count;\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n    return info;\n  }\n  updateResults(_ref3) {\n    let {\n      aggregationData,\n      maxData\n    } = _ref3;\n    const {\n      count\n    } = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({\n      data: aggregationData\n    });\n    count.maxData = maxData;\n    count.maxTexture.setImageData({\n      data: maxData\n    });\n  }\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {\n      viewportChanged\n    } = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      dimensions\n    } = this.state;\n    const {\n      data,\n      weights\n    } = dimensions;\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n      compareAll: gpuAggregation,\n      dimension: data\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n    const {\n      viewport\n    } = this.context;\n    if (viewportChanged || cellSizeChanged) {\n      const {\n        width,\n        height\n      } = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        scaling: [width / 2, -height / 2, 1],\n        gridOffset: {\n          xOffset: cellSize,\n          yOffset: cellSize\n        },\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n_defineProperty(ScreenGridLayer, \"layerName\", 'ScreenGridLayer');\n_defineProperty(ScreenGridLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","ScreenGridCellLayer","GridAggregationLayer","getFloatTexture","defaultProps","getPosition","type","value","d","position","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ScreenGridLayer","constructor","arguments","_defineProperty","initializeState","gl","context","isSupported","setState","supported","error","concat","id","initializeAggregationLayer","dimensions","getCellSize","cellSizePixels","count","size","operation","SUM","needMax","maxTexture","projectPoints","subLayerData","attributes","positionAttributeName","posOffset","translation","attributeManager","getAttributeManager","add","accessor","fp64","use64bitPositions","shouldUpdateState","_ref","changeFlags","state","somethingChanged","updateState","opts","renderLayers","numRow","numCol","updateTriggers","aggregationBuffer","CellLayerClass","getSubLayerClass","getSubLayerProps","instanceCounts","numInstances","finalizeState","maxBuffer","delete","getPickingInfo","_ref2","info","index","gpuGridAggregator","aggregationResults","getData","object","getAggregationData","pixelIndex","updateResults","_ref3","aggregationData","maxData","setData","setImageData","updateAggregationState","cellSize","cellSizeChanged","oldProps","viewportChanged","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","aggregationDataDirty","isAggregationDirty","compareAll","dimension","aggregationWeightsDirty","viewport","width","height","Math","ceil","allocateResources","scaling","gridOffset","xOffset","yOffset","_updateAccessors","_resetResults","getValue"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  Layer,\n  LayerContext,\n  LayersList,\n  log,\n  PickingInfo,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport type {Texture2D} from '@luma.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\nimport {getFloatTexture} from '../utils/resource-utils.js';\n\nconst defaultProps: DefaultProps<ScreenGridLayerProps> = {\n  ...ScreenGridCellLayer.defaultProps,\n  getPosition: {type: 'accessor', value: d => d.position},\n  getWeight: {type: 'accessor', value: 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\n/** All properties supported by ScreenGridLayer. */\nexport type ScreenGridLayerProps<DataT = any> = _ScreenGridLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by ScreenGridLayer. */\nexport type _ScreenGridLayerProps<DataT> = {\n  /**\n   * Unit width/height of the bins.\n   * @default 100\n   */\n  cellSizePixels?: number;\n\n  /**\n   * Cell margin size in pixels.\n   * @default 2\n   */\n  cellMarginPixels?: number;\n\n  /**\n   * Expressed as an rgba array, minimal color that could be rendered by a tile.\n   * @default [0, 0, 0, 255]\n   * @deprecated Deprecated in version 5.2.0, use `colorRange` and `colorDomain` instead.\n   */\n  minColor?: Color | null;\n\n  /**\n   * Expressed as an rgba array, maximal color that could be rendered by a tile.\n   * @default [0, 255, 0, 255]\n   * @deprecated Deprecated in version 5.2.0, use `colorRange` and `colorDomain` instead.\n   */\n  maxColor?: Color | null;\n\n  /**\n   * Color scale input domain. The color scale maps continues numeric domain into discrete color range.\n   * @default [1, max(weight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n\n  /**\n   * Perform aggregation is performed on GPU.\n   *\n   * NOTE: GPU Aggregation requires WebGL2 support by the browser.\n   * When `gpuAggregation` is set to true and browser doesn't support WebGL2, aggregation falls back to CPU.\n   *\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation\n   *\n   * V valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n};\n\n/** Aggregates data into histogram bins and renders them as a grid. */\nexport default class ScreenGridLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraProps & Required<_ScreenGridLayerProps<DataT>>> {\n  static layerName = 'ScreenGridLayer';\n  static defaultProps = defaultProps;\n\n  state!: GridAggregationLayer<DataT>['state'] & {\n    supported: boolean;\n    gpuGridAggregator?: any;\n    gpuAggregation?: any;\n    weights?: any;\n    maxTexture?: Texture2D;\n  };\n\n  initializeState() {\n    const {gl} = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      // max aggregated value is sampled from a float texture\n      this.setState({supported: false});\n      log.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS,\n      // @ts-expect-error\n      getCellSize: props => props.cellSizePixels // TODO\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {id: `${this.id}-max-texture`})\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true, // aggregation in screen space\n      weights,\n      subLayerData: {attributes: {}},\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n  }\n\n  renderLayers(): LayersList | Layer {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {maxTexture, numRow, numCol, weights} = this.state;\n    const {updateTriggers} = this.props;\n    const {aggregationBuffer} = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers\n      }),\n      {\n        data: {attributes: {instanceCounts: aggregationBuffer}},\n        maxTexture,\n        numInstances: numRow * numCol\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext): void {\n    super.finalizeState(context);\n\n    const {aggregationBuffer, maxBuffer, maxTexture} = this.state;\n\n    aggregationBuffer?.delete();\n    maxBuffer?.delete();\n    maxTexture?.delete();\n  }\n\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    const {index} = info;\n    if (index >= 0) {\n      const {gpuGridAggregator, gpuAggregation, weights} = this.state;\n      // Get count aggregation results\n      const aggregationResults = gpuAggregation\n        ? gpuGridAggregator.getData('count')\n        : weights.count;\n\n      // Each instance (one cell) is aggregated into single pixel,\n      // Get current instance's aggregation details.\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  // Aggregation Overrides\n\n  updateResults({aggregationData, maxData}) {\n    const {count} = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({data: aggregationData});\n    count.maxData = maxData;\n    count.maxTexture.setImageData({data: maxData});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {viewportChanged} = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n\n    const {dimensions} = this.state;\n    const {data, weights} = dimensions;\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      viewportChanged ||\n      this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n        dimension: data\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n\n    const {viewport} = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {width, height} = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        // transformation from clipspace to screen(pixel) space\n        scaling: [width / 2, -height / 2, 1],\n\n        gridOffset: {xOffset: cellSize, yOffset: cellSize},\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}