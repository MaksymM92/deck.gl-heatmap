{"ast":null,"code":"import { whichButtons, getOffsetPosition } from './event-utils';\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    /**\n     * Handles hammerjs event\n     */\n    this.handleEvent = event => {\n      if (this.isEmpty()) {\n        return;\n      }\n      const mjolnirEvent = this._normalizeEvent(event);\n      let target = event.srcEvent.target;\n      while (target && target !== mjolnirEvent.rootElement) {\n        this._emit(mjolnirEvent, target);\n        if (mjolnirEvent.handled) {\n          return;\n        }\n        target = target.parentNode;\n      }\n      this._emit(mjolnirEvent, 'root');\n    };\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n    this._active = false;\n  }\n  // Returns true if there are no non-passive handlers\n  isEmpty() {\n    return !this._active;\n  }\n  add(type, handler, options) {\n    let once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    let opts = DEFAULT_OPTIONS;\n    if (typeof options === 'string' || options && options.addEventListener) {\n      // is DOM element, backward compatibility\n      // @ts-ignore\n      opts = {\n        ...DEFAULT_OPTIONS,\n        srcElement: options\n      };\n    } else if (options) {\n      opts = {\n        ...DEFAULT_OPTIONS,\n        ...options\n      };\n    }\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n  remove(type, handler) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n    if (entries) {\n      let immediatePropagationStopped = false;\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n      for (let i = 0; i < entries.length; i++) {\n        const {\n          type,\n          handler,\n          once\n        } = entries[i];\n        handler({\n          ...event,\n          // @ts-ignore\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        });\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {\n          type,\n          handler\n        } = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.getElement();\n    return {\n      ...event,\n      ...whichButtons(event),\n      ...getOffsetPosition(event, rootElement),\n      preventDefault: () => {\n        event.srcEvent.preventDefault();\n      },\n      stopImmediatePropagation: null,\n      stopPropagation: null,\n      handled: false,\n      rootElement\n    };\n  }\n}","map":{"version":3,"names":["whichButtons","getOffsetPosition","DEFAULT_OPTIONS","srcElement","priority","EventRegistrar","constructor","eventManager","handleEvent","event","isEmpty","mjolnirEvent","_normalizeEvent","target","srcEvent","rootElement","_emit","handled","parentNode","handlers","handlersByElement","Map","_active","add","type","handler","options","once","arguments","length","undefined","passive","opts","addEventListener","entries","get","set","entry","push","insertPosition","splice","remove","i","indexOf","delete","some","immediatePropagationStopped","stopPropagation","stopImmediatePropagation","entriesToRemove","getElement","preventDefault"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/mjolnir.js/src/utils/event-registrar.ts"],"sourcesContent":["import type EventManager from '../event-manager';\nimport {whichButtons, getOffsetPosition} from './event-utils';\nimport type {MjolnirEventRaw, MjolnirEventWrapper, MjolnirEvent} from '../types';\n\nexport type HandlerOptions = {\n  srcElement?: 'root' | HTMLElement;\n  priority?: number;\n};\n\ntype EventHandler = {\n  type: string;\n  handler: (event: MjolnirEvent) => void;\n  once?: boolean;\n  passive?: boolean;\n} & HandlerOptions;\n\nconst DEFAULT_OPTIONS: HandlerOptions = {\n  srcElement: 'root',\n  priority: 0\n};\n\nexport default class EventRegistrar {\n  eventManager: EventManager;\n  recognizerName: string;\n  handlers: EventHandler[];\n  handlersByElement: Map<'root' | HTMLElement, EventHandler[]>;\n  _active: boolean;\n\n  constructor(eventManager: EventManager) {\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n\n    this._active = false;\n  }\n\n  // Returns true if there are no non-passive handlers\n  isEmpty(): boolean {\n    return !this._active;\n  }\n\n  add(\n    type: string,\n    handler: (event: MjolnirEvent) => void,\n    options: HTMLElement | HandlerOptions,\n    once: boolean = false,\n    passive: boolean = false\n  ) {\n    const {handlers, handlersByElement} = this;\n    let opts: HandlerOptions = DEFAULT_OPTIONS;\n\n    if (typeof options === 'string' || (options && (options as HTMLElement).addEventListener)) {\n      // is DOM element, backward compatibility\n      // @ts-ignore\n      opts = {...DEFAULT_OPTIONS, srcElement: options};\n    } else if (options) {\n      opts = {...DEFAULT_OPTIONS, ...options};\n    }\n\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry: EventHandler = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n\n  remove(type: string, handler: (event: MjolnirEvent) => void) {\n    const {handlers, handlersByElement} = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n\n  /**\n   * Handles hammerjs event\n   */\n  handleEvent = (event: MjolnirEventRaw) => {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    const mjolnirEvent = this._normalizeEvent(event);\n    let target = event.srcEvent.target as HTMLElement;\n\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n      if (mjolnirEvent.handled) {\n        return;\n      }\n      target = target.parentNode as HTMLElement;\n    }\n    this._emit(mjolnirEvent, 'root');\n  };\n\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit<T extends MjolnirEventRaw>(\n    event: MjolnirEventWrapper<T>,\n    srcElement: 'root' | HTMLElement\n  ) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false;\n\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove: EventHandler[] = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {type, handler, once} = entries[i];\n        handler({\n          ...event,\n          // @ts-ignore\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        });\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {type, handler} = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent<T extends MjolnirEventRaw>(event: T): MjolnirEventWrapper<T> {\n    const rootElement = this.eventManager.getElement();\n\n    return {\n      ...event,\n      ...whichButtons(event),\n      ...getOffsetPosition(event, rootElement),\n      preventDefault: () => {\n        event.srcEvent.preventDefault();\n      },\n      stopImmediatePropagation: null,\n      stopPropagation: null,\n      handled: false,\n      rootElement\n    };\n  }\n}\n"],"mappings":"AACA,SAAQA,YAAY,EAAEC,iBAAiB,QAAO,eAAe;AAe7D,MAAMC,eAAe,GAAmB;EACtCC,UAAU,EAAE,MAAM;EAClBC,QAAQ,EAAE;CACX;AAED,eAAc,MAAOC,cAAc;EAOjCC,YAAYC,YAA0B;IAkFtC;;;IAGA,KAAAC,WAAW,GAAIC,KAAsB,IAAI;MACvC,IAAI,IAAI,CAACC,OAAO,EAAE,EAAE;QAClB;;MAGF,MAAMC,YAAY,GAAG,IAAI,CAACC,eAAe,CAACH,KAAK,CAAC;MAChD,IAAII,MAAM,GAAGJ,KAAK,CAACK,QAAQ,CAACD,MAAqB;MAEjD,OAAOA,MAAM,IAAIA,MAAM,KAAKF,YAAY,CAACI,WAAW,EAAE;QACpD,IAAI,CAACC,KAAK,CAACL,YAAY,EAAEE,MAAM,CAAC;QAChC,IAAIF,YAAY,CAACM,OAAO,EAAE;UACxB;;QAEFJ,MAAM,GAAGA,MAAM,CAACK,UAAyB;;MAE3C,IAAI,CAACF,KAAK,CAACL,YAAY,EAAE,MAAM,CAAC;IAClC,CAAC;IApGC,IAAI,CAACJ,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACY,QAAQ,GAAG,EAAE;IAClB;IACA,IAAI,CAACC,iBAAiB,GAAG,IAAIC,GAAG,EAAE;IAElC,IAAI,CAACC,OAAO,GAAG,KAAK;EACtB;EAEA;EACAZ,OAAOA,CAAA;IACL,OAAO,CAAC,IAAI,CAACY,OAAO;EACtB;EAEAC,GAAGA,CACDC,IAAY,EACZC,OAAsC,EACtCC,OAAqC,EAEb;IAAA,IADxBC,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAgB,KAAK;IAAA,IACrBG,OAAA,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAmB,KAAK;IAExB,MAAM;MAACT,QAAQ;MAAEC;IAAiB,CAAC,GAAG,IAAI;IAC1C,IAAIY,IAAI,GAAmB9B,eAAe;IAE1C,IAAI,OAAOwB,OAAO,KAAK,QAAQ,IAAKA,OAAO,IAAKA,OAAuB,CAACO,gBAAiB,EAAE;MACzF;MACA;MACAD,IAAI,GAAG;QAAC,GAAG9B,eAAe;QAAEC,UAAU,EAAEuB;MAAO,CAAC;KACjD,MAAM,IAAIA,OAAO,EAAE;MAClBM,IAAI,GAAG;QAAC,GAAG9B,eAAe;QAAE,GAAGwB;MAAO,CAAC;;IAGzC,IAAIQ,OAAO,GAAGd,iBAAiB,CAACe,GAAG,CAACH,IAAI,CAAC7B,UAAU,CAAC;IACpD,IAAI,CAAC+B,OAAO,EAAE;MACZA,OAAO,GAAG,EAAE;MACZd,iBAAiB,CAACgB,GAAG,CAACJ,IAAI,CAAC7B,UAAU,EAAE+B,OAAO,CAAC;;IAEjD,MAAMG,KAAK,GAAiB;MAC1Bb,IAAI;MACJC,OAAO;MACPtB,UAAU,EAAE6B,IAAI,CAAC7B,UAAU;MAC3BC,QAAQ,EAAE4B,IAAI,CAAC5B;KAChB;IACD,IAAIuB,IAAI,EAAE;MACRU,KAAK,CAACV,IAAI,GAAG,IAAI;;IAEnB,IAAII,OAAO,EAAE;MACXM,KAAK,CAACN,OAAO,GAAG,IAAI;;IAEtBZ,QAAQ,CAACmB,IAAI,CAACD,KAAK,CAAC;IACpB,IAAI,CAACf,OAAO,GAAG,IAAI,CAACA,OAAO,IAAI,CAACe,KAAK,CAACN,OAAO;IAE7C;IACA;IACA,IAAIQ,cAAc,GAAGL,OAAO,CAACL,MAAM,GAAG,CAAC;IACvC,OAAOU,cAAc,IAAI,CAAC,EAAE;MAC1B,IAAIL,OAAO,CAACK,cAAc,CAAC,CAACnC,QAAQ,IAAIiC,KAAK,CAACjC,QAAQ,EAAE;QACtD;;MAEFmC,cAAc,EAAE;;IAElBL,OAAO,CAACM,MAAM,CAACD,cAAc,GAAG,CAAC,EAAE,CAAC,EAAEF,KAAK,CAAC;EAC9C;EAEAI,MAAMA,CAACjB,IAAY,EAAEC,OAAsC;IACzD,MAAM;MAACN,QAAQ;MAAEC;IAAiB,CAAC,GAAG,IAAI;IAE1C,KAAK,IAAIsB,CAAC,GAAGvB,QAAQ,CAACU,MAAM,GAAG,CAAC,EAAEa,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC7C,MAAML,KAAK,GAAGlB,QAAQ,CAACuB,CAAC,CAAC;MAEzB,IAAIL,KAAK,CAACb,IAAI,KAAKA,IAAI,IAAIa,KAAK,CAACZ,OAAO,KAAKA,OAAO,EAAE;QACpDN,QAAQ,CAACqB,MAAM,CAACE,CAAC,EAAE,CAAC,CAAC;QACrB,MAAMR,OAAO,GAAGd,iBAAiB,CAACe,GAAG,CAACE,KAAK,CAAClC,UAAU,CAAC;QACvD+B,OAAO,CAACM,MAAM,CAACN,OAAO,CAACS,OAAO,CAACN,KAAK,CAAC,EAAE,CAAC,CAAC;QACzC,IAAIH,OAAO,CAACL,MAAM,KAAK,CAAC,EAAE;UACxBT,iBAAiB,CAACwB,MAAM,CAACP,KAAK,CAAClC,UAAU,CAAC;;;;IAIhD,IAAI,CAACmB,OAAO,GAAGH,QAAQ,CAAC0B,IAAI,CAACR,KAAK,IAAI,CAACA,KAAK,CAACN,OAAO,CAAC;EACvD;EAuBA;;;EAGAf,KAAKA,CACHP,KAA6B,EAC7BN,UAAgC;IAEhC,MAAM+B,OAAO,GAAG,IAAI,CAACd,iBAAiB,CAACe,GAAG,CAAChC,UAAU,CAAC;IAEtD,IAAI+B,OAAO,EAAE;MACX,IAAIY,2BAA2B,GAAG,KAAK;MAEvC;MACA,MAAMC,eAAe,GAAGA,CAAA,KAAK;QAC3BtC,KAAK,CAACQ,OAAO,GAAG,IAAI;MACtB,CAAC;MACD;MACA,MAAM+B,wBAAwB,GAAGA,CAAA,KAAK;QACpCvC,KAAK,CAACQ,OAAO,GAAG,IAAI;QACpB6B,2BAA2B,GAAG,IAAI;MACpC,CAAC;MACD,MAAMG,eAAe,GAAmB,EAAE;MAE1C,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,OAAO,CAACL,MAAM,EAAEa,CAAC,EAAE,EAAE;QACvC,MAAM;UAAClB,IAAI;UAAEC,OAAO;UAAEE;QAAI,CAAC,GAAGO,OAAO,CAACQ,CAAC,CAAC;QACxCjB,OAAO,CAAC;UACN,GAAGhB,KAAK;UACR;UACAe,IAAI;UACJuB,eAAe;UACfC;SACD,CAAC;QACF,IAAIrB,IAAI,EAAE;UACRsB,eAAe,CAACX,IAAI,CAACJ,OAAO,CAACQ,CAAC,CAAC,CAAC;;QAElC,IAAII,2BAA2B,EAAE;UAC/B;;;MAIJ,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,eAAe,CAACpB,MAAM,EAAEa,CAAC,EAAE,EAAE;QAC/C,MAAM;UAAClB,IAAI;UAAEC;QAAO,CAAC,GAAGwB,eAAe,CAACP,CAAC,CAAC;QAC1C,IAAI,CAACD,MAAM,CAACjB,IAAI,EAAEC,OAAO,CAAC;;;EAGhC;EAEA;;;EAGAb,eAAeA,CAA4BH,KAAQ;IACjD,MAAMM,WAAW,GAAG,IAAI,CAACR,YAAY,CAAC2C,UAAU,EAAE;IAElD,OAAO;MACL,GAAGzC,KAAK;MACR,GAAGT,YAAY,CAACS,KAAK,CAAC;MACtB,GAAGR,iBAAiB,CAACQ,KAAK,EAAEM,WAAW,CAAC;MACxCoC,cAAc,EAAEA,CAAA,KAAK;QACnB1C,KAAK,CAACK,QAAQ,CAACqC,cAAc,EAAE;MACjC,CAAC;MACDH,wBAAwB,EAAE,IAAI;MAC9BD,eAAe,EAAE,IAAI;MACrB9B,OAAO,EAAE,KAAK;MACdF;KACD;EACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}