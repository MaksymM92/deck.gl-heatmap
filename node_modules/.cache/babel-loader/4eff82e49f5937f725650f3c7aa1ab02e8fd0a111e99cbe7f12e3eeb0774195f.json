{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { LineLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { generateContours } from './contour-utils';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\nconst defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM',\n  contours: {\n    type: 'object',\n    value: [{\n      threshold: DEFAULT_THRESHOLD\n    }],\n    optional: true,\n    compare: 3\n  },\n  zOffset: 0.005\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ContourLayer extends GridAggregationLayer {\n  initializeState() {\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n  updateState(opts) {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {\n      oldProps,\n      props\n    } = opts;\n    const {\n      aggregationDirty\n    } = this.state;\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n      this._updateThresholdData(opts.props);\n    }\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n  renderLayers() {\n    const {\n      contourSegments,\n      contourPolygons\n    } = this.state.contourData;\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n    const lineLayer = contourSegments && contourSegments.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({\n      id: 'lines'\n    }), {\n      data: this.state.contourData.contourSegments,\n      getSourcePosition: d => d.start,\n      getTargetPosition: d => d.end,\n      getColor: d => d.contour.color || DEFAULT_COLOR,\n      getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n    });\n    const bandsLayer = contourPolygons && contourPolygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({\n      id: 'bands'\n    }), {\n      data: this.state.contourData.contourPolygons,\n      getPolygon: d => d.vertices,\n      getFillColor: d => d.contour.color || DEFAULT_COLOR\n    });\n    return [lineLayer, bandsLayer];\n  }\n  updateAggregationState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const {\n      cellSize,\n      coordinateSystem\n    } = props;\n    const {\n      viewport\n    } = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const {\n      dimensions\n    } = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      data,\n      weights\n    } = dimensions;\n    let {\n      boundingBox\n    } = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({\n        boundingBox\n      });\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {\n        gridOffset,\n        translation,\n        width,\n        height,\n        numCol,\n        numRow\n      } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(),\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || this.isAggregationDirty(opts, {\n      dimension: data,\n      compareAll: gpuAggregation\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n  _generateContours() {\n    const {\n      numCol,\n      numRow,\n      gridOrigin,\n      gridOffset,\n      thresholdData\n    } = this.state;\n    const {\n      count\n    } = this.state.weights;\n    let {\n      aggregationData\n    } = count;\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n    const {\n      cellWeights\n    } = GPUGridAggregator.getCellData({\n      countsData: aggregationData\n    });\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n    this.setState({\n      contourData\n    });\n  }\n  _updateThresholdData(props) {\n    const {\n      contours,\n      zOffset\n    } = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n    this.setState({\n      thresholdData\n    });\n  }\n}\n_defineProperty(ContourLayer, \"layerName\", 'ContourLayer');\n_defineProperty(ContourLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["_defineProperty","LineLayer","SolidPolygonLayer","generateContours","log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","getBoundingBox","getGridParams","GridAggregationLayer","DEFAULT_COLOR","DEFAULT_STROKE_WIDTH","DEFAULT_THRESHOLD","defaultProps","cellSize","type","min","max","value","getPosition","x","position","getWeight","gpuAggregation","aggregation","contours","threshold","optional","compare","zOffset","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ContourLayer","initializeState","initializeAggregationLayer","dimensions","setState","contourData","projectPoints","count","size","operation","SUM","attributeManager","getAttributeManager","add","accessor","fp64","use64bitPositions","updateState","opts","contoursChanged","oldProps","aggregationDirty","state","_updateThresholdData","getNumInstances","_generateContours","renderLayers","contourSegments","contourPolygons","LinesSubLayerClass","getSubLayerClass","BandsSubLayerClass","lineLayer","length","getSubLayerProps","id","getSourcePosition","d","start","getTargetPosition","end","getColor","contour","color","getWidth","strokeWidth","bandsLayer","getPolygon","vertices","getFillColor","updateAggregationState","coordinateSystem","viewport","context","cellSizeChanged","isSupported","gl","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","boundingBox","getAttributes","gridOffset","translation","width","height","numCol","numRow","allocateResources","posOffset","slice","gridOrigin","aggregationDataDirty","isAggregationDirty","dimension","compareAll","aggregationWeightsDirty","_updateAccessors","_resetResults","getValue","aggregationData","thresholdData","aggregationBuffer","getData","cellWeights","getCellData","countsData","gridSize","xOffset","yOffset","Array","i","zIndex"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/contour-layer/contour-layer.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { LineLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { generateContours } from './contour-utils';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\nconst defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM',\n  contours: {\n    type: 'object',\n    value: [{\n      threshold: DEFAULT_THRESHOLD\n    }],\n    optional: true,\n    compare: 3\n  },\n  zOffset: 0.005\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ContourLayer extends GridAggregationLayer {\n  initializeState() {\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {\n      oldProps,\n      props\n    } = opts;\n    const {\n      aggregationDirty\n    } = this.state;\n\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n\n      this._updateThresholdData(opts.props);\n    }\n\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n\n  renderLayers() {\n    const {\n      contourSegments,\n      contourPolygons\n    } = this.state.contourData;\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n    const lineLayer = contourSegments && contourSegments.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({\n      id: 'lines'\n    }), {\n      data: this.state.contourData.contourSegments,\n      getSourcePosition: d => d.start,\n      getTargetPosition: d => d.end,\n      getColor: d => d.contour.color || DEFAULT_COLOR,\n      getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n    });\n    const bandsLayer = contourPolygons && contourPolygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({\n      id: 'bands'\n    }), {\n      data: this.state.contourData.contourPolygons,\n      getPolygon: d => d.vertices,\n      getFillColor: d => d.contour.color || DEFAULT_COLOR\n    });\n    return [lineLayer, bandsLayer];\n  }\n\n  updateAggregationState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const {\n      cellSize,\n      coordinateSystem\n    } = props;\n    const {\n      viewport\n    } = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const {\n      dimensions\n    } = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      data,\n      weights\n    } = dimensions;\n    let {\n      boundingBox\n    } = this.state;\n\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({\n        boundingBox\n      });\n    }\n\n    if (positionsChanged || cellSizeChanged) {\n      const {\n        gridOffset,\n        translation,\n        width,\n        height,\n        numCol,\n        numRow\n      } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(),\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || this.isAggregationDirty(opts, {\n      dimension: data,\n      compareAll: gpuAggregation\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n  _generateContours() {\n    const {\n      numCol,\n      numRow,\n      gridOrigin,\n      gridOffset,\n      thresholdData\n    } = this.state;\n    const {\n      count\n    } = this.state.weights;\n    let {\n      aggregationData\n    } = count;\n\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n\n    const {\n      cellWeights\n    } = GPUGridAggregator.getCellData({\n      countsData: aggregationData\n    });\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n    this.setState({\n      contourData\n    });\n  }\n\n  _updateThresholdData(props) {\n    const {\n      contours,\n      zOffset\n    } = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n\n    this.setState({\n      thresholdData\n    });\n  }\n\n}\n\n_defineProperty(ContourLayer, \"layerName\", 'ContourLayer');\n\n_defineProperty(ContourLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=contour-layer.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}