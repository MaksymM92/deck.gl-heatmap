{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Pass from './pass';\nimport { clear, setParameters, withParameters, cssToDeviceRatio } from '@luma.gl/core';\nexport default class LayersPass extends Pass {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"_lastRenderIndex\", -1);\n  }\n  render(options) {\n    const gl = this.gl;\n    setParameters(gl, {\n      framebuffer: options.target\n    });\n    return this._drawLayers(options);\n  }\n  _drawLayers(options) {\n    const {\n      target,\n      moduleParameters,\n      viewports,\n      views,\n      onViewportActive,\n      clearStack = true,\n      clearCanvas = true\n    } = options;\n    options.pass = options.pass || 'unknown';\n    const gl = this.gl;\n    if (clearCanvas) {\n      clearGLCanvas(gl, target);\n    }\n    if (clearStack) {\n      this._lastRenderIndex = -1;\n    }\n    const renderStats = [];\n    for (const viewport of viewports) {\n      const view = views && views[viewport.id];\n      onViewportActive === null || onViewportActive === void 0 ? void 0 : onViewportActive(viewport);\n      const drawLayerParams = this._getDrawLayerParams(viewport, options);\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        const stats = this._drawLayersInViewport(gl, {\n          target,\n          moduleParameters,\n          viewport: subViewport,\n          view,\n          pass: options.pass,\n          layers: options.layers\n        }, drawLayerParams);\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n  _getDrawLayerParams(viewport, _ref) {\n    let {\n      layers,\n      pass,\n      isPicking = false,\n      layerFilter,\n      cullRect,\n      effects,\n      moduleParameters\n    } = _ref;\n    let evaluateShouldDrawOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const drawLayerParams = [];\n    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n    const drawContext = {\n      layer: layers[0],\n      viewport,\n      isPicking,\n      renderPass: pass,\n      cullRect\n    };\n    const layerFilterCache = {};\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);\n      const layerParam = {\n        shouldDrawLayer\n      };\n      if (shouldDrawLayer && !evaluateShouldDrawOnly) {\n        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);\n        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);\n      }\n      drawLayerParams[layerIndex] = layerParam;\n    }\n    return drawLayerParams;\n  }\n  _drawLayersInViewport(gl, _ref2, drawLayerParams) {\n    let {\n      layers,\n      moduleParameters: globalModuleParameters,\n      pass,\n      target,\n      viewport,\n      view\n    } = _ref2;\n    const glViewport = getGLViewport(gl, {\n      moduleParameters: globalModuleParameters,\n      target,\n      viewport\n    });\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {\n        color: true,\n        depth: true\n      } : view.props.clear;\n      withParameters(gl, {\n        scissorTest: true,\n        scissor: glViewport\n      }, () => clear(gl, clearOpts));\n    }\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n    setParameters(gl, {\n      viewport: glViewport\n    });\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const {\n        shouldDrawLayer,\n        layerRenderIndex,\n        moduleParameters,\n        layerParameters\n      } = drawLayerParams[layerIndex];\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      } else if (shouldDrawLayer) {\n        renderStatus.visibleCount++;\n        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n        moduleParameters.viewport = viewport;\n        try {\n          layer._drawLayer({\n            moduleParameters,\n            uniforms: {\n              layerIndex: layerRenderIndex\n            },\n            parameters: layerParameters\n          });\n        } catch (err) {\n          layer.raiseError(err, \"drawing \".concat(layer, \" to \").concat(pass));\n        }\n      }\n    }\n    return renderStatus;\n  }\n  shouldDrawLayer(layer) {\n    return true;\n  }\n  getModuleParameters(layer, effects) {\n    return null;\n  }\n  getLayerParameters(layer, layerIndex, viewport) {\n    return layer.props.parameters;\n  }\n  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {\n    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n    if (!shouldDrawLayer) {\n      return false;\n    }\n    drawContext.layer = layer;\n    let parent = layer.parent;\n    while (parent) {\n      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n        return false;\n      }\n      drawContext.layer = parent;\n      parent = parent.parent;\n    }\n    if (layerFilter) {\n      const rootLayerId = drawContext.layer.id;\n      if (!(rootLayerId in layerFilterCache)) {\n        layerFilterCache[rootLayerId] = layerFilter(drawContext);\n      }\n      if (!layerFilterCache[rootLayerId]) {\n        return false;\n      }\n    }\n    layer.activateViewport(drawContext.viewport);\n    return true;\n  }\n  _getModuleParameters(layer, effects, pass, overrides) {\n    var _layer$internalState;\n    const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {\n      autoWrapLongitude: layer.wrapLongitude,\n      viewport: layer.context.viewport,\n      mousePosition: layer.context.mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(this.gl)\n    });\n    if (effects) {\n      for (const effect of effects) {\n        var _effect$getModulePara;\n        Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));\n      }\n    }\n    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n  }\n}\nexport function layerIndexResolver() {\n  let startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let layerIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const resolvers = {};\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n    let index;\n    if (parentId && !(parentId in layerIndices)) {\n      resolveLayerIndex(layer.parent, false);\n    }\n    if (parentId in resolvers) {\n      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n    layerIndices[layerId] = index;\n    return index;\n  };\n  return resolveLayerIndex;\n}\nfunction getGLViewport(gl, _ref3) {\n  let {\n    moduleParameters,\n    target,\n    viewport\n  } = _ref3;\n  const useTarget = target && target.id !== 'default-framebuffer';\n  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || cssToDeviceRatio(gl);\n  const height = useTarget ? target.height : gl.drawingBufferHeight;\n  const dimensions = viewport;\n  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];\n}\nfunction clearGLCanvas(gl, targetFramebuffer) {\n  const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;\n  const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;\n  setParameters(gl, {\n    viewport: [0, 0, width, height]\n  });\n  gl.clear(16384 | 256);\n}","map":{"version":3,"names":["Pass","clear","setParameters","withParameters","cssToDeviceRatio","LayersPass","constructor","arguments","_defineProperty","render","options","gl","framebuffer","target","_drawLayers","moduleParameters","viewports","views","onViewportActive","clearStack","clearCanvas","pass","clearGLCanvas","_lastRenderIndex","renderStats","viewport","view","id","drawLayerParams","_getDrawLayerParams","subViewports","subViewport","stats","_drawLayersInViewport","layers","push","_ref","isPicking","layerFilter","cullRect","effects","evaluateShouldDrawOnly","length","undefined","indexResolver","layerIndexResolver","drawContext","layer","renderPass","layerFilterCache","layerIndex","shouldDrawLayer","_shouldDrawLayer","layerParam","layerRenderIndex","_getModuleParameters","layerParameters","getLayerParameters","_ref2","globalModuleParameters","glViewport","getGLViewport","props","clearOpts","color","depth","scissorTest","scissor","renderStatus","totalCount","visibleCount","compositeCount","pickableCount","pickable","isComposite","Math","max","_drawLayer","uniforms","parameters","err","raiseError","concat","getModuleParameters","visible","parent","filterSubLayer","rootLayerId","activateViewport","overrides","_layer$internalState","Object","assign","create","internalState","propsInTransition","autoWrapLongitude","wrapLongitude","context","mousePosition","pickingActive","devicePixelRatio","effect","_effect$getModulePara","call","startIndex","layerIndices","resolvers","resolveLayerIndex","isDrawn","indexOverride","_offset","layerId","parentId","index","resolver","Number","isFinite","_ref3","useTarget","pixelRatio","height","drawingBufferHeight","dimensions","x","y","width","targetFramebuffer","drawingBufferWidth"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/core/src/passes/layers-pass.ts"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport Pass from './pass';\nimport {clear, setParameters, withParameters, cssToDeviceRatio} from '@luma.gl/core';\n\nimport type {Framebuffer} from '@luma.gl/core';\nimport type Viewport from '../viewports/viewport';\nimport type View from '../views/view';\nimport type Layer from '../lib/layer';\nimport type {Effect} from '../lib/effect';\n\nexport type Rect = {x: number; y: number; width: number; height: number};\n\nexport type LayersPassRenderOptions = {\n  target?: Framebuffer;\n  isPicking?: boolean;\n  pass: string;\n  layers: Layer[];\n  viewports: Viewport[];\n  onViewportActive?: (viewport: Viewport) => void;\n  cullRect?: Rect;\n  views?: Record<string, View>;\n  effects?: Effect[];\n  /** If true, recalculates render index (z) from 0. Set to false if a stack of layers are rendered in multiple passes. */\n  clearStack?: boolean;\n  clearCanvas?: boolean;\n  layerFilter?: ((context: FilterContext) => boolean) | null;\n  moduleParameters?: any;\n  /** Stores returned results from Effect.preRender, for use downstream in the render pipeline */\n  preRenderStats?: Record<string, any>;\n};\n\ntype DrawLayerParameters = {\n  shouldDrawLayer: boolean;\n  layerRenderIndex?: number;\n  moduleParameters?: any;\n  layerParameters?: any;\n};\n\nexport type FilterContext = {\n  layer: Layer;\n  viewport: Viewport;\n  isPicking: boolean;\n  renderPass: string;\n  cullRect?: Rect;\n};\n\nexport type RenderStats = {\n  totalCount: number;\n  visibleCount: number;\n  compositeCount: number;\n  pickableCount: number;\n};\n\nexport default class LayersPass extends Pass {\n  _lastRenderIndex: number = -1;\n\n  render(options: LayersPassRenderOptions): any {\n    const gl = this.gl;\n\n    setParameters(gl, {framebuffer: options.target});\n    return this._drawLayers(options);\n  }\n\n  // Draw a list of layers in a list of viewports\n  private _drawLayers(options: LayersPassRenderOptions) {\n    const {\n      target,\n      moduleParameters,\n      viewports,\n      views,\n      onViewportActive,\n      clearStack = true,\n      clearCanvas = true\n    } = options;\n    options.pass = options.pass || 'unknown';\n\n    const gl = this.gl;\n    if (clearCanvas) {\n      clearGLCanvas(gl, target);\n    }\n\n    if (clearStack) {\n      this._lastRenderIndex = -1;\n    }\n\n    const renderStats: RenderStats[] = [];\n\n    for (const viewport of viewports) {\n      const view = views && views[viewport.id];\n\n      // Update context to point to this viewport\n      onViewportActive?.(viewport);\n\n      const drawLayerParams = this._getDrawLayerParams(viewport, options);\n\n      // render this viewport\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        const stats = this._drawLayersInViewport(\n          gl,\n          {\n            target,\n            moduleParameters,\n            viewport: subViewport,\n            view,\n            pass: options.pass,\n            layers: options.layers\n          },\n          drawLayerParams\n        );\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n\n  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),\n  // this is only done once for the parent viewport\n  /* Resolve the parameters needed to draw each layer */\n  protected _getDrawLayerParams(\n    viewport: Viewport,\n    {\n      layers,\n      pass,\n      isPicking = false,\n      layerFilter,\n      cullRect,\n      effects,\n      moduleParameters\n    }: LayersPassRenderOptions,\n    /** Internal flag, true if only used to determine whether each layer should be drawn */\n    evaluateShouldDrawOnly: boolean = false\n  ): DrawLayerParameters[] {\n    const drawLayerParams: DrawLayerParameters[] = [];\n    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n    const drawContext: FilterContext = {\n      layer: layers[0],\n      viewport,\n      isPicking,\n      renderPass: pass,\n      cullRect\n    };\n    const layerFilterCache = {};\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      // Check if we should draw layer\n      const shouldDrawLayer = this._shouldDrawLayer(\n        layer,\n        drawContext,\n        layerFilter,\n        layerFilterCache\n      );\n\n      const layerParam: DrawLayerParameters = {\n        shouldDrawLayer\n      };\n\n      if (shouldDrawLayer && !evaluateShouldDrawOnly) {\n        // This is the \"logical\" index for ordering this layer in the stack\n        // used to calculate polygon offsets\n        // It can be the same as another layer\n        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n\n        layerParam.moduleParameters = this._getModuleParameters(\n          layer,\n          effects,\n          pass,\n          moduleParameters\n        );\n        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);\n      }\n      drawLayerParams[layerIndex] = layerParam;\n    }\n    return drawLayerParams;\n  }\n\n  // Draws a list of layers in one viewport\n  // TODO - when picking we could completely skip rendering viewports that dont\n  // intersect with the picking rect\n  /* eslint-disable max-depth, max-statements */\n  private _drawLayersInViewport(\n    gl,\n    {layers, moduleParameters: globalModuleParameters, pass, target, viewport, view},\n    drawLayerParams\n  ): RenderStats {\n    const glViewport = getGLViewport(gl, {\n      moduleParameters: globalModuleParameters,\n      target,\n      viewport\n    });\n\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {color: true, depth: true} : view.props.clear;\n      withParameters(\n        gl,\n        {\n          scissorTest: true,\n          scissor: glViewport\n        },\n        () => clear(gl, clearOpts)\n      );\n    }\n\n    // render layers in normal colors\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n\n    setParameters(gl, {viewport: glViewport});\n\n    // render layers in normal colors\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const {shouldDrawLayer, layerRenderIndex, moduleParameters, layerParameters} =\n        drawLayerParams[layerIndex];\n\n      // Calculate stats\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      } else if (shouldDrawLayer) {\n        // Draw the layer\n        renderStatus.visibleCount++;\n\n        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n\n        // overwrite layer.context.viewport with the sub viewport\n        moduleParameters.viewport = viewport;\n\n        try {\n          layer._drawLayer({\n            moduleParameters,\n            uniforms: {layerIndex: layerRenderIndex},\n            parameters: layerParameters\n          });\n        } catch (err) {\n          layer.raiseError(err, `drawing ${layer} to ${pass}`);\n        }\n      }\n    }\n\n    return renderStatus;\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  /* Methods for subclass overrides */\n  shouldDrawLayer(layer: Layer): boolean {\n    return true;\n  }\n\n  protected getModuleParameters(layer: Layer, effects?: Effect[]): any {\n    return null;\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): any {\n    return layer.props.parameters;\n  }\n\n  /* Private */\n  private _shouldDrawLayer(\n    layer: Layer,\n    drawContext: FilterContext,\n    layerFilter: ((params: FilterContext) => boolean) | undefined | null,\n    layerFilterCache: Record<string, boolean>\n  ) {\n    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n\n    if (!shouldDrawLayer) {\n      return false;\n    }\n\n    drawContext.layer = layer;\n\n    let parent = layer.parent as Layer;\n    while (parent) {\n      // @ts-ignore\n      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n        return false;\n      }\n      drawContext.layer = parent;\n      parent = parent.parent as Layer;\n    }\n\n    if (layerFilter) {\n      const rootLayerId = drawContext.layer.id;\n      if (!(rootLayerId in layerFilterCache)) {\n        layerFilterCache[rootLayerId] = layerFilter(drawContext);\n      }\n      if (!layerFilterCache[rootLayerId]) {\n        return false;\n      }\n    }\n\n    // If a layer is drawn, update its viewportChanged flag\n    layer.activateViewport(drawContext.viewport);\n\n    return true;\n  }\n\n  private _getModuleParameters(\n    layer: Layer,\n    effects: Effect[] | undefined,\n    pass: string,\n    overrides: any\n  ): any {\n    const moduleParameters = Object.assign(\n      Object.create(layer.internalState?.propsInTransition || layer.props),\n      {\n        autoWrapLongitude: layer.wrapLongitude,\n        // @ts-ignore\n        viewport: layer.context.viewport,\n        // @ts-ignore\n        mousePosition: layer.context.mousePosition,\n        pickingActive: 0,\n        devicePixelRatio: cssToDeviceRatio(this.gl)\n      }\n    );\n\n    if (effects) {\n      for (const effect of effects) {\n        Object.assign(moduleParameters, effect.getModuleParameters?.(layer));\n      }\n    }\n\n    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n  }\n}\n\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(\n  startIndex: number = 0,\n  layerIndices: Record<string, number> = {}\n): (layer: Layer, isDrawn: boolean) => number {\n  const resolvers = {};\n\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n\n    let index;\n\n    if (parentId && !(parentId in layerIndices)) {\n      // Populate layerIndices with the parent layer's index\n      resolveLayerIndex(layer.parent, false);\n    }\n\n    if (parentId in resolvers) {\n      const resolver = (resolvers[parentId] =\n        resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices));\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      // Mark layer as needing its own resolver\n      // We don't actually create it until it's used for the first time\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n  return resolveLayerIndex;\n}\n\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(\n  gl,\n  {\n    moduleParameters,\n    target,\n    viewport\n  }: {\n    moduleParameters: any;\n    target?: Framebuffer;\n    viewport: Viewport;\n  }\n): [number, number, number, number] {\n  const useTarget = target && target.id !== 'default-framebuffer';\n  const pixelRatio =\n    (moduleParameters && moduleParameters.devicePixelRatio) || cssToDeviceRatio(gl);\n\n  // Default framebuffer is used when writing to canvas\n  const height = useTarget ? target.height : gl.drawingBufferHeight;\n\n  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n  const dimensions = viewport;\n  return [\n    dimensions.x * pixelRatio,\n    height - (dimensions.y + dimensions.height) * pixelRatio,\n    dimensions.width * pixelRatio,\n    dimensions.height * pixelRatio\n  ];\n}\n\nfunction clearGLCanvas(gl: WebGLRenderingContext, targetFramebuffer?: Framebuffer) {\n  const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;\n  const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;\n  // clear depth and color buffers, restoring transparency\n  setParameters(gl, {viewport: [0, 0, width, height]});\n  gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n}\n"],"mappings":";AACA,OAAOA,IAAP,MAAiB,QAAjB;AACA,SAAQC,KAAR,EAAeC,aAAf,EAA8BC,cAA9B,EAA8CC,gBAA9C,QAAqE,eAArE;AAmDA,eAAe,MAAMC,UAAN,SAAyBL,IAAzB,CAA8B;EAAAM,YAAA;IAAA,SAAAC,SAAA;IAAAC,eAAA,2BAChB,CAAC,CADe;EAAA;EAG3CC,MAAMA,CAACC,OAAD,EAAwC;IAC5C,MAAMC,EAAE,GAAG,KAAKA,EAAhB;IAEAT,aAAa,CAACS,EAAD,EAAK;MAACC,WAAW,EAAEF,OAAO,CAACG;IAAtB,CAAL,CAAb;IACA,OAAO,KAAKC,WAAL,CAAiBJ,OAAjB,CAAP;EACD;EAGOI,WAAWA,CAACJ,OAAD,EAAmC;IACpD,MAAM;MACJG,MADI;MAEJE,gBAFI;MAGJC,SAHI;MAIJC,KAJI;MAKJC,gBALI;MAMJC,UAAU,GAAG,IANT;MAOJC,WAAW,GAAG;IAPV,IAQFV,OARJ;IASAA,OAAO,CAACW,IAAR,GAAeX,OAAO,CAACW,IAAR,IAAgB,SAA/B;IAEA,MAAMV,EAAE,GAAG,KAAKA,EAAhB;IACA,IAAIS,WAAJ,EAAiB;MACfE,aAAa,CAACX,EAAD,EAAKE,MAAL,CAAb;IACD;IAED,IAAIM,UAAJ,EAAgB;MACd,KAAKI,gBAAL,GAAwB,CAAC,CAAzB;IACD;IAED,MAAMC,WAA0B,GAAG,EAAnC;IAEA,KAAK,MAAMC,QAAX,IAAuBT,SAAvB,EAAkC;MAChC,MAAMU,IAAI,GAAGT,KAAK,IAAIA,KAAK,CAACQ,QAAQ,CAACE,EAAV,CAA3B;MAGAT,gBAAgB,SAAhB,IAAAA,gBAAgB,WAAhB,YAAAA,gBAAgB,CAAGO,QAAH,CAAhB;MAEA,MAAMG,eAAe,GAAG,KAAKC,mBAAL,CAAyBJ,QAAzB,EAAmCf,OAAnC,CAAxB;MAGA,MAAMoB,YAAY,GAAGL,QAAQ,CAACK,YAAT,IAAyB,CAACL,QAAD,CAA9C;MACA,KAAK,MAAMM,WAAX,IAA0BD,YAA1B,EAAwC;QACtC,MAAME,KAAK,GAAG,KAAKC,qBAAL,CACZtB,EADY,EAEZ;UACEE,MADF;UAEEE,gBAFF;UAGEU,QAAQ,EAAEM,WAHZ;UAIEL,IAJF;UAKEL,IAAI,EAAEX,OAAO,CAACW,IALhB;UAMEa,MAAM,EAAExB,OAAO,CAACwB;QANlB,CAFY,EAUZN,eAVY,CAAd;QAYAJ,WAAW,CAACW,IAAZ,CAAiBH,KAAjB;MACD;IACF;IACD,OAAOR,WAAP;EACD;EAKSK,mBAAmBA,CAC3BJ,QAD2B,EAAAW,IAAA,EAaJ;IAAA,IAXvB;MACEF,MADF;MAEEb,IAFF;MAGEgB,SAAS,GAAG,KAHd;MAIEC,WAJF;MAKEC,QALF;MAMEC,OANF;MAOEzB;IAPF,CAF2B,GAAAqB,IAAA;IAAA,IAY3BK,sBAA+B,GAAAlC,SAAA,CAAAmC,MAAA,QAAAnC,SAAA,QAAAoC,SAAA,GAAApC,SAAA,MAAG,KAZP;IAc3B,MAAMqB,eAAsC,GAAG,EAA/C;IACA,MAAMgB,aAAa,GAAGC,kBAAkB,CAAC,KAAKtB,gBAAL,GAAwB,CAAzB,CAAxC;IACA,MAAMuB,WAA0B,GAAG;MACjCC,KAAK,EAAEb,MAAM,CAAC,CAAD,CADoB;MAEjCT,QAFiC;MAGjCY,SAHiC;MAIjCW,UAAU,EAAE3B,IAJqB;MAKjCkB;IALiC,CAAnC;IAOA,MAAMU,gBAAgB,GAAG,EAAzB;IACA,KAAK,IAAIC,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGhB,MAAM,CAACQ,MAA7C,EAAqDQ,UAAU,EAA/D,EAAmE;MACjE,MAAMH,KAAK,GAAGb,MAAM,CAACgB,UAAD,CAApB;MAEA,MAAMC,eAAe,GAAG,KAAKC,gBAAL,CACtBL,KADsB,EAEtBD,WAFsB,EAGtBR,WAHsB,EAItBW,gBAJsB,CAAxB;MAOA,MAAMI,UAA+B,GAAG;QACtCF;MADsC,CAAxC;MAIA,IAAIA,eAAe,IAAI,CAACV,sBAAxB,EAAgD;QAI9CY,UAAU,CAACC,gBAAX,GAA8BV,aAAa,CAACG,KAAD,EAAQI,eAAR,CAA3C;QAEAE,UAAU,CAACtC,gBAAX,GAA8B,KAAKwC,oBAAL,CAC5BR,KAD4B,EAE5BP,OAF4B,EAG5BnB,IAH4B,EAI5BN,gBAJ4B,CAA9B;QAMAsC,UAAU,CAACG,eAAX,GAA6B,KAAKC,kBAAL,CAAwBV,KAAxB,EAA+BG,UAA/B,EAA2CzB,QAA3C,CAA7B;MACD;MACDG,eAAe,CAACsB,UAAD,CAAf,GAA8BG,UAA9B;IACD;IACD,OAAOzB,eAAP;EACD;EAMOK,qBAAqBA,CAC3BtB,EAD2B,EAAA+C,KAAA,EAG3B9B,eAH2B,EAId;IAAA,IAFb;MAACM,MAAD;MAASnB,gBAAgB,EAAE4C,sBAA3B;MAAmDtC,IAAnD;MAAyDR,MAAzD;MAAiEY,QAAjE;MAA2EC;IAA3E,CAF2B,GAAAgC,KAAA;IAK3B,MAAME,UAAU,GAAGC,aAAa,CAAClD,EAAD,EAAK;MACnCI,gBAAgB,EAAE4C,sBADiB;MAEnC9C,MAFmC;MAGnCY;IAHmC,CAAL,CAAhC;IAMA,IAAIC,IAAI,IAAIA,IAAI,CAACoC,KAAL,CAAW7D,KAAvB,EAA8B;MAC5B,MAAM8D,SAAS,GAAGrC,IAAI,CAACoC,KAAL,CAAW7D,KAAX,KAAqB,IAArB,GAA4B;QAAC+D,KAAK,EAAE,IAAR;QAAcC,KAAK,EAAE;MAArB,CAA5B,GAAyDvC,IAAI,CAACoC,KAAL,CAAW7D,KAAtF;MACAE,cAAc,CACZQ,EADY,EAEZ;QACEuD,WAAW,EAAE,IADf;QAEEC,OAAO,EAAEP;MAFX,CAFY,EAMZ,MAAM3D,KAAK,CAACU,EAAD,EAAKoD,SAAL,CANC,CAAd;IAQD;IAGD,MAAMK,YAAY,GAAG;MACnBC,UAAU,EAAEnC,MAAM,CAACQ,MADA;MAEnB4B,YAAY,EAAE,CAFK;MAGnBC,cAAc,EAAE,CAHG;MAInBC,aAAa,EAAE;IAJI,CAArB;IAOAtE,aAAa,CAACS,EAAD,EAAK;MAACc,QAAQ,EAAEmC;IAAX,CAAL,CAAb;IAGA,KAAK,IAAIV,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGhB,MAAM,CAACQ,MAA7C,EAAqDQ,UAAU,EAA/D,EAAmE;MACjE,MAAMH,KAAK,GAAGb,MAAM,CAACgB,UAAD,CAApB;MACA,MAAM;QAACC,eAAD;QAAkBG,gBAAlB;QAAoCvC,gBAApC;QAAsDyC;MAAtD,IACJ5B,eAAe,CAACsB,UAAD,CADjB;MAIA,IAAIC,eAAe,IAAIJ,KAAK,CAACe,KAAN,CAAYW,QAAnC,EAA6C;QAC3CL,YAAY,CAACI,aAAb;MACD;MACD,IAAIzB,KAAK,CAAC2B,WAAV,EAAuB;QACrBN,YAAY,CAACG,cAAb;MACD,CAFD,MAEO,IAAIpB,eAAJ,EAAqB;QAE1BiB,YAAY,CAACE,YAAb;QAEA,KAAK/C,gBAAL,GAAwBoD,IAAI,CAACC,GAAL,CAAS,KAAKrD,gBAAd,EAAgC+B,gBAAhC,CAAxB;QAGAvC,gBAAgB,CAACU,QAAjB,GAA4BA,QAA5B;QAEA,IAAI;UACFsB,KAAK,CAAC8B,UAAN,CAAiB;YACf9D,gBADe;YAEf+D,QAAQ,EAAE;cAAC5B,UAAU,EAAEI;YAAb,CAFK;YAGfyB,UAAU,EAAEvB;UAHG,CAAjB;QAKD,CAND,CAME,OAAOwB,GAAP,EAAY;UACZjC,KAAK,CAACkC,UAAN,CAAiBD,GAAjB,aAAAE,MAAA,CAAiCnC,KAAjC,UAAAmC,MAAA,CAA6C7D,IAA7C;QACD;MACF;IACF;IAED,OAAO+C,YAAP;EACD;EAIDjB,eAAeA,CAACJ,KAAD,EAAwB;IACrC,OAAO,IAAP;EACD;EAESoC,mBAAmBA,CAACpC,KAAD,EAAeP,OAAf,EAAwC;IACnE,OAAO,IAAP;EACD;EAESiB,kBAAkBA,CAACV,KAAD,EAAeG,UAAf,EAAmCzB,QAAnC,EAA4D;IACtF,OAAOsB,KAAK,CAACe,KAAN,CAAYiB,UAAnB;EACD;EAGO3B,gBAAgBA,CACtBL,KADsB,EAEtBD,WAFsB,EAGtBR,WAHsB,EAItBW,gBAJsB,EAKtB;IACA,MAAME,eAAe,GAAGJ,KAAK,CAACe,KAAN,CAAYsB,OAAZ,IAAuB,KAAKjC,eAAL,CAAqBJ,KAArB,CAA/C;IAEA,IAAI,CAACI,eAAL,EAAsB;MACpB,OAAO,KAAP;IACD;IAEDL,WAAW,CAACC,KAAZ,GAAoBA,KAApB;IAEA,IAAIsC,MAAM,GAAGtC,KAAK,CAACsC,MAAnB;IACA,OAAOA,MAAP,EAAe;MAEb,IAAI,CAACA,MAAM,CAACvB,KAAP,CAAasB,OAAd,IAAyB,CAACC,MAAM,CAACC,cAAP,CAAsBxC,WAAtB,CAA9B,EAAkE;QAChE,OAAO,KAAP;MACD;MACDA,WAAW,CAACC,KAAZ,GAAoBsC,MAApB;MACAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;IACD;IAED,IAAI/C,WAAJ,EAAiB;MACf,MAAMiD,WAAW,GAAGzC,WAAW,CAACC,KAAZ,CAAkBpB,EAAtC;MACA,IAAI,EAAE4D,WAAW,IAAItC,gBAAjB,CAAJ,EAAwC;QACtCA,gBAAgB,CAACsC,WAAD,CAAhB,GAAgCjD,WAAW,CAACQ,WAAD,CAA3C;MACD;MACD,IAAI,CAACG,gBAAgB,CAACsC,WAAD,CAArB,EAAoC;QAClC,OAAO,KAAP;MACD;IACF;IAGDxC,KAAK,CAACyC,gBAAN,CAAuB1C,WAAW,CAACrB,QAAnC;IAEA,OAAO,IAAP;EACD;EAEO8B,oBAAoBA,CAC1BR,KAD0B,EAE1BP,OAF0B,EAG1BnB,IAH0B,EAI1BoE,SAJ0B,EAKrB;IAAA,IAAAC,oBAAA;IACL,MAAM3E,gBAAgB,GAAG4E,MAAM,CAACC,MAAP,CACvBD,MAAM,CAACE,MAAP,CAAc,EAAAH,oBAAA,GAAA3C,KAAK,CAAC+C,aAAN,cAAAJ,oBAAA,uBAAAA,oBAAA,CAAqBK,iBAArB,KAA0ChD,KAAK,CAACe,KAA9D,CADuB,EAEvB;MACEkC,iBAAiB,EAAEjD,KAAK,CAACkD,aAD3B;MAGExE,QAAQ,EAAEsB,KAAK,CAACmD,OAAN,CAAczE,QAH1B;MAKE0E,aAAa,EAAEpD,KAAK,CAACmD,OAAN,CAAcC,aAL/B;MAMEC,aAAa,EAAE,CANjB;MAOEC,gBAAgB,EAAEjG,gBAAgB,CAAC,KAAKO,EAAN;IAPpC,CAFuB,CAAzB;IAaA,IAAI6B,OAAJ,EAAa;MACX,KAAK,MAAM8D,MAAX,IAAqB9D,OAArB,EAA8B;QAAA,IAAA+D,qBAAA;QAC5BZ,MAAM,CAACC,MAAP,CAAc7E,gBAAd,GAAAwF,qBAAA,GAAgCD,MAAM,CAACnB,mBAAvC,cAAAoB,qBAAA,uBAAgCA,qBAAA,CAAAC,IAAA,CAAAF,MAAM,EAAuBvD,KAAvB,CAAtC;MACD;IACF;IAED,OAAO4C,MAAM,CAACC,MAAP,CAAc7E,gBAAd,EAAgC,KAAKoE,mBAAL,CAAyBpC,KAAzB,EAAgCP,OAAhC,CAAhC,EAA0EiD,SAA1E,CAAP;EACD;AArR0C;AA8R7C,OAAO,SAAS5C,kBAATA,CAAA,EAGuC;EAAA,IAF5C4D,UAAkB,GAAAlG,SAAA,CAAAmC,MAAA,QAAAnC,SAAA,QAAAoC,SAAA,GAAApC,SAAA,MAAG,CADhB;EAAA,IAELmG,YAAoC,GAAAnG,SAAA,CAAAmC,MAAA,QAAAnC,SAAA,QAAAoC,SAAA,GAAApC,SAAA,MAAG,EAFlC;EAIL,MAAMoG,SAAS,GAAG,EAAlB;EAEA,MAAMC,iBAAiB,GAAGA,CAAC7D,KAAD,EAAQ8D,OAAR,KAAoB;IAC5C,MAAMC,aAAa,GAAG/D,KAAK,CAACe,KAAN,CAAYiD,OAAlC;IACA,MAAMC,OAAO,GAAGjE,KAAK,CAACpB,EAAtB;IACA,MAAMsF,QAAQ,GAAGlE,KAAK,CAACsC,MAAN,IAAgBtC,KAAK,CAACsC,MAAN,CAAa1D,EAA9C;IAEA,IAAIuF,KAAJ;IAEA,IAAID,QAAQ,IAAI,EAAEA,QAAQ,IAAIP,YAAd,CAAhB,EAA6C;MAE3CE,iBAAiB,CAAC7D,KAAK,CAACsC,MAAP,EAAe,KAAf,CAAjB;IACD;IAED,IAAI4B,QAAQ,IAAIN,SAAhB,EAA2B;MACzB,MAAMQ,QAAQ,GAAIR,SAAS,CAACM,QAAD,CAAT,GAChBN,SAAS,CAACM,QAAD,CAAT,IAAuBpE,kBAAkB,CAAC6D,YAAY,CAACO,QAAD,CAAb,EAAyBP,YAAzB,CAD3C;MAEAQ,KAAK,GAAGC,QAAQ,CAACpE,KAAD,EAAQ8D,OAAR,CAAhB;MACAF,SAAS,CAACK,OAAD,CAAT,GAAqBG,QAArB;IACD,CALD,MAKO,IAAIC,MAAM,CAACC,QAAP,CAAgBP,aAAhB,CAAJ,EAAoC;MACzCI,KAAK,GAAGJ,aAAa,IAAIJ,YAAY,CAACO,QAAD,CAAZ,IAA0B,CAA9B,CAArB;MAGAN,SAAS,CAACK,OAAD,CAAT,GAAqB,IAArB;IACD,CALM,MAKA;MACLE,KAAK,GAAGT,UAAR;IACD;IAED,IAAII,OAAO,IAAIK,KAAK,IAAIT,UAAxB,EAAoC;MAClCA,UAAU,GAAGS,KAAK,GAAG,CAArB;IACD;IAEDR,YAAY,CAACM,OAAD,CAAZ,GAAwBE,KAAxB;IACA,OAAOA,KAAP;EACD,CAhCD;EAiCA,OAAON,iBAAP;AACD;AAGD,SAAS/C,aAATA,CACElD,EADF,EAAA2G,KAAA,EAWoC;EAAA,IATlC;IACEvG,gBADF;IAEEF,MAFF;IAGEY;EAHF,CAFF,GAAA6F,KAAA;EAYE,MAAMC,SAAS,GAAG1G,MAAM,IAAIA,MAAM,CAACc,EAAP,KAAc,qBAA1C;EACA,MAAM6F,UAAU,GACbzG,gBAAgB,IAAIA,gBAAgB,CAACsF,gBAAtC,IAA2DjG,gBAAgB,CAACO,EAAD,CAD7E;EAIA,MAAM8G,MAAM,GAAGF,SAAS,GAAG1G,MAAM,CAAC4G,MAAV,GAAmB9G,EAAE,CAAC+G,mBAA9C;EAGA,MAAMC,UAAU,GAAGlG,QAAnB;EACA,OAAO,CACLkG,UAAU,CAACC,CAAX,GAAeJ,UADV,EAELC,MAAM,GAAG,CAACE,UAAU,CAACE,CAAX,GAAeF,UAAU,CAACF,MAA3B,IAAqCD,UAFzC,EAGLG,UAAU,CAACG,KAAX,GAAmBN,UAHd,EAILG,UAAU,CAACF,MAAX,GAAoBD,UAJf,CAAP;AAMD;AAED,SAASlG,aAATA,CAAuBX,EAAvB,EAAkDoH,iBAAlD,EAAmF;EACjF,MAAMD,KAAK,GAAGC,iBAAiB,GAAGA,iBAAiB,CAACD,KAArB,GAA6BnH,EAAE,CAACqH,kBAA/D;EACA,MAAMP,MAAM,GAAGM,iBAAiB,GAAGA,iBAAiB,CAACN,MAArB,GAA8B9G,EAAE,CAAC+G,mBAAjE;EAEAxH,aAAa,CAACS,EAAD,EAAK;IAACc,QAAQ,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAOqG,KAAP,EAAcL,MAAd;EAAX,CAAL,CAAb;EACA9G,EAAE,CAACV,KAAH,CAAS,WAAT;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}