{"ast":null,"code":"import { log } from '@deck.gl/core';\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nexport function buildMapping(_ref) {\n  let {\n    characterSet,\n    getFontWidth,\n    fontHeight,\n    buffer,\n    maxCanvasWidth,\n    mapping = {},\n    xOffset = 0,\n    yOffset = 0\n  } = _ref;\n  let row = 0;\n  let x = xOffset;\n  const rowHeight = fontHeight + buffer * 2;\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      const width = getFontWidth(char);\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * rowHeight + buffer,\n        width,\n        height: rowHeight,\n        layoutWidth: width,\n        layoutHeight: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    var _mapping$character;\n    const character = text[i];\n    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.layoutWidth) || 0;\n  }\n  return width;\n}\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n  return rowOffsetLeft;\n}\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n    if (groupEndCharIndex > groupStartCharIndex) {\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n  return rowOffsetLeft;\n}\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping) {\n  let startIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let endIndex = arguments.length > 5 ? arguments[5] : undefined;\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n  const result = [];\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n  return result;\n}\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        rowHeight = frame.layoutHeight;\n      }\n      leftOffsets[i] = x + frame.layoutWidth / 2;\n      x += frame.layoutWidth;\n    } else {\n      log.warn(\"Missing character: \".concat(character, \" (\").concat(character.codePointAt(0), \")\"))();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n  const size = [0, 0];\n  const rowSize = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n        for (let j = rowStart; j < rowEnd; j++) {\n          var _iconMapping$char;\n          const char = characters[j];\n          const layoutOffsetY = ((_iconMapping$char = iconMapping[char]) === null || _iconMapping$char === void 0 ? void 0 : _iconMapping$char.layoutOffsetY) || 0;\n          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;\n          rowWidth[j] = rowSize[0];\n        }\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n      lineStartIndex = lineEndIndex;\n    }\n    if (char === '\\n') {\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n  size[1] = rowOffsetTop;\n  return {\n    x,\n    y,\n    rowWidth,\n    size\n  };\n}\nexport function getTextFromBuffer(_ref2) {\n  let {\n    value,\n    length,\n    stride,\n    offset,\n    startIndices,\n    characterSet\n  } = _ref2;\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set();\n  const texts = new Array(length);\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor;\n    codes = new ArrayType(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n    if (autoCharacterSet) {\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n  return {\n    texts,\n    characterCount\n  };\n}","map":{"version":3,"names":["log","MISSING_CHAR_WIDTH","SINGLE_LINE","nextPowOfTwo","number","Math","pow","ceil","log2","buildMapping","_ref","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","rowHeight","char","width","y","height","layoutWidth","layoutHeight","canvasHeight","getTextWidth","text","startIndex","endIndex","i","_mapping$character","character","breakAll","maxWidth","iconMapping","target","rowStartCharIndex","rowOffsetLeft","textWidth","push","breakWord","groupStartCharIndex","groupEndCharIndex","groupWidth","length","autoWrapping","wordBreak","arguments","undefined","result","transformRow","line","leftOffsets","rowSize","frame","warn","concat","codePointAt","transformParagraph","paragraph","lineHeight","characters","Array","from","numCharacters","rowWidth","autoWrappingEnabled","isFinite","size","rowOffsetTop","lineStartIndex","lineEndIndex","rows","rowIndex","rowStart","rowEnd","j","_iconMapping$char","layoutOffsetY","max","getTextFromBuffer","_ref2","value","stride","offset","startIndices","bytesPerElement","BYTES_PER_ELEMENT","elementStride","elementOffset","characterCount","autoCharacterSet","Set","texts","codes","ArrayType","constructor","index","codesAtIndex","subarray","String","fromCodePoint","apply","forEach","add","charCode"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js"],"sourcesContent":["import { log } from '@deck.gl/core';\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  let x = xOffset;\n  const rowHeight = fontHeight + buffer * 2;\n\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      const width = getFontWidth(char);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * rowHeight + buffer,\n        width,\n        height: rowHeight,\n        layoutWidth: width,\n        layoutHeight: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    var _mapping$character;\n\n    const character = text[i];\n    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.layoutWidth) || 0;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n\n  const result = [];\n\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n\n  return result;\n}\n\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n\n    if (frame) {\n      if (!rowHeight) {\n        rowHeight = frame.layoutHeight;\n      }\n\n      leftOffsets[i] = x + frame.layoutWidth / 2;\n      x += frame.layoutWidth;\n    } else {\n      log.warn(\"Missing character: \".concat(character, \" (\").concat(character.codePointAt(0), \")\"))();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n  const size = [0, 0];\n  const rowSize = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n\n        for (let j = rowStart; j < rowEnd; j++) {\n          var _iconMapping$char;\n\n          const char = characters[j];\n          const layoutOffsetY = ((_iconMapping$char = iconMapping[char]) === null || _iconMapping$char === void 0 ? void 0 : _iconMapping$char.layoutOffsetY) || 0;\n          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  size[1] = rowOffsetTop;\n  return {\n    x,\n    y,\n    rowWidth,\n    size\n  };\n}\nexport function getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set();\n  const texts = new Array(length);\n  let codes = value;\n\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor;\n    codes = new ArrayType(characterCount);\n\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n\n    if (autoCharacterSet) {\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n\n  return {\n    texts,\n    characterCount\n  };\n}\n//# sourceMappingURL=utils.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}