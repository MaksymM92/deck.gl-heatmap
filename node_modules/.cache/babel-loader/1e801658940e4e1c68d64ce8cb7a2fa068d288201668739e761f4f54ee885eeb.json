{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION } from '../utils/aggregation-operation-utils';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport { pointToDensityGridDataCPU } from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  extruded: false,\n  material: true\n};\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nexport default class GPUGridLayer extends GridAggregationLayer {\n  initializeState(_ref) {\n    let {\n      gl\n    } = _ref;\n    const isSupported = GPUGridAggregator.isSupported(gl);\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false,\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      color: {\n        size: 3,\n        accessor: 'getColorWeight'\n      },\n      elevation: {\n        size: 3,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      return;\n    }\n    super.updateState(opts);\n    const {\n      aggregationDirty\n    } = this.state;\n    if (aggregationDirty) {\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n  getHashKeyForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n    const lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n    return \"\".concat(latIdx, \"-\").concat(lonIdx);\n  }\n  getPositionForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n  getPickingInfo(_ref2) {\n    let {\n      info,\n      mode\n    } = _ref2;\n    const {\n      index\n    } = info;\n    let object = null;\n    if (index >= 0) {\n      const {\n        gpuGridAggregator\n      } = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n      if (mode !== 'hover') {\n        const {\n          props\n        } = this;\n        let {\n          gridHash\n        } = this.state;\n        if (!gridHash) {\n          const {\n            gridOffset,\n            translation,\n            boundingBox\n          } = this.state;\n          const {\n            viewport\n          } = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({\n            gridHash\n          });\n        }\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n    info.picked = Boolean(object);\n    info.object = object;\n    return info;\n  }\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const {\n      weights,\n      numRow,\n      numCol,\n      gridOrigin,\n      gridOffset\n    } = this.state;\n    const {\n      color,\n      elevation\n    } = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n    return new SubLayerClass({\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n      colorRange,\n      elevationRange,\n      colorDomain,\n      elevationDomain,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationScale,\n      extruded\n    }, this.getSubLayerProps({\n      id: 'gpu-grid-cell'\n    }), {\n      data: {\n        attributes: {\n          colors: color.aggregationBuffer,\n          elevations: elevation.aggregationBuffer\n        }\n      },\n      colorMaxMinBuffer: color.maxMinBuffer,\n      elevationMaxMinBuffer: elevation.maxMinBuffer,\n      numInstances: numCol * numRow\n    });\n  }\n  finalizeState(context) {\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {\n        aggregationBuffer,\n        maxMinBuffer\n      } = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    });\n    super.finalizeState(context);\n  }\n  updateAggregationState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const {\n      cellSize,\n      coordinateSystem\n    } = props;\n    const {\n      viewport\n    } = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {\n      dimensions\n    } = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n    let {\n      boundingBox\n    } = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({\n        boundingBox\n      });\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {\n        gridOffset,\n        translation,\n        width,\n        height,\n        numCol,\n        numRow\n      } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n    const aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {\n      dimension: dimensions.data,\n      compareAll: true\n    });\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n  _updateAccessors(opts) {\n    const {\n      colorAggregation,\n      elevationAggregation\n    } = opts.props;\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n}\n_defineProperty(GPUGridLayer, \"layerName\", 'GPUGridLayer');\n_defineProperty(GPUGridLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["_defineProperty","Buffer","log","GPUGridAggregator","AGGREGATION_OPERATION","defaultColorRange","colorRangeToFlatArray","GPUGridCellLayer","pointToDensityGridDataCPU","GridAggregationLayer","getBoundingBox","getGridParams","defaultProps","colorDomain","colorRange","getColorWeight","type","value","colorAggregation","elevationDomain","elevationRange","getElevationWeight","elevationAggregation","elevationScale","min","cellSize","max","coverage","getPosition","x","position","extruded","material","DIMENSIONS","data","props","POSITION_ATTRIBUTE_NAME","GPUGridLayer","initializeState","_ref","gl","isSupported","error","initializeAggregationLayer","dimensions","setState","gpuAggregation","projectPoints","weights","color","needMin","needMax","combineMaxMin","maxMinBuffer","byteLength","accessor","size","divisor","elevation","positionAttributeName","attributeManager","getAttributeManager","add","fp64","use64bitPositions","updateState","opts","state","aggregationDirty","gridHash","getHashKeyForIndex","index","numRow","numCol","boundingBox","gridOffset","gridSize","gridOrigin","xMin","yMin","xOffset","yOffset","yIndex","Math","floor","xIndex","latIdx","lonIdx","concat","getPositionForIndex","yPos","xPos","getPickingInfo","_ref2","info","mode","object","gpuGridAggregator","colorInfo","getAggregationData","pixelIndex","getData","elevationInfo","colorValue","cellWeight","elevationValue","count","cellCount","totalCount","translation","viewport","context","attributes","getAttributes","cpuAggregation","key","cpuAggregationData","Object","assign","picked","Boolean","renderLayers","cellSizeMeters","SubLayerClass","getSubLayerClass","getSubLayerProps","id","colors","aggregationBuffer","elevations","colorMaxMinBuffer","elevationMaxMinBuffer","numInstances","finalizeState","forEach","weight","delete","updateAggregationState","oldProps","coordinateSystem","cellSizeChanged","positionsChanged","isAttributeChanged","attributesChanged","getNumInstances","width","height","allocateResources","aggregationDataDirty","isAggregationDirty","dimension","compareAll","_updateAccessors","operation"],"sources":["/Users/maks/Desktop/projects/geo-viz/node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-layer.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION } from '../utils/aggregation-operation-utils';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport { pointToDensityGridDataCPU } from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  extruded: false,\n  material: true\n};\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nexport default class GPUGridLayer extends GridAggregationLayer {\n  initializeState({\n    gl\n  }) {\n    const isSupported = GPUGridAggregator.isSupported(gl);\n\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false,\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      color: {\n        size: 3,\n        accessor: 'getColorWeight'\n      },\n      elevation: {\n        size: 3,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      return;\n    }\n\n    super.updateState(opts);\n    const {\n      aggregationDirty\n    } = this.state;\n\n    if (aggregationDirty) {\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n    const lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n    return \"\".concat(latIdx, \"-\").concat(lonIdx);\n  }\n\n  getPositionForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({\n    info,\n    mode\n  }) {\n    const {\n      index\n    } = info;\n    let object = null;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator\n      } = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n\n      if (mode !== 'hover') {\n        const {\n          props\n        } = this;\n        let {\n          gridHash\n        } = this.state;\n\n        if (!gridHash) {\n          const {\n            gridOffset,\n            translation,\n            boundingBox\n          } = this.state;\n          const {\n            viewport\n          } = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({\n            gridHash\n          });\n        }\n\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    info.picked = Boolean(object);\n    info.object = object;\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const {\n      weights,\n      numRow,\n      numCol,\n      gridOrigin,\n      gridOffset\n    } = this.state;\n    const {\n      color,\n      elevation\n    } = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n    return new SubLayerClass({\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n      colorRange,\n      elevationRange,\n      colorDomain,\n      elevationDomain,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationScale,\n      extruded\n    }, this.getSubLayerProps({\n      id: 'gpu-grid-cell'\n    }), {\n      data: {\n        attributes: {\n          colors: color.aggregationBuffer,\n          elevations: elevation.aggregationBuffer\n        }\n      },\n      colorMaxMinBuffer: color.maxMinBuffer,\n      elevationMaxMinBuffer: elevation.maxMinBuffer,\n      numInstances: numCol * numRow\n    });\n  }\n\n  finalizeState(context) {\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {\n        aggregationBuffer,\n        maxMinBuffer\n      } = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    });\n    super.finalizeState(context);\n  }\n\n  updateAggregationState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const {\n      cellSize,\n      coordinateSystem\n    } = props;\n    const {\n      viewport\n    } = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {\n      dimensions\n    } = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n    let {\n      boundingBox\n    } = this.state;\n\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({\n        boundingBox\n      });\n    }\n\n    if (positionsChanged || cellSizeChanged) {\n      const {\n        gridOffset,\n        translation,\n        width,\n        height,\n        numCol,\n        numRow\n      } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {\n      dimension: dimensions.data,\n      compareAll: true\n    });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  _updateAccessors(opts) {\n    const {\n      colorAggregation,\n      elevationAggregation\n    } = opts.props;\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n\n}\n\n_defineProperty(GPUGridLayer, \"layerName\", 'GPUGridLayer');\n\n_defineProperty(GPUGridLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=gpu-grid-layer.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}